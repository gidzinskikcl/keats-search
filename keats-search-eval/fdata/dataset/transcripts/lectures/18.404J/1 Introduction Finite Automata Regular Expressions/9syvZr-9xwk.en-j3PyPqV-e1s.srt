1
00:00:00,000 --> 00:00:02,445
[SQUEAKING]

2
00:00:02,445 --> 00:00:04,401
[RUSTLING]

3
00:00:04,401 --> 00:00:06,357
[CLICKING]

4
00:00:06,357 --> 00:00:18,600

5
00:00:18,600 --> 00:00:21,660
MICHAEL SIPSER: So,
welcome, everybody,

6
00:00:21,660 --> 00:00:28,140
to the Fall 2020 online
Introduction to the Theory

7
00:00:28,140 --> 00:00:33,770
of Computing 18.404/6.840.

8
00:00:33,770 --> 00:00:36,290
My name is Mike Sipser.

9
00:00:36,290 --> 00:00:41,850
I'm going to be your instructor
for the semester in this class.

10
00:00:41,850 --> 00:00:45,020
So let me just tell you
what the course is about.

11
00:00:45,020 --> 00:00:47,625
Basically, it's going
to be in two halves.

12
00:00:47,625 --> 00:00:50,000
We're going to be talking
about what are the capabilities

13
00:00:50,000 --> 00:00:52,850
and limitations of computers--
of computer algorithms,

14
00:00:52,850 --> 00:00:55,130
really, computation.

15
00:00:55,130 --> 00:00:59,240
And the two parts of the
course are more or less divided

16
00:00:59,240 --> 00:01:01,568
in half.

17
00:01:01,568 --> 00:01:03,110
The first half of
the course is going

18
00:01:03,110 --> 00:01:06,275
to talk about a subject called
computability theory, which

19
00:01:06,275 --> 00:01:08,810
it really asks what
you can compute

20
00:01:08,810 --> 00:01:12,080
with an algorithm in principle.

21
00:01:12,080 --> 00:01:15,710
That's-- was an active area of
research in the earlier part

22
00:01:15,710 --> 00:01:17,090
of the 20th century.

23
00:01:17,090 --> 00:01:20,060
It's pretty much closed
off as a research subject

24
00:01:20,060 --> 00:01:23,330
these days, mainly
because they answered

25
00:01:23,330 --> 00:01:25,260
all of their big questions.

26
00:01:25,260 --> 00:01:28,850
And so a mathematical
field really only

27
00:01:28,850 --> 00:01:32,450
stays vital when it
has problems to solve,

28
00:01:32,450 --> 00:01:35,810
and they really solved all of
their interesting problems--

29
00:01:35,810 --> 00:01:37,280
for the most part, not 100%.

30
00:01:37,280 --> 00:01:42,383
But for the most part, it sort
of finished off in the 1950s--

31
00:01:42,383 --> 00:01:44,300
just to say a little bit
more about what we're

32
00:01:44,300 --> 00:01:45,800
going to talk about there.

33
00:01:45,800 --> 00:01:48,410
When you're interested to
know what kinds of problems

34
00:01:48,410 --> 00:01:50,540
you can solve with
an algorithm--

35
00:01:50,540 --> 00:01:52,280
there are problems
that you might

36
00:01:52,280 --> 00:01:54,350
want to solve that
you just can't solve.

37
00:01:54,350 --> 00:02:00,650
For example, given a
specification for a computer

38
00:02:00,650 --> 00:02:03,860
problem you want
to solve, whatever

39
00:02:03,860 --> 00:02:05,510
that specification might be--

40
00:02:05,510 --> 00:02:07,790
say your algorithm
actually is a sorting

41
00:02:07,790 --> 00:02:09,360
algorithm, for example--

42
00:02:09,360 --> 00:02:11,390
and you want to write
down that specification

43
00:02:11,390 --> 00:02:13,490
and have an automatic
verifier that's

44
00:02:13,490 --> 00:02:16,830
going to check whether a
program meets the specification.

45
00:02:16,830 --> 00:02:20,330
Well, that's just in
principle impossible.

46
00:02:20,330 --> 00:02:26,360
You cannot make a verifier
which is going to answer,

47
00:02:26,360 --> 00:02:29,360
in all cases, whether or not
a program meets a certain

48
00:02:29,360 --> 00:02:30,950
specification.

49
00:02:30,950 --> 00:02:35,030
So with things like that,
we will prove this semester.

50
00:02:35,030 --> 00:02:37,730
Questions about
mathematical truth--

51
00:02:37,730 --> 00:02:39,980
if you're given a mathematical
statement, is it true

52
00:02:39,980 --> 00:02:41,870
or is it false?

53
00:02:41,870 --> 00:02:45,027
It'd be great if you can
write a computer program that

54
00:02:45,027 --> 00:02:46,110
would answer that problem.

55
00:02:46,110 --> 00:02:47,930
Well, it would not be great
if you were a mathematician,

56
00:02:47,930 --> 00:02:49,847
because that would put
us all out of business.

57
00:02:49,847 --> 00:02:53,390
But you can imagine that
might be a nice thing to have,

58
00:02:53,390 --> 00:02:54,200
but you can't.

59
00:02:54,200 --> 00:02:56,742
I mean, there is no algorithm
which can answer that question.

60
00:02:56,742 --> 00:02:59,090

61
00:02:59,090 --> 00:03:01,610
Well, along the way, we're
going to introduce models

62
00:03:01,610 --> 00:03:03,920
of computation, like finite
automata, which we'll

63
00:03:03,920 --> 00:03:07,160
see today, Turing machines,
and some other models

64
00:03:07,160 --> 00:03:08,990
that we'll see along the way.

65
00:03:08,990 --> 00:03:10,490
The second half of
the course, which

66
00:03:10,490 --> 00:03:11,960
is going to be
after the midterm,

67
00:03:11,960 --> 00:03:13,418
we're going to
shift gears and talk

68
00:03:13,418 --> 00:03:16,400
about complexity theory, which
is instead of looking at what's

69
00:03:16,400 --> 00:03:18,080
computable in
principle, you're going

70
00:03:18,080 --> 00:03:20,900
to look at what's computable
in practice, so things

71
00:03:20,900 --> 00:03:23,700
that you can solve in a
reasonable amount of time.

72
00:03:23,700 --> 00:03:27,080
And, for example,
I'm sure many of you

73
00:03:27,080 --> 00:03:30,260
are aware of the factoring
problem, which has connections

74
00:03:30,260 --> 00:03:38,720
to the RSA cryptosystem,
cryptography, and asks

75
00:03:38,720 --> 00:03:42,860
whether you can factor
big numbers quickly.

76
00:03:42,860 --> 00:03:46,470
That's a problem we
don't know the answer to.

77
00:03:46,470 --> 00:03:48,750
We just don't know how to
factor big numbers quickly.

78
00:03:48,750 --> 00:03:51,000
But it's possible that there
are algorithms out there

79
00:03:51,000 --> 00:03:53,220
that we haven't discovered
yet that can do so.

80
00:03:53,220 --> 00:03:55,290
It's connected with
this very famous problem

81
00:03:55,290 --> 00:03:57,780
in the intersection
of computer science

82
00:03:57,780 --> 00:04:00,060
and mathematics called the
P versus NP problem, which

83
00:04:00,060 --> 00:04:01,310
many of you may have heard of.

84
00:04:01,310 --> 00:04:02,400
We'll talk about that.

85
00:04:02,400 --> 00:04:06,300
We'll spend a lot of
time on that this term.

86
00:04:06,300 --> 00:04:08,580
And along the way, we'll
talk about different measures

87
00:04:08,580 --> 00:04:12,120
of complexity, of
computation, time and space,

88
00:04:12,120 --> 00:04:16,709
time and memory, theoretical
memory, electrical space.

89
00:04:16,709 --> 00:04:20,250
That's going to be a big part
of the course in the complexity

90
00:04:20,250 --> 00:04:21,120
theory part--

91
00:04:21,120 --> 00:04:23,070
introduce other
models of computation,

92
00:04:23,070 --> 00:04:27,000
such as probabilistic and
interactive computation.

93
00:04:27,000 --> 00:04:29,200
Talk about the
expectations of the course.

94
00:04:29,200 --> 00:04:31,860
First of all, prerequisites.

95
00:04:31,860 --> 00:04:35,770
There are a bunch of
prerequisites listed, 6.042,

96
00:04:35,770 --> 00:04:39,810
18.062 , or maybe some
other subject as well.

97
00:04:39,810 --> 00:04:43,140
The real thing is that
this is a math class.

98
00:04:43,140 --> 00:04:45,000
This is a class where--

99
00:04:45,000 --> 00:04:46,530
and it's not a
beginning math class,

100
00:04:46,530 --> 00:04:49,170
this is a moderate-to-advanced
math class.

101
00:04:49,170 --> 00:04:51,210
And I'm expecting
people to have had

102
00:04:51,210 --> 00:04:55,290
some prior experience,
of a substantial nature,

103
00:04:55,290 --> 00:05:00,090
with mathematical
theorems and proofs.

104
00:05:00,090 --> 00:05:02,820
We'll start off slow, but we're
going to ramp up pretty fast.

105
00:05:02,820 --> 00:05:06,940
So if you haven't
really got the idea

106
00:05:06,940 --> 00:05:09,550
or gotten comfortable with
doing proofs, coming up

107
00:05:09,550 --> 00:05:12,010
with proofs to
mathematical statements,

108
00:05:12,010 --> 00:05:14,530
that's going to be a concern.

109
00:05:14,530 --> 00:05:16,600
I would just be
monitoring yourself

110
00:05:16,600 --> 00:05:18,250
and seeing how you're doing.

111
00:05:18,250 --> 00:05:21,430
Because the homeworks
and the exams

112
00:05:21,430 --> 00:05:23,470
are going to count on
your being able to produce

113
00:05:23,470 --> 00:05:28,090
proofs, and so you're
going to be struggling

114
00:05:28,090 --> 00:05:30,010
if that's going to be a real--

115
00:05:30,010 --> 00:05:33,670
something that you haven't
had experience with.

116
00:05:33,670 --> 00:05:35,740
And let me talk a little
bit about the role

117
00:05:35,740 --> 00:05:39,070
of theory in computer science.

118
00:05:39,070 --> 00:05:43,330
This is a theory
class, as you know.

119
00:05:43,330 --> 00:05:47,150
So before we jump
into the material,

120
00:05:47,150 --> 00:05:48,970
I just thought it would
be worth it for you

121
00:05:48,970 --> 00:05:50,560
to give you at
least my perspective

122
00:05:50,560 --> 00:05:52,510
on the role of theoretical
computer science

123
00:05:52,510 --> 00:05:55,150
within the field.

124
00:05:55,150 --> 00:06:00,700
So I've been in computer
science for a long time.

125
00:06:00,700 --> 00:06:03,880
I go back-- I'm sure I'm
getting to be a dinosaur here--

126
00:06:03,880 --> 00:06:06,880
but I go back to the days
when you had punch cards.

127
00:06:06,880 --> 00:06:08,980
That's what we did when
I was an undergraduate.

128
00:06:08,980 --> 00:06:13,600
And, obviously, things
are very different now.

129
00:06:13,600 --> 00:06:17,560
And you can argue
that computer science

130
00:06:17,560 --> 00:06:21,970
as a discipline has matured,
and sort of the basic stuff

131
00:06:21,970 --> 00:06:23,770
has all been solved.

132
00:06:23,770 --> 00:06:25,870
Well, I would say there's
a certain truth to that,

133
00:06:25,870 --> 00:06:27,340
but there's a
certain way in which

134
00:06:27,340 --> 00:06:29,130
I would say that's not true.

135
00:06:29,130 --> 00:06:30,880
I think we're still
at the very beginning,

136
00:06:30,880 --> 00:06:33,790
at least in certain
respects, of computer science

137
00:06:33,790 --> 00:06:35,410
as a discipline.

138
00:06:35,410 --> 00:06:37,270
For one thing, there
are a lot of things

139
00:06:37,270 --> 00:06:42,490
that we do, a lot of things
relating to computation,

140
00:06:42,490 --> 00:06:45,160
that we just don't know
the answer to-- very

141
00:06:45,160 --> 00:06:46,120
fundamental things.

142
00:06:46,120 --> 00:06:49,840
Let's take as an example,
how does the brain work?

143
00:06:49,840 --> 00:06:52,180
Obviously, the brain computes
in a certain fashion.

144
00:06:52,180 --> 00:06:56,190

145
00:06:56,190 --> 00:06:58,560
And we've made good
progress, you can argue,

146
00:06:58,560 --> 00:07:04,030
with machine learning and all
of those things that have very--

147
00:07:04,030 --> 00:07:06,090
very powerful and
doing very cool things.

148
00:07:06,090 --> 00:07:15,030
But I would also say that at
some deeper level, the methods

149
00:07:15,030 --> 00:07:23,250
that we have so far don't allow
us to understand creativity.

150
00:07:23,250 --> 00:07:27,360
We're not close to being able to
create a computer program that

151
00:07:27,360 --> 00:07:29,550
can do mathematics
or that can do

152
00:07:29,550 --> 00:07:31,260
many of the creative
kinds of things

153
00:07:31,260 --> 00:07:32,400
that human beings can do.

154
00:07:32,400 --> 00:07:34,950

155
00:07:34,950 --> 00:07:37,170
I think machine learning,
powerful as it is,

156
00:07:37,170 --> 00:07:41,800
is really successful only for
a very narrow set of tasks.

157
00:07:41,800 --> 00:07:48,870
And so I think there's probably
something deeper and more

158
00:07:48,870 --> 00:07:51,060
fundamental going on
that we're missing.

159
00:07:51,060 --> 00:07:52,890
That would be my hunch.

160
00:07:52,890 --> 00:07:56,670
Now, whether something like
theoretical computer science is

161
00:07:56,670 --> 00:07:59,130
going to give you an answer
there-- or this kind of theory,

162
00:07:59,130 --> 00:08:00,810
or some kind of theory--

163
00:08:00,810 --> 00:08:04,500
I think some kind of theory
has at least a decent shot

164
00:08:04,500 --> 00:08:07,680
at playing a role in helping
us to understand computation

165
00:08:07,680 --> 00:08:09,240
in a deeper way.

166
00:08:09,240 --> 00:08:11,970
And the fact that we can't
understand something as basic

167
00:08:11,970 --> 00:08:16,260
as, can you factor a big
number quickly or not?

168
00:08:16,260 --> 00:08:18,600
You can't really say you
understand computation

169
00:08:18,600 --> 00:08:21,760
until you can answer
questions like that.

170
00:08:21,760 --> 00:08:24,210
So I would argue that
we have a really very

171
00:08:24,210 --> 00:08:27,090
primitive understanding of
computation at this stage

172
00:08:27,090 --> 00:08:32,490
and that there is a lot that
has yet to be discovered,

173
00:08:32,490 --> 00:08:34,169
not just on the
technological side,

174
00:08:34,169 --> 00:08:36,870
but just on the very fundamental
theoretical side that

175
00:08:36,870 --> 00:08:39,330
has a real shot at playing
a role in affecting

176
00:08:39,330 --> 00:08:42,600
the practice of how
we use computers.

177
00:08:42,600 --> 00:08:44,670
And so I think for
that reason-- again,

178
00:08:44,670 --> 00:08:47,340
I'm not sure what kind of theory
is going to be the most useful,

179
00:08:47,340 --> 00:08:49,560
but the theory we're going
to cover in this course

180
00:08:49,560 --> 00:08:51,270
is a particularly
elegant theory,

181
00:08:51,270 --> 00:08:54,240
and it has already paid
off in many applications

182
00:08:54,240 --> 00:08:56,860
and in terms of our
understanding of computation.

183
00:08:56,860 --> 00:09:00,360
And I think, at least
as a starting point,

184
00:09:00,360 --> 00:09:03,990
it's a good subject to learn.

185
00:09:03,990 --> 00:09:06,960
Certainly, I enjoy it, and
I've spent a good chunk

186
00:09:06,960 --> 00:09:11,140
of my career doing that.

187
00:09:11,140 --> 00:09:24,770
So let's move on then and begin
with the subject material.

188
00:09:24,770 --> 00:09:29,770
So we're going to talk
about models of computation,

189
00:09:29,770 --> 00:09:31,480
as I mentioned.

190
00:09:31,480 --> 00:09:34,310
We want to try to
understand computers,

191
00:09:34,310 --> 00:09:36,310
and we want to understand
what computers can do.

192
00:09:36,310 --> 00:09:39,160
But computers in the real world
are pretty complicated objects,

193
00:09:39,160 --> 00:09:41,900
and they're really not nice
to talk about mathematically.

194
00:09:41,900 --> 00:09:44,950
So we're going to talk about
abstract models of computers

195
00:09:44,950 --> 00:09:47,500
that are much simpler
but really capture--

196
00:09:47,500 --> 00:09:49,090
just like models in general--

197
00:09:49,090 --> 00:09:51,310
capture the important
aspects of the thing

198
00:09:51,310 --> 00:09:53,560
we're trying to understand.

199
00:09:53,560 --> 00:09:57,430
And so we're going to look
at several different kinds

200
00:09:57,430 --> 00:10:00,550
of models that vary in their
capabilities and the way

201
00:10:00,550 --> 00:10:03,900
they approximate
the real computers

202
00:10:03,900 --> 00:10:05,710
that we deal with every day.

203
00:10:05,710 --> 00:10:10,200
And for starters, we're going
to look at a very simple model

204
00:10:10,200 --> 00:10:12,000
called the finite automaton.

205
00:10:12,000 --> 00:10:15,210
And that's going to represent--

206
00:10:15,210 --> 00:10:17,370
you can think of it as
representing a computer that

207
00:10:17,370 --> 00:10:20,670
has a very small
amount of memory

208
00:10:20,670 --> 00:10:23,190
and a very limited and
small amount of memory.

209
00:10:23,190 --> 00:10:25,050
And we're going to look
at the capabilities

210
00:10:25,050 --> 00:10:26,610
of those kinds of machines.

211
00:10:26,610 --> 00:10:29,070
And what's nice about them is
that you can understand them

212
00:10:29,070 --> 00:10:30,700
very well.

213
00:10:30,700 --> 00:10:35,760
And so more powerful models that
we're going to look at later

214
00:10:35,760 --> 00:10:38,850
are going to be harder to
understand in as deep a way.

215
00:10:38,850 --> 00:10:46,015
But for these, we can develop
a very comprehensive theory.

216
00:10:46,015 --> 00:10:48,390
And so that's what we're going
to do for the next lecture

217
00:10:48,390 --> 00:10:50,540
and a half.

218
00:10:50,540 --> 00:10:53,370
So I'm starting off
with an example.

219
00:10:53,370 --> 00:10:58,430
I'm presenting a finite
automaton as a diagram--

220
00:10:58,430 --> 00:11:00,050
we call it a state diagram.

221
00:11:00,050 --> 00:11:07,670
It has these circles and
lines and labels on the lines

222
00:11:07,670 --> 00:11:09,720
and also on these circles.

223
00:11:09,720 --> 00:11:11,550
So what's going on here?

224
00:11:11,550 --> 00:11:13,220
So this is a finite automaton.

225
00:11:13,220 --> 00:11:14,960
I'm giving it the name M1.

226
00:11:14,960 --> 00:11:22,070
And it has-- these
circles are called states.

227
00:11:22,070 --> 00:11:25,240
So in this case, there were
three states, q1, q2, and q3.

228
00:11:25,240 --> 00:11:26,920
Those are the labels there.

229
00:11:26,920 --> 00:11:31,700
There are arrows connecting
states with each other.

230
00:11:31,700 --> 00:11:34,690
So these we'll call transitions.

231
00:11:34,690 --> 00:11:36,430
And they're going
to tell you how

232
00:11:36,430 --> 00:11:38,950
to compute with this device.

233
00:11:38,950 --> 00:11:42,250
And there's going to be a
specially-designated starting

234
00:11:42,250 --> 00:11:47,410
state, which has an arrow
coming in from nowhere.

235
00:11:47,410 --> 00:11:50,800
And there are other
specially-designated states

236
00:11:50,800 --> 00:11:52,390
called accepting
states, and that's

237
00:11:52,390 --> 00:11:54,490
going to have to do with
how the machine computes.

238
00:11:54,490 --> 00:11:57,700
But those are the ones that
have these double circles.

239
00:11:57,700 --> 00:12:00,730
And so talking about
the way it computes,

240
00:12:00,730 --> 00:12:02,870
the idea is pretty simple.

241
00:12:02,870 --> 00:12:04,990
The input is going to
be some finite string

242
00:12:04,990 --> 00:12:06,860
of 0's and 1's, in this case.

243
00:12:06,860 --> 00:12:09,610
We might have other types
of symbols that are allowed

244
00:12:09,610 --> 00:12:13,690
for other automata, but the
example that I have here,

245
00:12:13,690 --> 00:12:15,890
it's going to be 0's and 1's.

246
00:12:15,890 --> 00:12:17,740
And the way you
compute with the thing

247
00:12:17,740 --> 00:12:20,780
is you first put your finger--

248
00:12:20,780 --> 00:12:24,730
which I can't do on Zoom,
so I'll use the pointer--

249
00:12:24,730 --> 00:12:27,370
you put your pointer
on the starting state,

250
00:12:27,370 --> 00:12:30,430
the one that has the arrow
coming in from nowhere.

251
00:12:30,430 --> 00:12:33,880
First, you put
your pointer there.

252
00:12:33,880 --> 00:12:37,640
And then are you
start reading symbols

253
00:12:37,640 --> 00:12:40,170
from the input,
one after the next.

254
00:12:40,170 --> 00:12:44,180
So let's take an
example here, 01101.

255
00:12:44,180 --> 00:12:46,790
So you start reading
those symbols,

256
00:12:46,790 --> 00:12:48,810
and you follow
those transitions.

257
00:12:48,810 --> 00:12:50,900
So you go 0--

258
00:12:50,900 --> 00:12:52,550
and you go back
to the same state.

259
00:12:52,550 --> 00:12:54,890
Then you go-- the
next symbol is a 1,

260
00:12:54,890 --> 00:12:58,910
so you go over to this
state, from q1 to q2.

261
00:12:58,910 --> 00:13:01,110
Now you have another
one that comes in.

262
00:13:01,110 --> 00:13:03,770
So now you're starting at
q2, you have another one,

263
00:13:03,770 --> 00:13:06,150
so you follow its
associated transition.

264
00:13:06,150 --> 00:13:09,710
So if you notice,
every state has

265
00:13:09,710 --> 00:13:13,640
an outgoing transition for 1
and another outgoing transition

266
00:13:13,640 --> 00:13:14,330
for 0.

267
00:13:14,330 --> 00:13:17,690
So there's always somewhere to
go every time you read symbols

268
00:13:17,690 --> 00:13:18,660
from the input.

269
00:13:18,660 --> 00:13:20,270
So now you're at q2.

270
00:13:20,270 --> 00:13:23,420
You read that next, that
third symbol, which is a 1.

271
00:13:23,420 --> 00:13:25,760
That's going to
take you over to q3.

272
00:13:25,760 --> 00:13:28,040
And now you have a
0, which loops you

273
00:13:28,040 --> 00:13:32,840
back to where you were, and
another 1, which loops you

274
00:13:32,840 --> 00:13:34,010
back to where you were.

275
00:13:34,010 --> 00:13:39,920
And because you ended
up at an accept,

276
00:13:39,920 --> 00:13:44,180
you say we accept that string.

277
00:13:44,180 --> 00:13:49,100
So that's going to be the
output of this finite automaton.

278
00:13:49,100 --> 00:13:50,840
For each string,
it's either going

279
00:13:50,840 --> 00:13:52,650
to accept it or reject it.

280
00:13:52,650 --> 00:13:55,620
So it's just a binary decision
that is going to be made.

281
00:13:55,620 --> 00:13:57,410
It's sort of like
a 1 or a 0 output,

282
00:13:57,410 --> 00:13:59,850
but we're calling
it accept or reject.

283
00:13:59,850 --> 00:14:03,080
So this one here,
because it ended up

284
00:14:03,080 --> 00:14:05,430
at the accepting
state, is accepted.

285
00:14:05,430 --> 00:14:10,560
But if you look at the
second example, 00101,

286
00:14:10,560 --> 00:14:16,310
so you're going to
have 0, 0, 1, 0, 1.

287
00:14:16,310 --> 00:14:18,500
Now we ended up at q2.

288
00:14:18,500 --> 00:14:20,760
That's not an accepting state.

289
00:14:20,760 --> 00:14:25,350
So therefore, we say
we reject this input.

290
00:14:25,350 --> 00:14:25,850
OK?

291
00:14:25,850 --> 00:14:27,540
Very simple.

292
00:14:27,540 --> 00:14:29,390
And now, for example,
one of the questions

293
00:14:29,390 --> 00:14:31,432
you might want to ask,
given one of these things,

294
00:14:31,432 --> 00:14:34,100
is, well, which are
exactly those strings

295
00:14:34,100 --> 00:14:36,560
that the machine accepts?

296
00:14:36,560 --> 00:14:42,730
And a little bit of
thought will help

297
00:14:42,730 --> 00:14:46,060
you understand that
the only strings which

298
00:14:46,060 --> 00:14:49,000
are going to take you over
to q3 are those strings that

299
00:14:49,000 --> 00:14:52,510
have a 11 appearing
somewhere along the way, two

300
00:14:52,510 --> 00:14:55,810
consecutive 1's, and you will
end up at the accepting state.

301
00:14:55,810 --> 00:14:58,820

302
00:14:58,820 --> 00:15:01,180
I encourage you to think
about that for a minute

303
00:15:01,180 --> 00:15:02,890
if not immediately obvious.

304
00:15:02,890 --> 00:15:05,170
But those are the
strings that are going

305
00:15:05,170 --> 00:15:08,470
to be accepted by this machine.

306
00:15:08,470 --> 00:15:11,860
And we call that
collection of strings

307
00:15:11,860 --> 00:15:15,680
the language of the machine.

308
00:15:15,680 --> 00:15:19,880
So that set A of
those strings that

309
00:15:19,880 --> 00:15:24,680
have a 11, for this particular
machine, is the language of M1.

310
00:15:24,680 --> 00:15:30,000
We also say that M1 recognizes
that language, recognizes A.

311
00:15:30,000 --> 00:15:34,460
And in terms of notation,
we write that A is L of M1.

312
00:15:34,460 --> 00:15:36,290
A is the language of M1.

313
00:15:36,290 --> 00:15:39,470
So the language of a machine
is exactly the set of strings

314
00:15:39,470 --> 00:15:42,810
that machine accepts.

315
00:15:42,810 --> 00:15:43,995
OK?

316
00:15:43,995 --> 00:15:46,620
So one of the first things we're
going to want to be able to do

317
00:15:46,620 --> 00:15:48,720
is take a machine
and understand what

318
00:15:48,720 --> 00:15:50,580
its language is, what's
the set of strings

319
00:15:50,580 --> 00:15:51,900
that that machine accepts.

320
00:15:51,900 --> 00:15:54,300
Another thing we might want
to do is, given a language,

321
00:15:54,300 --> 00:15:59,370
build a machine which
recognizes that language.

322
00:15:59,370 --> 00:16:01,980
And then understanding, what
are the class of languages?

323
00:16:01,980 --> 00:16:04,038
Can you get any language
from some machine,

324
00:16:04,038 --> 00:16:06,330
or are there going to be some
languages that you can do

325
00:16:06,330 --> 00:16:08,172
and other languages
that you cannot do?

326
00:16:08,172 --> 00:16:09,630
So those are the
kinds of questions

327
00:16:09,630 --> 00:16:12,540
we're going to be asking
about these finite automata.

328
00:16:12,540 --> 00:16:15,180
What kinds of things
can those machines do,

329
00:16:15,180 --> 00:16:18,240
and what can they not do?

330
00:16:18,240 --> 00:16:20,520
OK.

331
00:16:20,520 --> 00:16:23,565
Here's our next check-in.

332
00:16:23,565 --> 00:16:27,300

333
00:16:27,300 --> 00:16:30,960
So wake up, everybody
who's not paying attention.

334
00:16:30,960 --> 00:16:33,180
A check-in is coming.

335
00:16:33,180 --> 00:16:34,950
So we have more
questions, though I

336
00:16:34,950 --> 00:16:39,550
can't keep-- are these
three statements equivalent?

337
00:16:39,550 --> 00:16:42,730
What three statements?

338
00:16:42,730 --> 00:16:45,580
AUDIENCE: At the
bottom of the slide.

339
00:16:45,580 --> 00:16:47,350
MICHAEL SIPSER: Oh,
oh, oh, oh, oh, yes.

340
00:16:47,350 --> 00:16:49,570
Those three are equivalent.

341
00:16:49,570 --> 00:16:52,010
A is the language-- yeah,
those mean the same thing.

342
00:16:52,010 --> 00:16:54,790
Not only are they equivalent,
but they're just different ways

343
00:16:54,790 --> 00:16:57,730
of saying the same thing.

344
00:16:57,730 --> 00:16:59,650
That M1 recognizes
the language is

345
00:16:59,650 --> 00:17:02,120
the same as saying that's
the language of the machine

346
00:17:02,120 --> 00:17:05,650
and that A equals
that L of M. That's

347
00:17:05,650 --> 00:17:09,310
all the same way of saying they
all-- six of one, half a dozen

348
00:17:09,310 --> 00:17:09,910
of the other.

349
00:17:09,910 --> 00:17:12,339
It's two ways of
saying the same thing.

350
00:17:12,339 --> 00:17:18,315
OK, so let's pop up our
poll and get that started.

351
00:17:18,315 --> 00:17:18,815
Whoops.

352
00:17:18,815 --> 00:17:21,430

353
00:17:21,430 --> 00:17:23,770
Still showing the old
one-- oh, here we go.

354
00:17:23,770 --> 00:17:26,015
Move it to the next question.

355
00:17:26,015 --> 00:17:26,515
OK.

356
00:17:26,515 --> 00:17:31,810

357
00:17:31,810 --> 00:17:37,410
OK, so you understand
the question here?

358
00:17:37,410 --> 00:17:40,645
Where do we end up
after we read 101?

359
00:17:40,645 --> 00:17:41,520
What state are we in?

360
00:17:41,520 --> 00:17:46,280

361
00:17:46,280 --> 00:17:49,625
Do we end up in
state q1, q2, or q3?

362
00:17:49,625 --> 00:17:52,300

363
00:17:52,300 --> 00:17:54,970
OK?

364
00:17:54,970 --> 00:17:57,120
Go fast.

365
00:17:57,120 --> 00:17:57,780
This is a--

366
00:17:57,780 --> 00:18:01,520

367
00:18:01,520 --> 00:18:08,200
OK, so I think we got
pretty much converged here.

368
00:18:08,200 --> 00:18:12,280
I think almost
everybody got it right.

369
00:18:12,280 --> 00:18:16,480
The answer is indeed that
you ended up in state q2.

370
00:18:16,480 --> 00:18:19,780
Because you go 1,
0, 1, and that's

371
00:18:19,780 --> 00:18:21,550
where you ended up, in state q2.

372
00:18:21,550 --> 00:18:24,190
So is this string accepted?

373
00:18:24,190 --> 00:18:27,220
No, because you didn't
end up at an accept state.

374
00:18:27,220 --> 00:18:30,520
So this machine rejects 101.

375
00:18:30,520 --> 00:18:35,050
OK, let's keep going.

376
00:18:35,050 --> 00:18:38,610
So now-- yeah.

377
00:18:38,610 --> 00:18:41,680

378
00:18:41,680 --> 00:18:45,100
OK, so now we gave
it this informal idea

379
00:18:45,100 --> 00:18:46,420
of a finite automaton.

380
00:18:46,420 --> 00:18:49,300
We're going to have to try to
get a formal definition now,

381
00:18:49,300 --> 00:18:52,570
which is going to be a more
mathematical way of saying

382
00:18:52,570 --> 00:18:56,250
the same thing that I just said.

383
00:18:56,250 --> 00:18:59,130
And the reason for having
a formal definition

384
00:18:59,130 --> 00:19:02,370
is, for one thing, it allows
us to be very precise.

385
00:19:02,370 --> 00:19:05,280
Then we'll know exactly what
we mean by a finite automaton,

386
00:19:05,280 --> 00:19:07,470
and it should answer any
questions about what counts

387
00:19:07,470 --> 00:19:08,790
and what doesn't count.

388
00:19:08,790 --> 00:19:12,970
It also is a way of
providing notation.

389
00:19:12,970 --> 00:19:15,540
So it'll help us
describe finite automata.

390
00:19:15,540 --> 00:19:19,860
And sometimes there might be an
automaton where the picture is

391
00:19:19,860 --> 00:19:22,530
just too big, so you might
want to be able to describe it

392
00:19:22,530 --> 00:19:25,530
in some mathematical
terminology rather

393
00:19:25,530 --> 00:19:26,670
than by giving a picture.

394
00:19:26,670 --> 00:19:28,045
Or maybe you're
going to be asked

395
00:19:28,045 --> 00:19:30,960
to give a family
of automata, where

396
00:19:30,960 --> 00:19:35,400
there is going to be a
parameter, N, associated

397
00:19:35,400 --> 00:19:38,190
with the class of
languages you're trying

398
00:19:38,190 --> 00:19:39,840
to describe with the automaton.

399
00:19:39,840 --> 00:19:42,870
And then it'll be more
helpful to describe it

400
00:19:42,870 --> 00:19:46,920
in this formal notation rather
than as a kind of a picture,

401
00:19:46,920 --> 00:19:49,980
because it might be
infinitely many pictures that

402
00:19:49,980 --> 00:19:52,000
are being needed.

403
00:19:52,000 --> 00:19:55,420
So maybe examples of
that will come up now.

404
00:19:55,420 --> 00:19:58,530
So a finite automaton,
we call it a 5-tuple.

405
00:19:58,530 --> 00:20:00,030
Don't be put off by that.

406
00:20:00,030 --> 00:20:02,490
A 5-tuple is just a
list of five things.

407
00:20:02,490 --> 00:20:06,480
So a finite automaton,
in our definition,

408
00:20:06,480 --> 00:20:09,090
is going to have
five components.

409
00:20:09,090 --> 00:20:11,970
It's going to have
Q, which is going

410
00:20:11,970 --> 00:20:13,650
to be a finite set
of states, so it's

411
00:20:13,650 --> 00:20:17,400
going to be a finite set,
which we'll designate

412
00:20:17,400 --> 00:20:19,890
as the states of the automaton.

413
00:20:19,890 --> 00:20:23,040
Sigma is the alphabet
symbols of the automaton,

414
00:20:23,040 --> 00:20:24,240
another finite set.

415
00:20:24,240 --> 00:20:26,790

416
00:20:26,790 --> 00:20:29,460
Delta is the
transition function.

417
00:20:29,460 --> 00:20:33,300
That tells us how the automaton
moves from state to state.

418
00:20:33,300 --> 00:20:37,650
Those describes how
those transition arrows--

419
00:20:37,650 --> 00:20:41,410
those arrows which connected
the states with each other--

420
00:20:41,410 --> 00:20:43,290
it describes them in
a mathematical way

421
00:20:43,290 --> 00:20:45,510
instead in terms of a picture.

422
00:20:45,510 --> 00:20:48,250
And the way I'm doing
that is with a function.

423
00:20:48,250 --> 00:20:51,430
So delta is a function
which takes two things.

424
00:20:51,430 --> 00:20:53,790
So I'm hoping you've seen
this notation before.

425
00:20:53,790 --> 00:20:56,502
I'll help you through
it once, but this

426
00:20:56,502 --> 00:20:57,960
is the kind of
thing I would expect

427
00:20:57,960 --> 00:20:59,290
you to have seen already.

428
00:20:59,290 --> 00:21:01,920
So we have Q cross sigma.

429
00:21:01,920 --> 00:21:09,150
So I'm going to give delta a
state and an alphabet symbol.

430
00:21:09,150 --> 00:21:11,880
So Q is states, sigma
is alphabet symbols.

431
00:21:11,880 --> 00:21:15,510
So you're going to get a
state and an alphabet symbol,

432
00:21:15,510 --> 00:21:18,040
and it's going to
give you back a state.

433
00:21:18,040 --> 00:21:26,980
So describing it kind of
a little bit more detail,

434
00:21:26,980 --> 00:21:33,400
delta, if you give it state
q and symbol a equals r,

435
00:21:33,400 --> 00:21:38,010
that means q, when you
read an a, you go to r.

436
00:21:38,010 --> 00:21:40,950
So that's the way this
picture gets translated

437
00:21:40,950 --> 00:21:44,490
into a mathematical
function, which

438
00:21:44,490 --> 00:21:47,420
describes those transitions.

439
00:21:47,420 --> 00:21:50,600
And then now q0 is going
to be the starting state.

440
00:21:50,600 --> 00:21:53,060
That's the one with the
arrow coming in from nowhere.

441
00:21:53,060 --> 00:21:56,510
And F is the set of
accepting states.

442
00:21:56,510 --> 00:21:59,360
So there's only going to
be one starting state,

443
00:21:59,360 --> 00:22:00,980
but there might be
several different--

444
00:22:00,980 --> 00:22:02,450
or possibly even 0--

445
00:22:02,450 --> 00:22:03,500
accepting states.

446
00:22:03,500 --> 00:22:07,550
That's all legal when we
have a finite automaton.

447
00:22:07,550 --> 00:22:09,520
And so in terms of
using the notation--

448
00:22:09,520 --> 00:22:12,020
going back to the machine that
we just had from the previous

449
00:22:12,020 --> 00:22:14,240
slide, which I've
given you here again--

450
00:22:14,240 --> 00:22:15,740
let me show you how
I would describe

451
00:22:15,740 --> 00:22:18,960
this using this notation that
comes out of the definition.

452
00:22:18,960 --> 00:22:21,050
So here is M1 again.

453
00:22:21,050 --> 00:22:26,330
It's this 5-tuple where Q
now is the set-- q1, q2, q3--

454
00:22:26,330 --> 00:22:29,480
that's the set of states.

455
00:22:29,480 --> 00:22:32,210
The input alphabet is 0, 1.

456
00:22:32,210 --> 00:22:34,730
It might vary in other automata.

457
00:22:34,730 --> 00:22:38,180
And f is the set q3,
which has only the element

458
00:22:38,180 --> 00:22:43,040
q3, because this has just
one accept state, q3.

459
00:22:43,040 --> 00:22:46,080
So I hope that's helpful.

460
00:22:46,080 --> 00:22:49,430
Oh, of course, I forgot the
transition function, which

461
00:22:49,430 --> 00:22:51,720
here I'm describing as a table.

462
00:22:51,720 --> 00:22:58,430
So the transition
function says if you

463
00:22:58,430 --> 00:23:01,580
have a state and
an input alphabet,

464
00:23:01,580 --> 00:23:04,070
you can look up in
the table where you're

465
00:23:04,070 --> 00:23:06,740
supposed to go under
the transition function

466
00:23:06,740 --> 00:23:12,440
according to the state
and the alphabet symbol

467
00:23:12,440 --> 00:23:13,830
that you're given.

468
00:23:13,830 --> 00:23:22,730
So, for example, if we were
in state q2 here getting a 0,

469
00:23:22,730 --> 00:23:27,590
then q2 goes back to q1
so that q2 on 0 is q1.

470
00:23:27,590 --> 00:23:32,080
But q2 on 1 here is q3.

471
00:23:32,080 --> 00:23:32,580
OK?

472
00:23:32,580 --> 00:23:36,990
So that's how that table
captures this picture.

473
00:23:36,990 --> 00:23:37,538
OK?

474
00:23:37,538 --> 00:23:38,580
And it's just a function.

475
00:23:38,580 --> 00:23:45,360
It's a way of representing a
function, a finite function,

476
00:23:45,360 --> 00:23:48,430
in terms of this table here.

477
00:23:48,430 --> 00:23:53,920
So I realize, for some
of you, this may be slow.

478
00:23:53,920 --> 00:23:55,410
We will ramp up
in speed, but I'm

479
00:23:55,410 --> 00:23:57,780
trying to get us all
together in terms

480
00:23:57,780 --> 00:24:01,620
of the language of the
course here at the beginning.

481
00:24:01,620 --> 00:24:07,800
OK, so now let's
talk about some more

482
00:24:07,800 --> 00:24:15,130
the computation, so
strings and languages.

483
00:24:15,130 --> 00:24:16,660
A string is just
a finite sequence

484
00:24:16,660 --> 00:24:18,490
of symbols from the alphabet.

485
00:24:18,490 --> 00:24:21,730

486
00:24:21,730 --> 00:24:25,000
This class is not going to
talk about infinite strings.

487
00:24:25,000 --> 00:24:28,490
All of our strings are
going to be finite.

488
00:24:28,490 --> 00:24:31,330
There's other mathematical
theories of automata

489
00:24:31,330 --> 00:24:33,280
and so on that talk
about infinite inputs

490
00:24:33,280 --> 00:24:34,210
and infinite strings.

491
00:24:34,210 --> 00:24:35,800
We're not going to
talk about that.

492
00:24:35,800 --> 00:24:39,120

493
00:24:39,120 --> 00:24:41,760
Maybe rarely, we'll
make it very clear,

494
00:24:41,760 --> 00:24:43,260
we'll talk about
an infinite string,

495
00:24:43,260 --> 00:24:46,140
but that's going
to be an exception.

496
00:24:46,140 --> 00:24:48,730
And a language is
a set of strings.

497
00:24:48,730 --> 00:24:56,190
That's the traditional way
that people in this subject

498
00:24:56,190 --> 00:24:57,510
refer to a set of strings.

499
00:24:57,510 --> 00:25:00,270
They call it a language--
really because the subject

500
00:25:00,270 --> 00:25:02,958
had its roots in
linguistics, actually.

501
00:25:02,958 --> 00:25:04,500
And they were talking
about-- they're

502
00:25:04,500 --> 00:25:08,620
trying to understand
languages, human languages.

503
00:25:08,620 --> 00:25:10,500
So this is just a
historical fact,

504
00:25:10,500 --> 00:25:13,230
and that's the
terminology that's stuck.

505
00:25:13,230 --> 00:25:15,540
OK, so two special string--

506
00:25:15,540 --> 00:25:17,850
a special string and
a special language.

507
00:25:17,850 --> 00:25:20,400
The empty string is
the string of length 0.

508
00:25:20,400 --> 00:25:23,040
This is a totally
legitimate string

509
00:25:23,040 --> 00:25:25,350
that you are going to
run into now and then.

510
00:25:25,350 --> 00:25:27,210
And there's the
empty language, which

511
00:25:27,210 --> 00:25:29,740
is the set with no strings.

512
00:25:29,740 --> 00:25:31,310
These are not the same.

513
00:25:31,310 --> 00:25:34,040
They're not even of the
same type of object.

514
00:25:34,040 --> 00:25:37,220
So don't confuse them
with one another.

515
00:25:37,220 --> 00:25:40,000
I mean, you can have
a set, a language,

516
00:25:40,000 --> 00:25:43,030
which has just one element,
which is the empty string.

517
00:25:43,030 --> 00:25:44,680
That is not the empty set.

518
00:25:44,680 --> 00:25:46,870
That is a set-- that is
not the empty language.

519
00:25:46,870 --> 00:25:49,400
That is a language that
has one element in it,

520
00:25:49,400 --> 00:25:51,010
namely, the empty string.

521
00:25:51,010 --> 00:25:54,020
So those are separate things.

522
00:25:54,020 --> 00:25:58,430
OK, so here's a little bit of
a mouthful here on the slide,

523
00:25:58,430 --> 00:26:03,590
defining what it means for an
automaton to accept its input--

524
00:26:03,590 --> 00:26:06,940
accepts its input string w.

525
00:26:06,940 --> 00:26:08,620
And we can define that formally.

526
00:26:08,620 --> 00:26:11,260
And it's a little
technical looking,

527
00:26:11,260 --> 00:26:14,150
it's really not that bad.

528
00:26:14,150 --> 00:26:17,740
So if you have your
input string w,

529
00:26:17,740 --> 00:26:19,870
which you can write as
a sequence of symbols

530
00:26:19,870 --> 00:26:26,740
in the alphabet-- w1, w2, dot
dot dot, wn, so like 01001.

531
00:26:26,740 --> 00:26:30,880
I'm just writing it out
symbol by symbol here.

532
00:26:30,880 --> 00:26:35,080
So what does it mean for the
machine to accept that input?

533
00:26:35,080 --> 00:26:38,130
So that means that there's
a sequence of states

534
00:26:38,130 --> 00:26:44,025
in the machine, sequence of
states of members of Q. So

535
00:26:44,025 --> 00:26:45,650
a sequence from Q,
these are the states

536
00:26:45,650 --> 00:26:50,450
of the machine that satisfy
these three properties down

537
00:26:50,450 --> 00:26:51,230
here.

538
00:26:51,230 --> 00:26:55,220
First of all-- and I'm
thinking about the sequence

539
00:26:55,220 --> 00:27:01,980
that the machine goes through
as it's processing the input w.

540
00:27:01,980 --> 00:27:04,770
So when does it accept w?

541
00:27:04,770 --> 00:27:08,220
If that sequence has the feature
that it starts at the start

542
00:27:08,220 --> 00:27:13,730
state, each state legally
follows the previous state

543
00:27:13,730 --> 00:27:17,420
according to the
transition function.

544
00:27:17,420 --> 00:27:22,570
So that says the i-th
member of the sequence

545
00:27:22,570 --> 00:27:25,300
is obtained by looking
at the previous one--

546
00:27:25,300 --> 00:27:29,320
the i minus first member of
that sequence, the i minus

547
00:27:29,320 --> 00:27:31,690
first state in that
sequence-- and then

548
00:27:31,690 --> 00:27:36,270
looking at what happens when
you take the i-th input symbol.

549
00:27:36,270 --> 00:27:39,330
So as you look at the previous
state and the next input

550
00:27:39,330 --> 00:27:41,158
symbol, you should
get the next state.

551
00:27:41,158 --> 00:27:42,450
That's all that this is saying.

552
00:27:42,450 --> 00:27:45,630
And this should happen for
each one of these guys.

553
00:27:45,630 --> 00:27:48,570
And lastly, for
this to be accepted,

554
00:27:48,570 --> 00:27:50,970
the very last member
here, where we ended up

555
00:27:50,970 --> 00:27:52,870
at the end of the input--

556
00:27:52,870 --> 00:27:55,170
so you only care about this
at the end of the input--

557
00:27:55,170 --> 00:27:58,780
you have to be in
an accepting state.

558
00:27:58,780 --> 00:28:01,290
So you can mathematically
capture this notion

559
00:28:01,290 --> 00:28:02,715
of going along this path.

560
00:28:02,715 --> 00:28:05,600

561
00:28:05,600 --> 00:28:07,300
And that's what--

562
00:28:07,300 --> 00:28:09,990
I'm just trying to illustrate
that we could describe

563
00:28:09,990 --> 00:28:10,990
all this very formally--

564
00:28:10,990 --> 00:28:12,760
I'm not saying that's the
best way to think about it all

565
00:28:12,760 --> 00:28:13,360
the time--

566
00:28:13,360 --> 00:28:15,350
but that it can be done.

567
00:28:15,350 --> 00:28:19,240
And I think that's something
worth appreciating.

568
00:28:19,240 --> 00:28:20,860
OK.

569
00:28:20,860 --> 00:28:23,110
So now in terms of, again,
getting back-- we've

570
00:28:23,110 --> 00:28:24,610
said this once
already, but in terms

571
00:28:24,610 --> 00:28:27,010
of the languages that
the machine recognizes,

572
00:28:27,010 --> 00:28:30,710
it's the collection of strings
that the machine accepts.

573
00:28:30,710 --> 00:28:35,240
Every machine accepts-- it
might accept many strings,

574
00:28:35,240 --> 00:28:39,890
but it always recognizes
one particular language,

575
00:28:39,890 --> 00:28:41,740
even if the machine
accepts no strings--

576
00:28:41,740 --> 00:28:44,330
then it recognizes
the empty language.

577
00:28:44,330 --> 00:28:48,430
So a machine always
recognizes one language,

578
00:28:48,430 --> 00:28:51,970
but it may have many, many
strings that it's accepting.

579
00:28:51,970 --> 00:28:54,760
And we call that language
the language of the machine.

580
00:28:54,760 --> 00:28:57,820
And we say that M
recognizes that language.

581
00:28:57,820 --> 00:28:59,650
These three things
mean the same thing.

582
00:28:59,650 --> 00:29:02,280

583
00:29:02,280 --> 00:29:02,880
OK?

584
00:29:02,880 --> 00:29:04,170
And now important definition--

585
00:29:04,170 --> 00:29:06,330
I try to reserve the
most important things

586
00:29:06,330 --> 00:29:09,180
or the highlighted things to
be in this light blue color,

587
00:29:09,180 --> 00:29:10,530
if you can see that.

588
00:29:10,530 --> 00:29:14,310
We say a language is
a regular language

589
00:29:14,310 --> 00:29:19,250
if there's some finite
automaton that recognizes it.

590
00:29:19,250 --> 00:29:20,090
OK?

591
00:29:20,090 --> 00:29:23,030
So there are going to be some
languages that have associated

592
00:29:23,030 --> 00:29:26,120
to them finite automata that
actually solve those languages,

593
00:29:26,120 --> 00:29:27,590
that recognize those languages.

594
00:29:27,590 --> 00:29:29,090
But there might be
other languages--

595
00:29:29,090 --> 00:29:31,520
and we'll see examples-- where
you just can't solve them.

596
00:29:31,520 --> 00:29:33,980
You can't recognize them
with a finite automaton.

597
00:29:33,980 --> 00:29:36,440
Those languages will not
be regular languages.

598
00:29:36,440 --> 00:29:38,270
The regular ones are
the ones that you

599
00:29:38,270 --> 00:29:40,100
can do with a finite automaton.

600
00:29:40,100 --> 00:29:43,770
That's the traditional
terminology.

601
00:29:43,770 --> 00:29:45,390
OK, so let's continue.

602
00:29:45,390 --> 00:29:46,450
Let's go on from there.

603
00:29:46,450 --> 00:29:48,450
So let's do a
couple of examples.

604
00:29:48,450 --> 00:29:50,010
Here, again, is that same--

605
00:29:50,010 --> 00:29:53,730
getting to be an old
friend, that automaton M1.

606
00:29:53,730 --> 00:29:56,280

607
00:29:56,280 --> 00:29:58,770
Remember, its language
here is the set

608
00:29:58,770 --> 00:30:02,520
of strings that have
the substring 11.

609
00:30:02,520 --> 00:30:08,050
That is that
language A. Now, what

610
00:30:08,050 --> 00:30:12,570
do we know about A from
the previous slide?

611
00:30:12,570 --> 00:30:13,690
Think with me.

612
00:30:13,690 --> 00:30:14,820
Don't just listen.

613
00:30:14,820 --> 00:30:18,900
A is a regular language
now, because it's

614
00:30:18,900 --> 00:30:22,660
recognized by some automaton.

615
00:30:22,660 --> 00:30:27,910
So whenever you
find an automaton

616
00:30:27,910 --> 00:30:30,130
for a language, a finite
automaton for language,

617
00:30:30,130 --> 00:30:34,568
we know that that language
is a regular language.

618
00:30:34,568 --> 00:30:36,360
So let's look at a
couple of more examples.

619
00:30:36,360 --> 00:30:38,090
So if you take the language--

620
00:30:38,090 --> 00:30:42,350
let's call this one B, which
is the strings that have

621
00:30:42,350 --> 00:30:45,060
an even number of 1's in them.

622
00:30:45,060 --> 00:30:51,370
So like the string 1101,
would that be in B?

623
00:30:51,370 --> 00:30:54,070
No, because it has
an odd number of 1's.

624
00:30:54,070 --> 00:30:57,860
So the string 1111
has four 1's in it.

625
00:30:57,860 --> 00:31:00,730
That's an even number, so
that string would be in B.

626
00:31:00,730 --> 00:31:04,000
The 0's don't matter
for this language.

627
00:31:04,000 --> 00:31:13,760
So strings that have
an even number of 1's,

628
00:31:13,760 --> 00:31:16,520
that's a regular language.

629
00:31:16,520 --> 00:31:18,200
And the way you would
know that is you

630
00:31:18,200 --> 00:31:20,390
would have to make a
finite automaton that

631
00:31:20,390 --> 00:31:21,750
recognizes that language.

632
00:31:21,750 --> 00:31:25,430
And I would encourage you to
go and make that automaton.

633
00:31:25,430 --> 00:31:26,690
You can do it with two states.

634
00:31:26,690 --> 00:31:28,280
It's a very simple automaton.

635
00:31:28,280 --> 00:31:30,560
But if you haven't had
practice with these,

636
00:31:30,560 --> 00:31:32,070
I encourage you to do that.

637
00:31:32,070 --> 00:31:34,220
And actually, there
are lots of examples

638
00:31:34,220 --> 00:31:38,930
that I ask you to solve at the
end of chapter 1 in the book,

639
00:31:38,930 --> 00:31:42,320
and you definitely should
spend some time playing with it

640
00:31:42,320 --> 00:31:47,450
if you have not yet seen
finite automata before.

641
00:31:47,450 --> 00:31:50,790
You need to get comfortable with
these and be able to make them.

642
00:31:50,790 --> 00:31:53,157
So we're going to start
making some of them,

643
00:31:53,157 --> 00:31:54,740
but we're going to
be talking about it

644
00:31:54,740 --> 00:31:56,750
at a sort of a more
abstract level in a minute.

645
00:31:56,750 --> 00:31:59,710

646
00:31:59,710 --> 00:32:03,220
Basically, the reason why
you can solve this problem,

647
00:32:03,220 --> 00:32:07,540
you can make a finite automaton
which recognizes the language

648
00:32:07,540 --> 00:32:09,850
B, is because that
finite automaton

649
00:32:09,850 --> 00:32:14,590
is going to keep track of the
parity of the number of 1's

650
00:32:14,590 --> 00:32:16,120
it's seen before.

651
00:32:16,120 --> 00:32:18,408
This has two states,
one of them remembering

652
00:32:18,408 --> 00:32:20,200
that it's seen an odd
number of 1's so far,

653
00:32:20,200 --> 00:32:21,658
the other one
remembering it's seen

654
00:32:21,658 --> 00:32:24,080
an even number of 1's before.

655
00:32:24,080 --> 00:32:26,380
And that's going to be
typical for these automata,

656
00:32:26,380 --> 00:32:27,490
finite automata.

657
00:32:27,490 --> 00:32:30,130
There's going to be several
different possibilities

658
00:32:30,130 --> 00:32:34,060
that you may have to keep track
of as you're reading the input,

659
00:32:34,060 --> 00:32:36,340
and there's going to
be a state associated

660
00:32:36,340 --> 00:32:38,790
with each one of
those possibilities.

661
00:32:38,790 --> 00:32:40,730
So if you're designing
an automaton,

662
00:32:40,730 --> 00:32:42,200
you have to think about--

663
00:32:42,200 --> 00:32:44,030
as you're processing the input--

664
00:32:44,030 --> 00:32:45,650
what things you have
to keep track of.

665
00:32:45,650 --> 00:32:47,525
And you're going to make
a state for each one

666
00:32:47,525 --> 00:32:49,470
of those possibilities.

667
00:32:49,470 --> 00:32:49,970
OK?

668
00:32:49,970 --> 00:32:54,230
So you need to get
comfortable with that.

669
00:32:54,230 --> 00:32:58,940
Let's look at another example,
the language C where the inputs

670
00:32:58,940 --> 00:33:02,640
have an equal number
of 0's and 1's.

671
00:33:02,640 --> 00:33:06,760
That turns out to be
not a regular language.

672
00:33:06,760 --> 00:33:09,210
So, in other words,
what that means

673
00:33:09,210 --> 00:33:12,420
is there's no way to
recognize that language

674
00:33:12,420 --> 00:33:13,590
with a finite automaton.

675
00:33:13,590 --> 00:33:15,070
You just can't do it.

676
00:33:15,070 --> 00:33:17,820
That's beyond the capabilities
of finite automata.

677
00:33:17,820 --> 00:33:23,460
And that's a statement
we will prove later.

678
00:33:23,460 --> 00:33:25,050
OK.

679
00:33:25,050 --> 00:33:29,160
And our goal over the
next lecture or so

680
00:33:29,160 --> 00:33:31,950
is to understand the regular
languages, which you can

681
00:33:31,950 --> 00:33:34,750
do in a very comprehensive way.

682
00:33:34,750 --> 00:33:38,030
So we're going to
start to do that now.

683
00:33:38,030 --> 00:33:40,300
So first, we're going to
introduce this concept

684
00:33:40,300 --> 00:33:42,663
of regular expressions--

685
00:33:42,663 --> 00:33:44,080
which, again, these
are things you

686
00:33:44,080 --> 00:33:47,210
may have run into in one
way or another before.

687
00:33:47,210 --> 00:33:52,700
So we're going to
introduce something

688
00:33:52,700 --> 00:33:54,650
called the regular operations.

689
00:33:54,650 --> 00:33:59,210
Now, I'm sure
you're familiar with

690
00:33:59,210 --> 00:34:04,490
the arithmetical operations,
like plus and times.

691
00:34:04,490 --> 00:34:08,110
Those apply to numbers.

692
00:34:08,110 --> 00:34:09,880
The operations we're
going to talk about

693
00:34:09,880 --> 00:34:12,639
are operations that
apply to languages.

694
00:34:12,639 --> 00:34:16,000
So they're going to take,
let's say, two languages,

695
00:34:16,000 --> 00:34:17,500
you apply an
operation, you're going

696
00:34:17,500 --> 00:34:19,000
to get back another language.

697
00:34:19,000 --> 00:34:21,730
Like the union
operation, for example,

698
00:34:21,730 --> 00:34:25,179
that's one you probably
have seen before.

699
00:34:25,179 --> 00:34:27,130
The union of two
languages here is

700
00:34:27,130 --> 00:34:29,949
a collection of strings that
are in either one or the other.

701
00:34:29,949 --> 00:34:33,078

702
00:34:33,078 --> 00:34:34,620
But there are other
operations, which

703
00:34:34,620 --> 00:34:37,469
you may not have seen before,
that we're going to look at--

704
00:34:37,469 --> 00:34:40,090
the concatenation
operation, for example.

705
00:34:40,090 --> 00:34:41,670
So that says you're
going to take

706
00:34:41,670 --> 00:34:45,090
a string from the first
language and another string

707
00:34:45,090 --> 00:34:49,370
from the second language
and stick them together.

708
00:34:49,370 --> 00:34:52,409
And it's called
concatenating them.

709
00:34:52,409 --> 00:34:54,679
And you do that in
all possible ways,

710
00:34:54,679 --> 00:34:56,900
and you're going to get
the concatenation language

711
00:34:56,900 --> 00:34:59,090
from these two languages
that you're starting with,

712
00:34:59,090 --> 00:35:02,930
A and B. The symbol we
use for concatenation

713
00:35:02,930 --> 00:35:04,070
is this little circle.

714
00:35:04,070 --> 00:35:06,410
But often, we don't.

715
00:35:06,410 --> 00:35:09,470
We just suppress that and
we write the two languages

716
00:35:09,470 --> 00:35:12,580
next to one another with
the little circle implied.

717
00:35:12,580 --> 00:35:17,510
So this also means concatenation
over here, just like this does.

718
00:35:17,510 --> 00:35:20,750
And the last of the
regular operations

719
00:35:20,750 --> 00:35:24,680
is the so-called star operation,
which is a unary operation.

720
00:35:24,680 --> 00:35:27,180
It applies to just
a single language.

721
00:35:27,180 --> 00:35:31,460
And so what you do is now
you're going to take--

722
00:35:31,460 --> 00:35:34,610
to get a member of
the star language,

723
00:35:34,610 --> 00:35:36,380
you're going to take
a bunch of strings

724
00:35:36,380 --> 00:35:39,980
in the original language,
A, you stick them together.

725
00:35:39,980 --> 00:35:43,500
Any number of members of
A, you stick them together,

726
00:35:43,500 --> 00:35:46,550
and that becomes an element
of the star language.

727
00:35:46,550 --> 00:35:49,430
And we'll do an example in a
second if you didn't get that.

728
00:35:49,430 --> 00:35:52,250
But one important element is
that when you have the star

729
00:35:52,250 --> 00:35:54,530
language, you can
also allow it to stick

730
00:35:54,530 --> 00:36:00,090
zero elements together, and
then you get the empty string.

731
00:36:00,090 --> 00:36:02,780
So that's always a
member of the star

732
00:36:02,780 --> 00:36:05,730
language, the empty string.

733
00:36:05,730 --> 00:36:08,160
OK, so let's look
at some examples.

734
00:36:08,160 --> 00:36:10,620
Let's say A is the
language-- these are

735
00:36:10,620 --> 00:36:12,510
two strings here-- good, bad.

736
00:36:12,510 --> 00:36:14,280
And B is the language boy, girl.

737
00:36:14,280 --> 00:36:17,800

738
00:36:17,800 --> 00:36:21,380
Now, if we take the
union of those two,

739
00:36:21,380 --> 00:36:25,740
we get good, bad, boy, girl.

740
00:36:25,740 --> 00:36:29,380
That's kind of
what you'd expect.

741
00:36:29,380 --> 00:36:38,170
And now let's take a look
at the concatenation.

742
00:36:38,170 --> 00:36:41,260
Now, if you concatenate
the A and the B language,

743
00:36:41,260 --> 00:36:44,200
you're going to get all
possible ways of having an A

744
00:36:44,200 --> 00:36:46,850
string followed by all possible
ways of having a B string.

745
00:36:46,850 --> 00:36:49,960
So you can get goodboy,
goodgirl, badboy, badgirl.

746
00:36:49,960 --> 00:36:53,990

747
00:36:53,990 --> 00:37:01,240
Now, looking at the
star, well, that

748
00:37:01,240 --> 00:37:02,900
applies to just one language.

749
00:37:02,900 --> 00:37:07,600
So let's say it's the
good, bad language from A.

750
00:37:07,600 --> 00:37:10,270
And so the A star
that you get from that

751
00:37:10,270 --> 00:37:14,710
is all possible ways of sticking
together the strings from A.

752
00:37:14,710 --> 00:37:18,260
So using no strings, you
always get the empty string.

753
00:37:18,260 --> 00:37:20,380
That's always guaranteed
to be a member of A.

754
00:37:20,380 --> 00:37:22,530
And then just taking
one element of A,

755
00:37:22,530 --> 00:37:24,790
you get good, or
another element, bad.

756
00:37:24,790 --> 00:37:28,090
But now two elements of A,
you get goodgood or goodbad,

757
00:37:28,090 --> 00:37:29,530
and so on.

758
00:37:29,530 --> 00:37:32,920
Or three elements of A,
goodgoodgood, goodgoodbad.

759
00:37:32,920 --> 00:37:37,130
And so, in fact, A star is
going to be an infinite language

760
00:37:37,130 --> 00:37:46,530
if A itself contains
any non-empty member.

761
00:37:46,530 --> 00:37:50,390
So if A is the empty
language or if A contains

762
00:37:50,390 --> 00:37:54,170
just the language empty
string, then A star

763
00:37:54,170 --> 00:37:56,480
will be not an
infinite language.

764
00:37:56,480 --> 00:37:59,000
It'll just be the
language empty string.

765
00:37:59,000 --> 00:38:02,020
But otherwise, it'll be
an infinite language.

766
00:38:02,020 --> 00:38:02,890
I'm not even sure--

767
00:38:02,890 --> 00:38:07,780

768
00:38:07,780 --> 00:38:08,650
OK.

769
00:38:08,650 --> 00:38:09,880
I'm not-- [LAUGHS]

770
00:38:09,880 --> 00:38:11,020
I'm ignoring the chat here.

771
00:38:11,020 --> 00:38:12,670
I'm hoping people
are getting-- are you

772
00:38:12,670 --> 00:38:15,850
guys are getting your
questions answered by our TAs?

773
00:38:15,850 --> 00:38:17,440
How are we doing, Thomas?

774
00:38:17,440 --> 00:38:21,177
AUDIENCE: One question is, are
the slides going to be posted?

775
00:38:21,177 --> 00:38:23,260
MICHAEL SIPSER: Are the
slides going to be posted?

776
00:38:23,260 --> 00:38:28,147
Well, the whole lecture
is going to be recorded.

777
00:38:28,147 --> 00:38:29,980
Is it helpful to have
the slides separately?

778
00:38:29,980 --> 00:38:33,130
I can post the slides.

779
00:38:33,130 --> 00:38:34,360
Sure.

780
00:38:34,360 --> 00:38:36,460
Remind me if I don't,
but I'll try to do that.

781
00:38:36,460 --> 00:38:37,360
Yes, it is helpful.

782
00:38:37,360 --> 00:38:38,530
I will do that.

783
00:38:38,530 --> 00:38:41,580

784
00:38:41,580 --> 00:38:43,440
Yeah.

785
00:38:43,440 --> 00:38:44,690
Yeah, I will post the slides.

786
00:38:44,690 --> 00:38:47,808
Just, Thomas, it's
your job to remind me.

787
00:38:47,808 --> 00:38:48,350
AUDIENCE: OK.

788
00:38:48,350 --> 00:38:51,820

789
00:38:51,820 --> 00:38:53,830
MICHAEL SIPSER: All right, good.

790
00:38:53,830 --> 00:38:55,610
So we talked about the
regular operations.

791
00:38:55,610 --> 00:38:57,740
Let's talk about the
regular expressions.

792
00:38:57,740 --> 00:38:59,500
So regular
expressions are-- just

793
00:38:59,500 --> 00:39:01,570
like you have the
arithmetical operations,

794
00:39:01,570 --> 00:39:03,550
then you can get
arithmetical expressions,

795
00:39:03,550 --> 00:39:07,320
like 1 plus 3 times 7.

796
00:39:07,320 --> 00:39:09,070
So now we're going to
make expressions out

797
00:39:09,070 --> 00:39:10,240
of these operations.

798
00:39:10,240 --> 00:39:13,120
First of all, you have,
the more atomic things,

799
00:39:13,120 --> 00:39:15,130
the building blocks of
the expressions, which

800
00:39:15,130 --> 00:39:23,330
are going to be like elements of
sigma, elements of the alphabet

801
00:39:23,330 --> 00:39:27,860
or the sigma itself
as an alphabet symbol,

802
00:39:27,860 --> 00:39:33,502
or the empty language
or the empty string.

803
00:39:33,502 --> 00:39:35,210
These are going to be
the building blocks

804
00:39:35,210 --> 00:39:36,470
for the regular expressions.

805
00:39:36,470 --> 00:39:38,550
We'll do an example in a second.

806
00:39:38,550 --> 00:39:42,530
And then you combine
those basic elements

807
00:39:42,530 --> 00:39:45,860
using the regular operations of
union, concatenation, and star.

808
00:39:45,860 --> 00:39:48,320
So these are the
atomic expressions,

809
00:39:48,320 --> 00:39:50,070
these are the
composite expressions.

810
00:39:50,070 --> 00:39:57,940
So, for example, if you look at
the expression 0 union 1 star--

811
00:39:57,940 --> 00:40:00,400
so we can also write
that as sigma star.

812
00:40:00,400 --> 00:40:04,540
Because if sigma is 0
and 1, then sigma star

813
00:40:04,540 --> 00:40:08,440
is the same thing as 0 union 1--
sigma is the same as 0 union 1.

814
00:40:08,440 --> 00:40:11,763
And that just gives all
possible strings over sigma.

815
00:40:11,763 --> 00:40:13,930
So this is something you're
going to see frequently.

816
00:40:13,930 --> 00:40:16,720
Sigma star means
this is the language

817
00:40:16,720 --> 00:40:18,850
of all strings over
the alphabet we're

818
00:40:18,850 --> 00:40:22,340
working with at that moment.

819
00:40:22,340 --> 00:40:26,270
Now, if you take
sigma star 1, you just

820
00:40:26,270 --> 00:40:30,350
concatenate 1 onto all of
the elements of sigma star,

821
00:40:30,350 --> 00:40:34,100
and that's going to give you
all strings that end with a 1.

822
00:40:34,100 --> 00:40:36,200
Technically, you might
imagine writing this

823
00:40:36,200 --> 00:40:40,880
with braces around the 1, but
generally, we don't do that.

824
00:40:40,880 --> 00:40:45,380
We just-- single element
sets, single element strings,

825
00:40:45,380 --> 00:40:47,900
we write without the
braces, because it's

826
00:40:47,900 --> 00:40:50,790
clear enough without them,
and it gets messy with them.

827
00:40:50,790 --> 00:40:53,780
So sigma star 1 is all
strings that end with 1.

828
00:40:53,780 --> 00:40:57,830
Or, for example,
you take sigma star

829
00:40:57,830 --> 00:41:03,020
11 sigma star, that is all
strings that contain 11.

830
00:41:03,020 --> 00:41:05,000
And we already saw that
language once before.

831
00:41:05,000 --> 00:41:06,830
That's the language
of that other machine

832
00:41:06,830 --> 00:41:10,960
that we presented one
or two slides back.

833
00:41:10,960 --> 00:41:11,460
OK?

834
00:41:11,460 --> 00:41:14,945

835
00:41:14,945 --> 00:41:15,445
Right.

836
00:41:15,445 --> 00:41:20,377

837
00:41:20,377 --> 00:41:22,210
Yeah, but in terms of
readings-- by the way,

838
00:41:22,210 --> 00:41:23,640
sorry, I don't know
if it's helpful to you

839
00:41:23,640 --> 00:41:25,110
for me to do these
interjections--

840
00:41:25,110 --> 00:41:30,240
but the readings are listed
also on the homework.

841
00:41:30,240 --> 00:41:33,570
So if you look at the
posted homework 1,

842
00:41:33,570 --> 00:41:38,910
it tells you which chapters
you should be reading now.

843
00:41:38,910 --> 00:41:42,420
And also, if you look at the
course schedule, which is also

844
00:41:42,420 --> 00:41:47,520
on the home page, it has the
whole course plan and which

845
00:41:47,520 --> 00:41:49,890
readings are for which dates.

846
00:41:49,890 --> 00:41:51,570
So it's all there for you.

847
00:41:51,570 --> 00:41:54,470

848
00:41:54,470 --> 00:41:57,110
And so our goal here--
this is not an accident

849
00:41:57,110 --> 00:42:00,290
that sigma star 11
sigma star happens

850
00:42:00,290 --> 00:42:03,140
to be the same language
as we saw before

851
00:42:03,140 --> 00:42:07,430
from the language of
that finite automaton M1.

852
00:42:07,430 --> 00:42:10,250
In fact, that's a
general phenomenon.

853
00:42:10,250 --> 00:42:12,780
Anything you can do with
a regular expression,

854
00:42:12,780 --> 00:42:16,800
you can also do with a finite
automaton and vice versa.

855
00:42:16,800 --> 00:42:19,670
They are equivalent
in power with respect

856
00:42:19,670 --> 00:42:23,030
to the class of
languages they describe.

857
00:42:23,030 --> 00:42:24,370
And we'll prove that.

858
00:42:24,370 --> 00:42:26,680

859
00:42:26,680 --> 00:42:27,180
OK?

860
00:42:27,180 --> 00:42:30,540

861
00:42:30,540 --> 00:42:35,010
So if you step back for
a second and just let

862
00:42:35,010 --> 00:42:38,190
yourself appreciate this,
it's kind of an amazing thing.

863
00:42:38,190 --> 00:42:41,160
Because finite automata, with
the states and transitions,

864
00:42:41,160 --> 00:42:45,090
and the regular expressions,
with these operations of union,

865
00:42:45,090 --> 00:42:47,670
concatenation, and star,
they look totally different

866
00:42:47,670 --> 00:42:48,437
from one another.

867
00:42:48,437 --> 00:42:50,770
They look like they have
nothing to do with one another.

868
00:42:50,770 --> 00:42:53,880
But, in fact, they both describe
exactly the regular languages,

869
00:42:53,880 --> 00:42:56,250
the same class of languages.

870
00:42:56,250 --> 00:42:58,980
And so it's kind of a cool
fact that you can prove,

871
00:42:58,980 --> 00:43:01,500
that these two very
different looking systems

872
00:43:01,500 --> 00:43:03,240
actually are equivalent
to one another.

873
00:43:03,240 --> 00:43:07,140

874
00:43:07,140 --> 00:43:10,780
Can we get empty
string from empty set?

875
00:43:10,780 --> 00:43:11,440
Yeah.

876
00:43:11,440 --> 00:43:15,520
There are a bunch of
exotic cases, by the way.

877
00:43:15,520 --> 00:43:19,270
So empty language star
is the language which

878
00:43:19,270 --> 00:43:21,190
has just the empty string.

879
00:43:21,190 --> 00:43:23,650
If you don't get that,
chew on that one.

880
00:43:23,650 --> 00:43:25,390
But that is true.

881
00:43:25,390 --> 00:43:28,210

882
00:43:28,210 --> 00:43:30,850
OK, let's move on.

883
00:43:30,850 --> 00:43:32,903
OK, let's talk about
closure properties now.

884
00:43:32,903 --> 00:43:35,320
We're going to start doing
something that has a little bit

885
00:43:35,320 --> 00:43:37,630
more meat to it,
in terms of we're

886
00:43:37,630 --> 00:43:41,080
going to have our first theorem
of the course coming here.

887
00:43:41,080 --> 00:43:43,400
And this is not a baby theorem.

888
00:43:43,400 --> 00:43:46,030
This is actually-- there's
going to be some meat to this.

889
00:43:46,030 --> 00:43:53,080
And you're going to
have to not totally--

890
00:43:53,080 --> 00:43:54,280
this is not a toy.

891
00:43:54,280 --> 00:43:58,010
We're proving something
that has real substance.

892
00:43:58,010 --> 00:44:02,120
And the statement
of this theorem

893
00:44:02,120 --> 00:44:08,120
says that the regular languages
are closed, that really,

894
00:44:08,120 --> 00:44:11,510
the class of regular languages
are closed under union, closed

895
00:44:11,510 --> 00:44:13,980
under the union operation.

896
00:44:13,980 --> 00:44:16,160
So what do I mean by that?

897
00:44:16,160 --> 00:44:20,930
So when you say a
collection of objects

898
00:44:20,930 --> 00:44:23,420
is closed under
some operation, that

899
00:44:23,420 --> 00:44:26,480
means applying that
operation to those objects

900
00:44:26,480 --> 00:44:29,850
leaves you in the
same class of objects.

901
00:44:29,850 --> 00:44:37,790
Like the positive integers,
the natural numbers,

902
00:44:37,790 --> 00:44:39,680
that's closed under addition.

903
00:44:39,680 --> 00:44:42,950
Because when you add
two positive integers,

904
00:44:42,950 --> 00:44:44,870
you get back a positive integer.

905
00:44:44,870 --> 00:44:47,390
But they're not closed
under subtraction.

906
00:44:47,390 --> 00:44:50,990
Because 2 minus 4, you
get something which

907
00:44:50,990 --> 00:44:52,830
is not a positive integer.

908
00:44:52,830 --> 00:44:56,490
So closed means you leave
yourself in the collection.

909
00:44:56,490 --> 00:45:00,570
And the fact is that if you look
at all the regular languages--

910
00:45:00,570 --> 00:45:05,130
these are the languages that the
finite automata can recognize--

911
00:45:05,130 --> 00:45:07,470
they are closed under
the union operation.

912
00:45:07,470 --> 00:45:10,020
So if you start off with
two regular languages

913
00:45:10,020 --> 00:45:13,528
and you apply the union, you get
back another regular language.

914
00:45:13,528 --> 00:45:15,570
And that's what the
statement of this theorem is.

915
00:45:15,570 --> 00:45:18,690
I hope that's clear enough
in the way I've written it.

916
00:45:18,690 --> 00:45:23,940
If A1 and A2 are regular, then
A1 union A2 is also regular.

917
00:45:23,940 --> 00:45:25,710
That's what the
statement of this is.

918
00:45:25,710 --> 00:45:28,020
And it's just simply that--

919
00:45:28,020 --> 00:45:30,210
that's proving that the
class of regular language

920
00:45:30,210 --> 00:45:31,200
is closed under union.

921
00:45:31,200 --> 00:45:33,970
So we're going to prove that.

922
00:45:33,970 --> 00:45:36,500
So how do you
prove such a thing?

923
00:45:36,500 --> 00:45:40,810
So the way we're going
to prove that is you

924
00:45:40,810 --> 00:45:43,190
start off with what
we're assuming.

925
00:45:43,190 --> 00:45:47,300
So our hypothesis is that we
have two regular languages.

926
00:45:47,300 --> 00:45:49,420
And we have to prove
our conclusion,

927
00:45:49,420 --> 00:45:52,300
that the union is also regular.

928
00:45:52,300 --> 00:45:55,000
Now, the hypothesis
that they're regular,

929
00:45:55,000 --> 00:45:58,780
you have to unpack that and
understand, what does that

930
00:45:58,780 --> 00:46:00,010
get you?

931
00:46:00,010 --> 00:46:03,970
And them being regular means
that there are finite automata

932
00:46:03,970 --> 00:46:05,750
that recognize those languages.

933
00:46:05,750 --> 00:46:08,260
So let's give those two
finite automata names.

934
00:46:08,260 --> 00:46:11,740
So M1 and M2 are the
two final automata

935
00:46:11,740 --> 00:46:13,998
that recognize those two
languages, A1 and A2.

936
00:46:13,998 --> 00:46:15,790
That's what it means,
that they're regular,

937
00:46:15,790 --> 00:46:19,050
that these automata exist.

938
00:46:19,050 --> 00:46:22,160
So let's have those two
automata, M1 and M2,

939
00:46:22,160 --> 00:46:26,120
using the components as we've
described, the respective state

940
00:46:26,120 --> 00:46:29,360
sets, input alphabet,
transition functions, the two

941
00:46:29,360 --> 00:46:31,880
starting states and the two
collections of accepting

942
00:46:31,880 --> 00:46:32,390
states.

943
00:46:32,390 --> 00:46:34,970
Here I'm assuming that they're
over the same alphabet.

944
00:46:34,970 --> 00:46:36,890
You could have
automata which operate

945
00:46:36,890 --> 00:46:38,180
over different alphabets.

946
00:46:38,180 --> 00:46:40,160
It's not interesting to do that.

947
00:46:40,160 --> 00:46:41,370
It doesn't add anything.

948
00:46:41,370 --> 00:46:43,200
The proof would be
exactly the same.

949
00:46:43,200 --> 00:46:46,040
So let's just not overcomplicate
our lives and focus

950
00:46:46,040 --> 00:46:47,840
on the more interesting
case, so assuming

951
00:46:47,840 --> 00:46:51,990
that the two input alphabets
are going to be the same.

952
00:46:51,990 --> 00:46:53,870
And from these two
automata, we have

953
00:46:53,870 --> 00:46:56,480
to show that this
language here, the union,

954
00:46:56,480 --> 00:46:58,220
is also a regular language.

955
00:46:58,220 --> 00:47:02,450
And we're going to do that
by constructing the automaton

956
00:47:02,450 --> 00:47:03,980
which recognizes the union.

957
00:47:03,980 --> 00:47:07,250
That's really the only
thing that we can do.

958
00:47:07,250 --> 00:47:11,210
So we're going to build an
automaton out of M1 and M2

959
00:47:11,210 --> 00:47:15,240
which recognizes the union
language A1 union A2.

960
00:47:15,240 --> 00:47:19,560
And the task of M is that
it should accept its input

961
00:47:19,560 --> 00:47:22,973
if either M1 or M2 accept.

962
00:47:22,973 --> 00:47:24,390
And now what I'd
like you to think

963
00:47:24,390 --> 00:47:26,370
about doing that,
how in the world

964
00:47:26,370 --> 00:47:30,360
are we going to come up with
this finite automaton M?

965
00:47:30,360 --> 00:47:42,730
And the way we do that is
to think about, how would

966
00:47:42,730 --> 00:47:46,110
you do that union language?

967
00:47:46,110 --> 00:47:47,550
If I ask you--

968
00:47:47,550 --> 00:47:50,850
I give you two automata,
M1 and M2, and I say,

969
00:47:50,850 --> 00:47:52,020
here's an input, w.

970
00:47:52,020 --> 00:47:54,820

971
00:47:54,820 --> 00:47:57,070
Is w in the union language?

972
00:47:57,070 --> 00:47:59,770
That's the job that M
is supposed to solve.

973
00:47:59,770 --> 00:48:01,450
And I suggest you
try to figure out

974
00:48:01,450 --> 00:48:03,820
how you would solve it first.

975
00:48:03,820 --> 00:48:06,308
I mean, this is a good
strategy for solving a lot

976
00:48:06,308 --> 00:48:07,600
of the problems in this course.

977
00:48:07,600 --> 00:48:10,830
Put yourself in the place of the
machine you're trying to build.

978
00:48:10,830 --> 00:48:14,270
And so if you want to try to
figure out how to do that,

979
00:48:14,270 --> 00:48:18,410
a natural thing is, well, you
take w, you feed it into M1,

980
00:48:18,410 --> 00:48:20,330
and then you feed it into M2.

981
00:48:20,330 --> 00:48:22,617
And if M1 accepts
it, great, then you

982
00:48:22,617 --> 00:48:23,780
know it's in the union.

983
00:48:23,780 --> 00:48:28,718
And if not, you try it out in
M2 and see if M2 accepts it.

984
00:48:28,718 --> 00:48:30,260
Now, you have to be
a little careful,

985
00:48:30,260 --> 00:48:32,750
because you want to have a
strategy that you can also

986
00:48:32,750 --> 00:48:37,440
implement in a finite automaton.

987
00:48:37,440 --> 00:48:42,180
And a finite automaton
only gets one shot

988
00:48:42,180 --> 00:48:43,320
at looking at the input.

989
00:48:43,320 --> 00:48:45,240
You can't sort of
rewind the input.

990
00:48:45,240 --> 00:48:48,990
You feed it first into M1
and then you feed it into M2

991
00:48:48,990 --> 00:48:53,010
and operate in a
sequential way like that.

992
00:48:53,010 --> 00:48:57,690
That's not going to be allowed
in the way finite automata

993
00:48:57,690 --> 00:48:58,480
work.

994
00:48:58,480 --> 00:49:01,950
So you're going to have to
take it to the next level,

995
00:49:01,950 --> 00:49:03,330
be a little bit more clever.

996
00:49:03,330 --> 00:49:05,880
And instead of feeding
it first into M1

997
00:49:05,880 --> 00:49:07,950
and then and then
into M2, you feed them

998
00:49:07,950 --> 00:49:11,480
into both in parallel.

999
00:49:11,480 --> 00:49:14,060
So you take M1 and
M2, and you run them

1000
00:49:14,060 --> 00:49:20,180
both in parallel on the input
w, keeping track of which state

1001
00:49:20,180 --> 00:49:24,450
each of those two
automata are in.

1002
00:49:24,450 --> 00:49:28,070
And then at the end, you see
if either one of those machines

1003
00:49:28,070 --> 00:49:31,243
is in an accepting state,
and then you accept.

1004
00:49:31,243 --> 00:49:32,660
So that's the
strategy we're going

1005
00:49:32,660 --> 00:49:38,430
to employ in building the finite
automaton M out of M1 and M2.

1006
00:49:38,430 --> 00:49:43,150
So in terms of a picture,
here's M1 and M2.

1007
00:49:43,150 --> 00:49:45,673
Here is the automaton
we're trying to build.

1008
00:49:45,673 --> 00:49:47,590
We don't know how it's
going to look like yet.

1009
00:49:47,590 --> 00:49:51,760
And yeah, so kind of getting
ahead of myself, but here

1010
00:49:51,760 --> 00:50:00,700
is a strategy, as I
just described, for M.

1011
00:50:00,700 --> 00:50:05,800
M is going to keep track of
which state that M1 is in

1012
00:50:05,800 --> 00:50:08,740
and which state M2 is
in at any given moment.

1013
00:50:08,740 --> 00:50:11,080
As we're reading
the symbols of w,

1014
00:50:11,080 --> 00:50:16,210
we're going to feed that
into M1 and also into M2.

1015
00:50:16,210 --> 00:50:21,340
And so the possibilities we
have to keep track of in M

1016
00:50:21,340 --> 00:50:25,380
are all the pairs of states
that are in M1 and M2,

1017
00:50:25,380 --> 00:50:27,130
because you're going
to really be tracking

1018
00:50:27,130 --> 00:50:29,120
M1 and M2 simultaneously.

1019
00:50:29,120 --> 00:50:31,570
So you have to remember
which state M1 is in and also

1020
00:50:31,570 --> 00:50:32,920
which state M2 is in.

1021
00:50:32,920 --> 00:50:35,170
And so that really corresponds
to what pair of states

1022
00:50:35,170 --> 00:50:38,380
to remember, one from M1
and one from M2, and that's

1023
00:50:38,380 --> 00:50:40,130
why I've indicated it like that.

1024
00:50:40,130 --> 00:50:42,970
So M1 is in state
q, M2 is in state r

1025
00:50:42,970 --> 00:50:44,890
at some given point in time.

1026
00:50:44,890 --> 00:50:48,240
And that's going to correspond
to M being in the pair q comma

1027
00:50:48,240 --> 00:50:49,000
r.

1028
00:50:49,000 --> 00:50:52,300
That's just the label of
this particular state of m

1029
00:50:52,300 --> 00:50:55,915
that we're going to apply here.

1030
00:50:55,915 --> 00:50:56,415
OK?

1031
00:50:56,415 --> 00:50:59,130

1032
00:50:59,130 --> 00:51:03,570
And then M is going
to accept if either M1

1033
00:51:03,570 --> 00:51:06,010
and M2 is an accepting state.

1034
00:51:06,010 --> 00:51:09,930
So it's going to be if either
q or r is an accepting state,

1035
00:51:09,930 --> 00:51:13,840
we're going to make this
into an accepting state too.

1036
00:51:13,840 --> 00:51:15,420
OK?

1037
00:51:15,420 --> 00:51:16,050
Whoops.

1038
00:51:16,050 --> 00:51:16,620
There we go.

1039
00:51:16,620 --> 00:51:19,725

1040
00:51:19,725 --> 00:51:21,350
So let's describe
this formally instead

1041
00:51:21,350 --> 00:51:23,757
of by a picture, because
we can do it both ways.

1042
00:51:23,757 --> 00:51:26,090
And sometimes it's better to
do it one way and sometimes

1043
00:51:26,090 --> 00:51:27,810
the other way.

1044
00:51:27,810 --> 00:51:29,150
So now if we take--

1045
00:51:29,150 --> 00:51:34,820
the components of M now are the
pairs of states from M1 and M2.

1046
00:51:34,820 --> 00:51:38,400
Again, I'm writing this out
literally, explicitly here,

1047
00:51:38,400 --> 00:51:40,490
but you should make sure
you're comfortable with

1048
00:51:40,490 --> 00:51:42,330
this cross product notation.

1049
00:51:42,330 --> 00:51:45,260
So this is the collection of
pairs of states, q1 and q2,

1050
00:51:45,260 --> 00:51:47,660
where q1 is in the state
of the first machine,

1051
00:51:47,660 --> 00:51:50,600
q2 is the state of
the second machine.

1052
00:51:50,600 --> 00:51:53,630
The start state is you
start at the two start

1053
00:51:53,630 --> 00:51:55,850
states of the two machines.

1054
00:51:55,850 --> 00:51:57,530
So this is q1, q2--

1055
00:51:57,530 --> 00:52:01,100
probably I should have
not reused the Q notation.

1056
00:52:01,100 --> 00:52:02,532
I should have called these r's--

1057
00:52:02,532 --> 00:52:03,740
now that I'm looking at that.

1058
00:52:03,740 --> 00:52:06,500
But, anyway, I hope you're
not confused by reusing this.

1059
00:52:06,500 --> 00:52:09,890
q1 and q2 here are the
specific start states

1060
00:52:09,890 --> 00:52:12,150
of the two machines.

1061
00:52:12,150 --> 00:52:15,650
These are just two other
states, representative states

1062
00:52:15,650 --> 00:52:17,780
of those machines.

1063
00:52:17,780 --> 00:52:20,623
Now, the transition
function for the new machine

1064
00:52:20,623 --> 00:52:22,790
is going to be built out
of the transition functions

1065
00:52:22,790 --> 00:52:24,870
from the previous machines.

1066
00:52:24,870 --> 00:52:30,500
So when I have a pair, q,
r, and I have the symbol a,

1067
00:52:30,500 --> 00:52:31,520
where do we go?

1068
00:52:31,520 --> 00:52:33,270
Which new pair do we get?

1069
00:52:33,270 --> 00:52:35,930
Well, we just update
the state from M1

1070
00:52:35,930 --> 00:52:38,510
and update the state
from M2 according

1071
00:52:38,510 --> 00:52:40,273
to their respective
transition functions,

1072
00:52:40,273 --> 00:52:41,690
and that's what's
shown over here.

1073
00:52:41,690 --> 00:52:45,410

1074
00:52:45,410 --> 00:52:50,080
Now let's take a look at
the accepting states for M.

1075
00:52:50,080 --> 00:52:54,430
The natural thing to do is look
at the set of pairs of states,

1076
00:52:54,430 --> 00:52:57,400
where we have a pair of states--

1077
00:52:57,400 --> 00:53:02,830
a pair of accepting states,
one from the first machine

1078
00:53:02,830 --> 00:53:05,430
and one from the second machine.

1079
00:53:05,430 --> 00:53:07,470
But if you're
thinking with me, you

1080
00:53:07,470 --> 00:53:09,585
realize that this is
not the right thing.

1081
00:53:09,585 --> 00:53:12,510

1082
00:53:12,510 --> 00:53:13,170
What is DFAs?

1083
00:53:13,170 --> 00:53:16,570

1084
00:53:16,570 --> 00:53:18,760
Did I would call
them DFA somewhere?

1085
00:53:18,760 --> 00:53:22,516
Oh, somebody else is probably
doing that in the chat.

1086
00:53:22,516 --> 00:53:25,540
The DFA-- careful what
notation you're using.

1087
00:53:25,540 --> 00:53:28,430
We haven't introduced DFAs yet.

1088
00:53:28,430 --> 00:53:30,370
We'll do that next on Thursday.

1089
00:53:30,370 --> 00:53:31,300
But these are DFAs.

1090
00:53:31,300 --> 00:53:34,300
These are just finite automata,
Deterministic Finite Automata.

1091
00:53:34,300 --> 00:53:35,680
That's why the D.

1092
00:53:35,680 --> 00:53:38,342
Anyway, so this is
actually not right,

1093
00:53:38,342 --> 00:53:40,300
because if you think
about what this is saying,

1094
00:53:40,300 --> 00:53:44,260
it says that both components
have to be accepting.

1095
00:53:44,260 --> 00:53:47,900
And you want either
one to be accepting.

1096
00:53:47,900 --> 00:53:50,050
So this is not good.

1097
00:53:50,050 --> 00:53:53,560
This would be the wrong
way of defining it.

1098
00:53:53,560 --> 00:53:55,510
That actually gives the
intersection language.

1099
00:53:55,510 --> 00:53:56,927
And really, kind
of along the way,

1100
00:53:56,927 --> 00:53:58,762
it's proving closure
under intersection,

1101
00:53:58,762 --> 00:54:00,220
which we don't care
about but might

1102
00:54:00,220 --> 00:54:04,690
be useful to have in our back
pocket sometime in the future.

1103
00:54:04,690 --> 00:54:07,000
In order to get
closure under a union,

1104
00:54:07,000 --> 00:54:09,100
we have to write it this
slightly more complicated

1105
00:54:09,100 --> 00:54:14,710
looking way, which says the
pair, what you want to have is

1106
00:54:14,710 --> 00:54:18,940
either the first state is
an accepting state and then

1107
00:54:18,940 --> 00:54:21,490
any state for the
second element,

1108
00:54:21,490 --> 00:54:23,680
or any state for
the first element

1109
00:54:23,680 --> 00:54:26,290
and an accepting state
for the second element.

1110
00:54:26,290 --> 00:54:31,090
That's what it means to have the
union, to be doing the union.

1111
00:54:31,090 --> 00:54:31,690
OK?

1112
00:54:31,690 --> 00:54:35,020
So let's do-- oh,
here's a quick check-in.

1113
00:54:35,020 --> 00:54:38,020

1114
00:54:38,020 --> 00:54:40,360
So let's do another poll here.

1115
00:54:40,360 --> 00:54:41,995
We thought we were
done with these.

1116
00:54:41,995 --> 00:54:44,660

1117
00:54:44,660 --> 00:54:50,450
Again-- oh, here we go.

1118
00:54:50,450 --> 00:54:53,320
So it was too complicated to
write it out in the polls,

1119
00:54:53,320 --> 00:54:55,480
so I actually put it up
on the slide for you.

1120
00:54:55,480 --> 00:54:58,400

1121
00:54:58,400 --> 00:55:02,410
So all I'm asking is
that if M1 has k1 states

1122
00:55:02,410 --> 00:55:05,290
and M2 has k2 states, how
many states does M have?

1123
00:55:05,290 --> 00:55:08,810

1124
00:55:08,810 --> 00:55:12,255
Is it the sum, the sum of
the squares, or the product?

1125
00:55:12,255 --> 00:55:17,450

1126
00:55:17,450 --> 00:55:20,330
OK, you have to think
about the states of M, what

1127
00:55:20,330 --> 00:55:22,790
do they look like?

1128
00:55:22,790 --> 00:55:26,720
And come on, guys.

1129
00:55:26,720 --> 00:55:29,330

1130
00:55:29,330 --> 00:55:33,560
All right, ending the
poll, sharing results.

1131
00:55:33,560 --> 00:55:37,460
Yes, indeed, it is-- most
of you got it correct.

1132
00:55:37,460 --> 00:55:40,040
It is C, the product.

1133
00:55:40,040 --> 00:55:42,830
Because when you look at the
number of pairs of states

1134
00:55:42,830 --> 00:55:46,280
from M1 and M2, you
need all possible pairs.

1135
00:55:46,280 --> 00:55:48,950
And so it's the number of
states in M1 times the number

1136
00:55:48,950 --> 00:55:49,950
of states in M2.

1137
00:55:49,950 --> 00:55:55,610
So make sure you understand
that and think about that

1138
00:55:55,610 --> 00:55:59,780
so that you're
following and get this.

1139
00:55:59,780 --> 00:56:04,370
All right, so
let's move on here.

1140
00:56:04,370 --> 00:56:06,070
So we have another
five minutes or so.

1141
00:56:06,070 --> 00:56:11,640
Let's start thinking about
closure under concatenation.

1142
00:56:11,640 --> 00:56:13,410
So if we have two
regular languages,

1143
00:56:13,410 --> 00:56:17,400
so is the
concatenation language.

1144
00:56:17,400 --> 00:56:18,810
We're going to
try to prove that.

1145
00:56:18,810 --> 00:56:21,780
We won't finish, but we'll at
least get our creative juices

1146
00:56:21,780 --> 00:56:23,620
going about it.

1147
00:56:23,620 --> 00:56:25,620
So we're going to do
the same scheme here.

1148
00:56:25,620 --> 00:56:29,610
We're going to take two
machines for A1 and A2

1149
00:56:29,610 --> 00:56:31,890
and build a machine for the
concatenation language out

1150
00:56:31,890 --> 00:56:32,790
of those two.

1151
00:56:32,790 --> 00:56:38,220
So here are the two machines
for A1 and A2 written down.

1152
00:56:38,220 --> 00:56:43,320
And now here is the
concatenation language.

1153
00:56:43,320 --> 00:56:46,240
And I'm going to propose
to you a strategy--

1154
00:56:46,240 --> 00:56:48,150
which is not going
to work, but it still

1155
00:56:48,150 --> 00:56:50,590
is going to be a good
intuition to have.

1156
00:56:50,590 --> 00:56:53,550
So what I'm going to do is
I'm going to make a copy of--

1157
00:56:53,550 --> 00:56:56,530
OK, let's understand what
M is supposed to do first.

1158
00:56:56,530 --> 00:56:58,170
So M should accept its input.

1159
00:56:58,170 --> 00:56:59,040
So think about this.

1160
00:56:59,040 --> 00:57:01,050
M is doing the
concatenation language.

1161
00:57:01,050 --> 00:57:02,610
So it's given a string.

1162
00:57:02,610 --> 00:57:07,380
And it has to answer, is it
in the concatenation language

1163
00:57:07,380 --> 00:57:09,030
A1A2 or not?

1164
00:57:09,030 --> 00:57:13,560
So it should accept it if
there's some way to divide w

1165
00:57:13,560 --> 00:57:17,250
into two pieces where M1 accepts
the first piece and M2 accepts

1166
00:57:17,250 --> 00:57:20,540
the second piece.

1167
00:57:20,540 --> 00:57:23,290
So here would be the picture.

1168
00:57:23,290 --> 00:57:23,800
OK?

1169
00:57:23,800 --> 00:57:27,550
And now we have to try to
make a machine which is

1170
00:57:27,550 --> 00:57:29,170
going to solve this intuition.

1171
00:57:29,170 --> 00:57:32,341
So how would you
do that yourself?

1172
00:57:32,341 --> 00:57:34,580
I'm giving you w.

1173
00:57:34,580 --> 00:57:37,410
And you can simulate M1 and M2.

1174
00:57:37,410 --> 00:57:39,410
So the natural thing
is you're going

1175
00:57:39,410 --> 00:57:41,780
to start out by
simulating M1 for a while

1176
00:57:41,780 --> 00:57:44,600
and then shift into
simulating M2 for a while,

1177
00:57:44,600 --> 00:57:47,960
because that's what's
supposed to be happening

1178
00:57:47,960 --> 00:57:49,260
as you're processing the input.

1179
00:57:49,260 --> 00:57:54,580
So I'm going to suggest that in
terms of the diagram like this.

1180
00:57:54,580 --> 00:58:01,500
So we have here M1
and M2 copied here.

1181
00:58:01,500 --> 00:58:08,940
And what I propose doing
is connecting M1 to M2

1182
00:58:08,940 --> 00:58:13,230
so that when M1 has
accepted its input,

1183
00:58:13,230 --> 00:58:16,410
we're going to jump to
M2, because that's perhaps

1184
00:58:16,410 --> 00:58:17,850
the first part of w.

1185
00:58:17,850 --> 00:58:20,495
And now we're going to have M2
process the second part of w.

1186
00:58:20,495 --> 00:58:21,870
So the way I'm
going to implement

1187
00:58:21,870 --> 00:58:26,100
that is by declassifying
the start state of M2,

1188
00:58:26,100 --> 00:58:29,880
having transition symbols from
the accepting states of M1

1189
00:58:29,880 --> 00:58:37,225
to M2, and then removing these
guys here as accepting states.

1190
00:58:37,225 --> 00:58:39,350
And we would have to figure
out what sort of labels

1191
00:58:39,350 --> 00:58:40,400
to apply here.

1192
00:58:40,400 --> 00:58:44,970
But, actually, this
reasoning doesn't work.

1193
00:58:44,970 --> 00:58:47,400
It's tempting, but flawed.

1194
00:58:47,400 --> 00:58:50,520
Because-- what goes wrong?

1195
00:58:50,520 --> 00:58:52,260
What happens is that--

1196
00:58:52,260 --> 00:58:59,300
it might be that when M1 has
accepted an initial part of w

1197
00:58:59,300 --> 00:59:03,980
and then it wants M2
to accept the rest,

1198
00:59:03,980 --> 00:59:08,000
it might fail because M2
doesn't accept the rest.

1199
00:59:08,000 --> 00:59:10,190
And what you might have
been better off doing

1200
00:59:10,190 --> 00:59:13,370
is waiting longer
in M1, because there

1201
00:59:13,370 --> 00:59:15,440
might have been some
other later place

1202
00:59:15,440 --> 00:59:20,010
to split w, which
is still valid.

1203
00:59:20,010 --> 00:59:22,710
Splitting w in the
first place where

1204
00:59:22,710 --> 00:59:25,020
you have M1 accepting
an initial part

1205
00:59:25,020 --> 00:59:27,870
may not be the optimal
place to split w.

1206
00:59:27,870 --> 00:59:29,850
You might want to wait
later, and then you'll

1207
00:59:29,850 --> 00:59:34,230
have a better chance
of accepting w.

1208
00:59:34,230 --> 00:59:38,310
So I'm not sure if
you quite follow that.

1209
00:59:38,310 --> 00:59:41,230
But, in fact, it doesn't work.

1210
00:59:41,230 --> 00:59:42,780
The question is
where to split w,

1211
00:59:42,780 --> 00:59:46,050
and it's challenging,
because how do you

1212
00:59:46,050 --> 00:59:47,370
know where to split w?

1213
00:59:47,370 --> 00:59:50,040
Because it depends upon what--

1214
00:59:50,040 --> 00:59:54,490
it depends on y, and
you haven't seen y yet.

1215
00:59:54,490 --> 00:59:57,980
So when you try to think about
it that way, it looks hopeless.

1216
00:59:57,980 --> 00:59:59,840
But, in fact, it's still true.

1217
00:59:59,840 --> 01:00:03,270
And we'll see how to
do that on Thursday.

1218
01:00:03,270 --> 01:00:08,030
So just to recap
what we did today,

1219
01:00:08,030 --> 01:00:10,550
we did our
introductory stuff, we

1220
01:00:10,550 --> 01:00:14,250
defined finite automata,
regular languages.

1221
01:00:14,250 --> 01:00:17,630
We defined the regular
operations and expressions.

1222
01:00:17,630 --> 01:00:19,130
We showed that the
regular languages

1223
01:00:19,130 --> 01:00:20,960
are closed under union.

1224
01:00:20,960 --> 01:00:24,640
We started closure under
intersection, to be continued.

1225
01:00:24,640 --> 01:00:34,000

