1
00:00:24,880 --> 00:00:27,279
okay

2
00:00:27,359 --> 00:00:30,400
why don't we begin

3
00:00:29,119 --> 00:00:32,559
hi everybody

4
00:00:30,400 --> 00:00:35,760
see how many we got here

5
00:00:32,559 --> 00:00:37,200
uh most of you um

6
00:00:35,760 --> 00:00:39,600
i'm sure the others will show up

7
00:00:37,200 --> 00:00:40,800
hopefully uh soon enough

8
00:00:39,600 --> 00:00:43,520
so

9
00:00:40,800 --> 00:00:45,840
welcome back um

10
00:00:43,520 --> 00:00:46,879
we have today's lecture four

11
00:00:45,840 --> 00:00:48,000
and

12
00:00:46,879 --> 00:00:49,760
um

13
00:00:48,000 --> 00:00:51,440
let's just remember what we've been

14
00:00:49,760 --> 00:00:52,800
doing um

15
00:00:51,440 --> 00:00:55,840
in the

16
00:00:52,800 --> 00:00:59,840
last few lectures we were exploring

17
00:00:55,840 --> 00:01:03,120
uh the regular languages as described by

18
00:00:59,840 --> 00:01:04,879
finite automata and regular expressions

19
00:01:03,120 --> 00:01:05,760
we showed how to convert them back and

20
00:01:04,879 --> 00:01:08,560
forth

21
00:01:05,760 --> 00:01:10,640
those two models to one another

22
00:01:08,560 --> 00:01:13,040
and we also showed how to prove

23
00:01:10,640 --> 00:01:16,320
certain languages are not regular now

24
00:01:13,040 --> 00:01:18,000
remember finite automata are a very

25
00:01:16,320 --> 00:01:19,759
um weak

26
00:01:18,000 --> 00:01:22,640
model of computation they only have a

27
00:01:19,759 --> 00:01:25,119
limited memory a finite memory um

28
00:01:22,640 --> 00:01:27,920
and uh they still aren't able to do

29
00:01:25,119 --> 00:01:30,000
certain things with their finite memory

30
00:01:27,920 --> 00:01:31,840
but um

31
00:01:30,000 --> 00:01:33,759
they are

32
00:01:31,840 --> 00:01:35,600
you know um

33
00:01:33,759 --> 00:01:37,840
if you compare them with

34
00:01:35,600 --> 00:01:39,840
a general-purpose computer at least the

35
00:01:37,840 --> 00:01:40,720
way we think about it

36
00:01:39,840 --> 00:01:42,560
is

37
00:01:40,720 --> 00:01:44,320
their uh

38
00:01:42,560 --> 00:01:47,200
you know their capabilities are just

39
00:01:44,320 --> 00:01:49,280
extremely limited and so

40
00:01:47,200 --> 00:01:51,680
we're going to over the next uh few

41
00:01:49,280 --> 00:01:54,000
lectures explore uh some more powerful

42
00:01:51,680 --> 00:01:56,320
models we started doing that last time

43
00:01:54,000 --> 00:01:57,600
uh the context-free grammars and as

44
00:01:56,320 --> 00:01:59,280
we'll see there are certain things that

45
00:01:57,600 --> 00:02:00,880
you can do i think we saw that last time

46
00:01:59,280 --> 00:02:02,560
as well those are some things you can do

47
00:02:00,880 --> 00:02:04,640
with context-free grammars that you

48
00:02:02,560 --> 00:02:06,479
cannot do with finite automata

49
00:02:04,640 --> 00:02:09,200
and uh but they still have their

50
00:02:06,479 --> 00:02:11,760
limitations as we'll see um

51
00:02:09,200 --> 00:02:13,599
so um

52
00:02:11,760 --> 00:02:15,520
today what we're going to do we're going

53
00:02:13,599 --> 00:02:16,800
to continue that discussion

54
00:02:15,520 --> 00:02:18,080
uh by

55
00:02:16,800 --> 00:02:19,680
looking at the definition of

56
00:02:18,080 --> 00:02:20,480
context-free grammars in a more formal

57
00:02:19,680 --> 00:02:22,879
way

58
00:02:20,480 --> 00:02:24,879
uh one of the uh things that we do in

59
00:02:22,879 --> 00:02:26,160
this course is develop practice with

60
00:02:24,879 --> 00:02:29,040
formalism

61
00:02:26,160 --> 00:02:30,400
and um so that that's going to be in the

62
00:02:29,040 --> 00:02:32,400
spirit of that

63
00:02:30,400 --> 00:02:34,239
we also are going to look at their

64
00:02:32,400 --> 00:02:36,319
associated languages called the context

65
00:02:34,239 --> 00:02:37,760
free languages so they're going to be

66
00:02:36,319 --> 00:02:39,920
the counterpart for context-free

67
00:02:37,760 --> 00:02:41,120
grammars of what the regular languages

68
00:02:39,920 --> 00:02:43,680
are for the

69
00:02:41,120 --> 00:02:45,519
finite automata of regular expressions

70
00:02:43,680 --> 00:02:48,239
and then we're going to look at a an

71
00:02:45,519 --> 00:02:50,720
automaton based model

72
00:02:48,239 --> 00:02:53,440
which is the counterpart

73
00:02:50,720 --> 00:02:56,160
to the grammars called the push down

74
00:02:53,440 --> 00:02:57,680
automata and we'll see that those are

75
00:02:56,160 --> 00:03:00,080
equivalent in power

76
00:02:57,680 --> 00:03:01,599
and finally um well

77
00:03:00,080 --> 00:03:03,680
and as part of that we will show how to

78
00:03:01,599 --> 00:03:05,360
convert the context free grammars to the

79
00:03:03,680 --> 00:03:06,720
push-down automata

80
00:03:05,360 --> 00:03:08,159
and that's what that's what that's what

81
00:03:06,720 --> 00:03:11,840
we're going to do today so we're going

82
00:03:08,159 --> 00:03:14,560
to move on then and uh return to uh our

83
00:03:11,840 --> 00:03:16,640
topic of context-free grammars that we

84
00:03:14,560 --> 00:03:19,440
began last time and just to refresh your

85
00:03:16,640 --> 00:03:22,000
memory um so here was that example of a

86
00:03:19,440 --> 00:03:22,879
context free grammar that we gave last

87
00:03:22,000 --> 00:03:24,400
time

88
00:03:22,879 --> 00:03:26,239
and

89
00:03:24,400 --> 00:03:27,599
it has

90
00:03:26,239 --> 00:03:29,599
the way we're going to be writing

91
00:03:27,599 --> 00:03:32,560
context-free grammars is using a bit of

92
00:03:29,599 --> 00:03:35,840
a shorthand uh which looks like this

93
00:03:32,560 --> 00:03:38,480
when you have multiple rules that have

94
00:03:35,840 --> 00:03:41,280
the same variable on this on the left

95
00:03:38,480 --> 00:03:42,720
hand side you can combine them into one

96
00:03:41,280 --> 00:03:44,959
line

97
00:03:42,720 --> 00:03:47,760
so these two rules over here

98
00:03:44,959 --> 00:03:48,879
s goes to 0 s1 and s goes to r can be

99
00:03:47,760 --> 00:03:50,959
written

100
00:03:48,879 --> 00:03:52,799
in one line as a little bit more compact

101
00:03:50,959 --> 00:03:56,319
way this is standard

102
00:03:52,799 --> 00:03:57,439
as s goes to 0 s 1 or r that's where you

103
00:03:56,319 --> 00:03:59,920
would read this

104
00:03:57,439 --> 00:04:01,840
this is really two rules but written on

105
00:03:59,920 --> 00:04:02,640
one line

106
00:04:01,840 --> 00:04:06,080
okay

107
00:04:02,640 --> 00:04:08,319
so uh as you recall uh from last time a

108
00:04:06,080 --> 00:04:10,560
context-free grammar has terminals

109
00:04:08,319 --> 00:04:12,159
variables and rules uh those are the

110
00:04:10,560 --> 00:04:14,480
parts that we

111
00:04:12,159 --> 00:04:17,120
speak of as well as one of the variables

112
00:04:14,480 --> 00:04:18,560
being designate designated as a starting

113
00:04:17,120 --> 00:04:20,400
variable which gets the whole thing

114
00:04:18,560 --> 00:04:23,360
going so i'll talk remind you about how

115
00:04:20,400 --> 00:04:25,759
that computation goes but um

116
00:04:23,360 --> 00:04:27,199
so the variables are the symbols that

117
00:04:25,759 --> 00:04:28,720
appear on the left-hand side of the

118
00:04:27,199 --> 00:04:31,360
rules

119
00:04:28,720 --> 00:04:34,000
the terminals are the other symbols

120
00:04:31,360 --> 00:04:36,240
that appear in the grammar

121
00:04:34,000 --> 00:04:36,240
and

122
00:04:36,880 --> 00:04:39,120
the

123
00:04:39,919 --> 00:04:43,520
we

124
00:04:41,520 --> 00:04:46,560
take the grammar and we use it to

125
00:04:43,520 --> 00:04:49,600
generate strings according to a certain

126
00:04:46,560 --> 00:04:52,160
system and the system is that you start

127
00:04:49,600 --> 00:04:53,120
out by writing down the uh starting

128
00:04:52,160 --> 00:04:56,320
variable

129
00:04:53,120 --> 00:04:58,160
and then once you've written down that

130
00:04:56,320 --> 00:04:59,360
variable or whatever variables you have

131
00:04:58,160 --> 00:05:02,479
written down you're allowed to

132
00:04:59,360 --> 00:05:04,560
substitute them according to the rules

133
00:05:02,479 --> 00:05:07,280
of the substitution rules that are in

134
00:05:04,560 --> 00:05:08,800
the grammar so you can keep on replacing

135
00:05:07,280 --> 00:05:11,039
the variables that you have with the

136
00:05:08,800 --> 00:05:12,240
corresponding right hand sides

137
00:05:11,039 --> 00:05:14,560
and then

138
00:05:12,240 --> 00:05:16,560
you do that over and over again until

139
00:05:14,560 --> 00:05:18,320
you don't have any variables left only

140
00:05:16,560 --> 00:05:21,440
terminal symbols remain

141
00:05:18,320 --> 00:05:23,520
and at that point you have generated a

142
00:05:21,440 --> 00:05:25,680
string that's in the language of the

143
00:05:23,520 --> 00:05:26,639
grammar

144
00:05:25,680 --> 00:05:29,360
all right

145
00:05:26,639 --> 00:05:32,479
so the

146
00:05:29,360 --> 00:05:35,440
grammar's language is going to be

147
00:05:32,479 --> 00:05:38,160
a language over strings

148
00:05:35,440 --> 00:05:40,000
whose alphabet are the terminal symbols

149
00:05:38,160 --> 00:05:42,240
so the terminal symbols in a certain

150
00:05:40,000 --> 00:05:45,199
sense play the same role

151
00:05:42,240 --> 00:05:46,880
as the input alphabet say for the finite

152
00:05:45,199 --> 00:05:49,759
automata

153
00:05:46,880 --> 00:05:52,479
okay the the the variables are kind of

154
00:05:49,759 --> 00:05:54,960
internal working um symbols for the

155
00:05:52,479 --> 00:05:56,080
grammar the terminals are sort of are

156
00:05:54,960 --> 00:05:58,400
are the

157
00:05:56,080 --> 00:05:59,440
symbols over which the language is is

158
00:05:58,400 --> 00:06:00,800
written

159
00:05:59,440 --> 00:06:02,160
okay we'll make that more precise in a

160
00:06:00,800 --> 00:06:03,520
minute where when i give the formal

161
00:06:02,160 --> 00:06:05,520
definition

162
00:06:03,520 --> 00:06:07,199
so the result is the generated string

163
00:06:05,520 --> 00:06:09,280
and the language of the grammar is the

164
00:06:07,199 --> 00:06:11,759
language of all generated strings that

165
00:06:09,280 --> 00:06:14,000
you can get using that grammar so

166
00:06:11,759 --> 00:06:17,360
um and the important thing is that we

167
00:06:14,000 --> 00:06:19,120
call that language a context free

168
00:06:17,360 --> 00:06:22,000
language

169
00:06:19,120 --> 00:06:24,080
okay so the that's like what we get from

170
00:06:22,000 --> 00:06:26,000
that that's the analogous thing to the

171
00:06:24,080 --> 00:06:28,160
regular languages but here we call them

172
00:06:26,000 --> 00:06:29,520
context-free languages uh the things

173
00:06:28,160 --> 00:06:32,000
that you can get from a context-free

174
00:06:29,520 --> 00:06:34,880
grammar again just a quick recap of that

175
00:06:32,000 --> 00:06:38,080
example we did last time

176
00:06:34,880 --> 00:06:39,520
so you start out by writing the

177
00:06:38,080 --> 00:06:41,680
start variable

178
00:06:39,520 --> 00:06:43,919
and then i'm going to give you kind of

179
00:06:41,680 --> 00:06:45,600
two views of that either in terms of the

180
00:06:43,919 --> 00:06:47,919
tree of substitutions which we call the

181
00:06:45,600 --> 00:06:50,160
parse tree or in terms of the resulting

182
00:06:47,919 --> 00:06:53,039
string as you do the substitutions so

183
00:06:50,160 --> 00:06:54,720
here is the uh parse tree here is the

184
00:06:53,039 --> 00:06:57,440
resulting strings here are the

185
00:06:54,720 --> 00:06:59,039
substitutions that you make um

186
00:06:57,440 --> 00:07:00,240
and now we have r

187
00:06:59,039 --> 00:07:02,240
um

188
00:07:00,240 --> 00:07:05,120
coming from s and we have zero zero r

189
00:07:02,240 --> 00:07:07,759
one one and now we have uh

190
00:07:05,120 --> 00:07:10,319
r in turn becomes an

191
00:07:07,759 --> 00:07:13,199
empty string and then uh the string that

192
00:07:10,319 --> 00:07:16,479
we generated is zero zero one one that's

193
00:07:13,199 --> 00:07:18,639
in the language of the grammar

194
00:07:16,479 --> 00:07:20,160
and now uh if you

195
00:07:18,639 --> 00:07:22,479
play with this a little bit you'll see

196
00:07:20,160 --> 00:07:24,560
that the language of the grammar is all

197
00:07:22,479 --> 00:07:28,720
strings that look like

198
00:07:24,560 --> 00:07:31,840
runs of zeros followed by runs of ones

199
00:07:28,720 --> 00:07:34,160
all right so uh is that clear

200
00:07:31,840 --> 00:07:37,120
um i think we're gonna have a

201
00:07:34,160 --> 00:07:38,400
um i think the next uh slide is gonna

202
00:07:37,120 --> 00:07:41,840
have a

203
00:07:38,400 --> 00:07:43,919
check in and so hopefully that'll uh

204
00:07:41,840 --> 00:07:44,879
get us all together on the same page

205
00:07:43,919 --> 00:07:47,199
with this

206
00:07:44,879 --> 00:07:49,840
anyway um so here's our formal

207
00:07:47,199 --> 00:07:51,680
definition anyway uh we have a

208
00:07:49,840 --> 00:07:54,319
context-free grammar

209
00:07:51,680 --> 00:07:56,000
is a four-tuple there are four parts of

210
00:07:54,319 --> 00:07:58,879
context for grammar these are the parts

211
00:07:56,000 --> 00:08:02,160
we've already been discussing uh the

212
00:07:58,879 --> 00:08:04,639
variables the terminal symbols the rules

213
00:08:02,160 --> 00:08:05,840
um the rules are always of the form a

214
00:08:04,639 --> 00:08:09,039
variable

215
00:08:05,840 --> 00:08:11,840
uh followed by you know with an arrow to

216
00:08:09,039 --> 00:08:13,199
a string of variables and terminals

217
00:08:11,840 --> 00:08:15,599
that's the way we write just write that

218
00:08:13,199 --> 00:08:16,879
down so this is the form of the rule

219
00:08:15,599 --> 00:08:19,199
and then we have the special start

220
00:08:16,879 --> 00:08:21,919
variable and we all wrap that up into a

221
00:08:19,199 --> 00:08:24,960
package this four tuple that's what the

222
00:08:21,919 --> 00:08:24,960
context free grammar is

223
00:08:25,039 --> 00:08:29,520
um

224
00:08:26,479 --> 00:08:30,879
now we have here uh

225
00:08:29,520 --> 00:08:32,640
and now

226
00:08:30,879 --> 00:08:35,839
maybe a little bit overkill but let's

227
00:08:32,640 --> 00:08:38,080
talk about what formally speaking what

228
00:08:35,839 --> 00:08:39,599
the the way the grammar actually

229
00:08:38,080 --> 00:08:42,000
processes

230
00:08:39,599 --> 00:08:43,760
um and produces strings

231
00:08:42,000 --> 00:08:46,240
um so

232
00:08:43,760 --> 00:08:48,560
we're going to write uh the the standard

233
00:08:46,240 --> 00:08:52,720
notation for this is that if you have

234
00:08:48,560 --> 00:08:54,800
two strings of variables and terminals

235
00:08:52,720 --> 00:08:56,320
so imagine you have an intermediate

236
00:08:54,800 --> 00:08:58,959
string that you've generated in the

237
00:08:56,320 --> 00:08:59,920
grammar so far

238
00:08:58,959 --> 00:09:02,800
um

239
00:08:59,920 --> 00:09:04,959
you know which might be like 0 0 s 1 1

240
00:09:02,800 --> 00:09:06,880
from the previous line so that's an

241
00:09:04,959 --> 00:09:10,240
intermediate string that is so far what

242
00:09:06,880 --> 00:09:12,480
you've generated you're going to say um

243
00:09:10,240 --> 00:09:13,760
maybe that's you and v might be the next

244
00:09:12,480 --> 00:09:15,120
line down

245
00:09:13,760 --> 00:09:17,519
uh

246
00:09:15,120 --> 00:09:21,519
so that means we're going to write u

247
00:09:17,519 --> 00:09:22,880
arrow v and that arrow is

248
00:09:21,519 --> 00:09:26,080
the the word we're going to use is

249
00:09:22,880 --> 00:09:28,880
yields we'll say u yields v

250
00:09:26,080 --> 00:09:32,080
um if it can go from u to v just with

251
00:09:28,880 --> 00:09:32,080
one substitution step

252
00:09:32,240 --> 00:09:34,640
um

253
00:09:33,279 --> 00:09:37,600
and then we'll write

254
00:09:34,640 --> 00:09:40,480
u yields v in some number of steps or

255
00:09:37,600 --> 00:09:42,320
actually we say u derives v

256
00:09:40,480 --> 00:09:44,399
if it can go to u to v with some number

257
00:09:42,320 --> 00:09:47,360
of substitutions instead of just one and

258
00:09:44,399 --> 00:09:49,600
that's used with the um the yields arrow

259
00:09:47,360 --> 00:09:51,360
with the star above it to mean some

260
00:09:49,600 --> 00:09:53,680
number of

261
00:09:51,360 --> 00:09:54,640
um another way of writing that is you

262
00:09:53,680 --> 00:09:57,760
can say

263
00:09:54,640 --> 00:09:59,760
u goes to v if there are a bunch of one

264
00:09:57,760 --> 00:10:01,360
step moves that you can make which take

265
00:09:59,760 --> 00:10:03,120
you from u to v

266
00:10:01,360 --> 00:10:05,040
and that whole sequence is called a

267
00:10:03,120 --> 00:10:08,320
derivation

268
00:10:05,040 --> 00:10:08,320
of v from u

269
00:10:08,399 --> 00:10:11,600
that's a sequence of steps that you go

270
00:10:10,160 --> 00:10:14,079
through

271
00:10:11,600 --> 00:10:16,160
doing these substitutions one by one to

272
00:10:14,079 --> 00:10:19,360
take you from u to v according to the

273
00:10:16,160 --> 00:10:20,720
rules of the grammar and lastly if u is

274
00:10:19,360 --> 00:10:22,000
a starting

275
00:10:20,720 --> 00:10:24,640
variable

276
00:10:22,000 --> 00:10:26,560
then we call that sequence

277
00:10:24,640 --> 00:10:29,040
just the derivation of v it could be the

278
00:10:26,560 --> 00:10:31,120
derivation from the start variable but

279
00:10:29,040 --> 00:10:33,040
that's kind of the assumed if you don't

280
00:10:31,120 --> 00:10:35,360
say it's a derivation from anything the

281
00:10:33,040 --> 00:10:37,279
derivation of v in the grammar is the

282
00:10:35,360 --> 00:10:39,120
derivation of v from the start variable

283
00:10:37,279 --> 00:10:41,040
it's just the sequence of substitutions

284
00:10:39,120 --> 00:10:42,800
that you make kind of the you know what

285
00:10:41,040 --> 00:10:45,360
you is

286
00:10:42,800 --> 00:10:47,440
what i think you would expect

287
00:10:45,360 --> 00:10:51,440
now the language of the grammar is the

288
00:10:47,440 --> 00:10:53,920
set of all strings that um

289
00:10:51,440 --> 00:10:56,959
of terminal symbols

290
00:10:53,920 --> 00:11:00,720
that you can get from uh starting at the

291
00:10:56,959 --> 00:11:02,480
starting variable of the grammar

292
00:11:00,720 --> 00:11:04,800
okay and that's called a context-free

293
00:11:02,480 --> 00:11:06,160
language as i mentioned before so it's a

294
00:11:04,800 --> 00:11:08,160
context of free language it's the

295
00:11:06,160 --> 00:11:10,320
language of of the grammar for some

296
00:11:08,160 --> 00:11:11,680
grammar

297
00:11:10,320 --> 00:11:13,920
okay so let's have a little check in

298
00:11:11,680 --> 00:11:15,200
here again nothing too hard nothing to

299
00:11:13,920 --> 00:11:18,640
get worried about anyway we're not

300
00:11:15,200 --> 00:11:19,920
counting correctness uh here so um

301
00:11:18,640 --> 00:11:22,480
let's just see

302
00:11:19,920 --> 00:11:25,920
um i'm gonna give you two

303
00:11:22,480 --> 00:11:28,480
uh things that look like grammars

304
00:11:25,920 --> 00:11:32,399
which of them are actually grammars and

305
00:11:28,480 --> 00:11:34,880
let me just pull that poll up uh here

306
00:11:32,399 --> 00:11:36,480
okay so which of these are valid

307
00:11:34,880 --> 00:11:37,600
grammars here

308
00:11:36,480 --> 00:11:40,000
are they both

309
00:11:37,600 --> 00:11:40,000
neither

310
00:11:40,640 --> 00:11:44,079
i mean you can kind of make an argument

311
00:11:42,320 --> 00:11:45,600
either you know either way for both of

312
00:11:44,079 --> 00:11:47,040
them but both of them are kind of a

313
00:11:45,600 --> 00:11:49,040
little have their own

314
00:11:47,040 --> 00:11:50,720
a bit of weirdness to them uh in a way

315
00:11:49,040 --> 00:11:53,760
if you if you if you

316
00:11:50,720 --> 00:11:53,760
study them for a second

317
00:11:54,839 --> 00:12:03,600
um okay that's pretty much converged um

318
00:11:59,839 --> 00:12:03,600
share the results um

319
00:12:05,680 --> 00:12:09,600
okay so um

320
00:12:07,760 --> 00:12:11,680
so in fact

321
00:12:09,600 --> 00:12:12,150
the correct answer is b

322
00:12:11,680 --> 00:12:14,079
um

323
00:12:12,150 --> 00:12:15,920
[Music]

324
00:12:14,079 --> 00:12:19,200
and uh

325
00:12:15,920 --> 00:12:21,040
why is only c2

326
00:12:19,200 --> 00:12:22,639
first of all you know well what's wrong

327
00:12:21,040 --> 00:12:25,760
with c1

328
00:12:22,639 --> 00:12:29,680
c1 the problem with c1 is that the rules

329
00:12:25,760 --> 00:12:31,360
have things besides a single variable on

330
00:12:29,680 --> 00:12:33,600
the left hand side

331
00:12:31,360 --> 00:12:37,120
so having a b1 on the left-hand side is

332
00:12:33,600 --> 00:12:38,160
not legal in a context-free grammar

333
00:12:37,120 --> 00:12:40,240
in fact there are other kinds of

334
00:12:38,160 --> 00:12:41,440
grammars

335
00:12:40,240 --> 00:12:43,440
there's a kind of grammar called a

336
00:12:41,440 --> 00:12:45,839
context sensitive grammar the term

337
00:12:43,440 --> 00:12:46,959
context free means you can replace the

338
00:12:45,839 --> 00:12:49,440
variable

339
00:12:46,959 --> 00:12:51,519
independent of its context in the

340
00:12:49,440 --> 00:12:53,519
intermediate string so independent of

341
00:12:51,519 --> 00:12:55,760
what's around it but here the this

342
00:12:53,519 --> 00:12:57,839
substitution is going to you can replace

343
00:12:55,760 --> 00:12:59,200
b but it depends on there being a one

344
00:12:57,839 --> 00:13:00,800
next to it

345
00:12:59,200 --> 00:13:02,320
um

346
00:13:00,800 --> 00:13:03,839
this is called a context sentence set of

347
00:13:02,320 --> 00:13:05,440
grammar but it's not the kind of

348
00:13:03,839 --> 00:13:07,519
character we're going to be using which

349
00:13:05,440 --> 00:13:08,399
are only context free grammar so c1 is

350
00:13:07,519 --> 00:13:10,800
out

351
00:13:08,399 --> 00:13:12,880
that's not a legit

352
00:13:10,800 --> 00:13:14,720
context-free grammar

353
00:13:12,880 --> 00:13:16,959
c2

354
00:13:14,720 --> 00:13:19,360
the thing that's a little weird about c2

355
00:13:16,959 --> 00:13:20,480
is if you try to generate a string in c2

356
00:13:19,360 --> 00:13:21,360
you'll see

357
00:13:20,480 --> 00:13:23,839
that

358
00:13:21,360 --> 00:13:25,519
um there's no way to get rid of the

359
00:13:23,839 --> 00:13:27,839
variables you're always going to be

360
00:13:25,519 --> 00:13:29,360
stuck with the variable um now that

361
00:13:27,839 --> 00:13:31,760
doesn't violate

362
00:13:29,360 --> 00:13:34,560
the definition of a context-free grammar

363
00:13:31,760 --> 00:13:35,680
so this is a context-free grammar but

364
00:13:34,560 --> 00:13:39,120
but it's not going to be able to

365
00:13:35,680 --> 00:13:42,000
generate any strings of only terminals

366
00:13:39,120 --> 00:13:43,600
so this is a context-free grammar whose

367
00:13:42,000 --> 00:13:47,040
language happens to be the empty

368
00:13:43,600 --> 00:13:49,680
language but that's totally okay

369
00:13:47,040 --> 00:13:52,480
so the correct answer here is b

370
00:13:49,680 --> 00:13:55,120
that only c2 here is a valid

371
00:13:52,480 --> 00:13:58,160
context-free grammar

372
00:13:55,120 --> 00:13:59,839
okay um

373
00:13:58,160 --> 00:14:03,440
common let's just see common question

374
00:13:59,839 --> 00:14:06,560
does a string u derive itself

375
00:14:03,440 --> 00:14:08,399
yes a string u derives itself uh

376
00:14:06,560 --> 00:14:09,920
that's a little bit of a little bit of

377
00:14:08,399 --> 00:14:11,199
an esoteric question there for us right

378
00:14:09,920 --> 00:14:14,639
now but yes

379
00:14:11,199 --> 00:14:18,240
um a string u in in this definition here

380
00:14:14,639 --> 00:14:20,160
u arrow stars you is legit is illegal

381
00:14:18,240 --> 00:14:22,240
maybe it isn't

382
00:14:20,160 --> 00:14:24,720
uh according to the way i've written it

383
00:14:22,240 --> 00:14:25,760
down here but it is it is uh a legal

384
00:14:24,720 --> 00:14:28,000
thing it's not going to really matter

385
00:14:25,760 --> 00:14:31,040
for you anyway but but it is illegal

386
00:14:28,000 --> 00:14:33,360
okay let's continue um

387
00:14:31,040 --> 00:14:36,079
let's do another somewhat interesting

388
00:14:33,360 --> 00:14:39,920
example of a context-free grammar um

389
00:14:36,079 --> 00:14:42,560
this is a grammar that is um

390
00:14:39,920 --> 00:14:46,000
can generate arithmetical expressions

391
00:14:42,560 --> 00:14:46,000
involving pluses and times

392
00:14:46,320 --> 00:14:50,720
so here it is it has

393
00:14:48,320 --> 00:14:53,360
how many rules well there are six rules

394
00:14:50,720 --> 00:14:55,440
here each line represents two rules so e

395
00:14:53,360 --> 00:14:58,639
goes to e plus t or t

396
00:14:55,440 --> 00:15:02,000
t goes to t times f or f and f goes to

397
00:14:58,639 --> 00:15:03,040
uh parenthesis e parenthesis or a

398
00:15:02,000 --> 00:15:04,480
um

399
00:15:03,040 --> 00:15:05,920
now so the

400
00:15:04,480 --> 00:15:07,680
variables are going to be the symbols

401
00:15:05,920 --> 00:15:09,920
that appear on the left hand side et and

402
00:15:07,680 --> 00:15:12,399
f the terminal symbols which are going

403
00:15:09,920 --> 00:15:14,480
to be the symbols of the language that

404
00:15:12,399 --> 00:15:16,720
you're going to be generating um is

405
00:15:14,480 --> 00:15:19,279
going to be the plus the time symbols

406
00:15:16,720 --> 00:15:20,800
the parentheses are just terminal

407
00:15:19,279 --> 00:15:22,959
symbols here so they're nothing not

408
00:15:20,800 --> 00:15:24,320
playing any special role besides that

409
00:15:22,959 --> 00:15:27,040
and then you have the a which is

410
00:15:24,320 --> 00:15:30,480
representing kind of the um

411
00:15:27,040 --> 00:15:32,160
operand on which those operators uh

412
00:15:30,480 --> 00:15:33,839
would be working if there was actually

413
00:15:32,160 --> 00:15:36,000
an expression you would use but they're

414
00:15:33,839 --> 00:15:37,759
just symbols from the perspective of the

415
00:15:36,000 --> 00:15:39,759
of the grammar

416
00:15:37,759 --> 00:15:41,839
and lastly the start variable is going

417
00:15:39,759 --> 00:15:44,639
to be as normally

418
00:15:41,839 --> 00:15:46,160
appears on the upper left hand side

419
00:15:44,639 --> 00:15:48,160
of the

420
00:15:46,160 --> 00:15:49,839
grammar in terms of the way you write it

421
00:15:48,160 --> 00:15:51,440
down

422
00:15:49,839 --> 00:15:53,600
so sometimes you might specify a

423
00:15:51,440 --> 00:15:55,600
different start variable but

424
00:15:53,600 --> 00:15:57,759
otherwise if not specified it's that

425
00:15:55,600 --> 00:16:00,240
it's the one in this corner here

426
00:15:57,759 --> 00:16:04,399
okay so let's just see uh some examples

427
00:16:00,240 --> 00:16:05,440
of uh using the grammar to generate

428
00:16:04,399 --> 00:16:07,360
uh

429
00:16:05,440 --> 00:16:10,079
a string so here is a string in the

430
00:16:07,360 --> 00:16:12,160
language a plus a times a and and this

431
00:16:10,079 --> 00:16:13,680
example will kind of reveal some other

432
00:16:12,160 --> 00:16:15,680
interesting features

433
00:16:13,680 --> 00:16:17,199
of the grammar but let's just see it in

434
00:16:15,680 --> 00:16:19,279
operation first

435
00:16:17,199 --> 00:16:21,040
so again i'll try to write it to you in

436
00:16:19,279 --> 00:16:22,720
both ways in terms of the parse tree and

437
00:16:21,040 --> 00:16:24,720
the resulting string as you're doing the

438
00:16:22,720 --> 00:16:26,800
substitutions

439
00:16:24,720 --> 00:16:27,600
so um

440
00:16:26,800 --> 00:16:29,839
the

441
00:16:27,600 --> 00:16:32,079
uh so first we start with the e

442
00:16:29,839 --> 00:16:34,160
then we substitute e plus t and we see

443
00:16:32,079 --> 00:16:36,079
the resulting string z plus t

444
00:16:34,160 --> 00:16:38,240
but now we as we're doing additional

445
00:16:36,079 --> 00:16:40,480
substitutions the resulting string that

446
00:16:38,240 --> 00:16:41,920
you get is going to evolve um

447
00:16:40,480 --> 00:16:42,800
accordingly

448
00:16:41,920 --> 00:16:44,000
and

449
00:16:42,800 --> 00:16:45,040
um so

450
00:16:44,000 --> 00:16:46,480
i hope

451
00:16:45,040 --> 00:16:49,279
it comes across

452
00:16:46,480 --> 00:16:51,600
that this tree here picture on the left

453
00:16:49,279 --> 00:16:53,759
shows you the structure of the various

454
00:16:51,600 --> 00:16:55,440
substitutions whereas on the right it

455
00:16:53,759 --> 00:16:58,720
just shows you the strings that you get

456
00:16:55,440 --> 00:17:00,240
as a result of those substitutions

457
00:16:58,720 --> 00:17:02,240
[Music]

458
00:17:00,240 --> 00:17:04,720
so now you can

459
00:17:02,240 --> 00:17:06,559
generate this particular string which is

460
00:17:04,720 --> 00:17:07,760
now in the language of this grammar you

461
00:17:06,559 --> 00:17:10,799
could generate all sorts of other

462
00:17:07,760 --> 00:17:12,319
strings as well uh such as

463
00:17:10,799 --> 00:17:14,799
you know parenthesis a plus a

464
00:17:12,319 --> 00:17:16,959
parenthesis times a and so on

465
00:17:14,799 --> 00:17:19,199
and in fact um

466
00:17:16,959 --> 00:17:21,520
this might be a piece

467
00:17:19,199 --> 00:17:23,199
of a programming language that you're

468
00:17:21,520 --> 00:17:24,240
trying to describe

469
00:17:23,199 --> 00:17:27,039
um

470
00:17:24,240 --> 00:17:30,000
and one application of

471
00:17:27,039 --> 00:17:32,720
context-free grammars is to describe the

472
00:17:30,000 --> 00:17:35,840
syntax of programming languages you know

473
00:17:32,720 --> 00:17:39,039
what are the legal programs that you can

474
00:17:35,840 --> 00:17:41,120
write with in that programming language

475
00:17:39,039 --> 00:17:42,000
and not only that

476
00:17:41,120 --> 00:17:44,960
the

477
00:17:42,000 --> 00:17:48,880
grammar can be used to automatically

478
00:17:44,960 --> 00:17:50,799
generate the part of the compiler uh for

479
00:17:48,880 --> 00:17:54,240
that programming language which will

480
00:17:50,799 --> 00:17:55,760
interpret the um which would

481
00:17:54,240 --> 00:17:58,000
uh

482
00:17:55,760 --> 00:18:00,320
interpret the structure of the input you

483
00:17:58,000 --> 00:18:02,960
know the so-called parser which will

484
00:18:00,320 --> 00:18:05,760
figure out the meaning of the

485
00:18:02,960 --> 00:18:08,080
uh input to the compiler so that the

486
00:18:05,760 --> 00:18:09,440
compiler then can generate the code or

487
00:18:08,080 --> 00:18:12,720
if it's an interpreter it could

488
00:18:09,440 --> 00:18:14,640
interpret the uh the resulting um code

489
00:18:12,720 --> 00:18:17,280
that you've given it um but the very

490
00:18:14,640 --> 00:18:20,640
first step in both of those is to figure

491
00:18:17,280 --> 00:18:22,640
out the meaning and the meaning is

492
00:18:20,640 --> 00:18:24,480
um embedded within the structure of the

493
00:18:22,640 --> 00:18:26,000
parse tree

494
00:18:24,480 --> 00:18:28,320
now in the in the case of this

495
00:18:26,000 --> 00:18:31,120
particular tree just to give you some

496
00:18:28,320 --> 00:18:33,600
sense of what meaning i have in mind

497
00:18:31,120 --> 00:18:36,400
this parse tree due to the structure of

498
00:18:33,600 --> 00:18:38,559
this grammar has the precedence for

499
00:18:36,400 --> 00:18:40,960
times over plus

500
00:18:38,559 --> 00:18:43,120
so normally when we write down a plus a

501
00:18:40,960 --> 00:18:44,880
times a you you assume you're going to

502
00:18:43,120 --> 00:18:46,559
do the multiplication before you do the

503
00:18:44,880 --> 00:18:48,320
addition even though it appears second

504
00:18:46,559 --> 00:18:50,960
that's just the way we tend to write

505
00:18:48,320 --> 00:18:54,400
things and and this grammar has grouped

506
00:18:50,960 --> 00:18:56,960
it that way for you it groups the times

507
00:18:54,400 --> 00:18:59,520
lower down in the tree than the plus so

508
00:18:56,960 --> 00:19:01,760
the the times is going to be done

509
00:18:59,520 --> 00:19:03,360
before the plus if you imagine doing

510
00:19:01,760 --> 00:19:05,760
this in terms of the way the tree is

511
00:19:03,360 --> 00:19:07,520
guiding you so the tree as you can see

512
00:19:05,760 --> 00:19:09,120
has a certain amount of meaning built

513
00:19:07,520 --> 00:19:11,280
into it now we're not actually going to

514
00:19:09,120 --> 00:19:12,720
be using that in this course but i just

515
00:19:11,280 --> 00:19:16,160
want to you

516
00:19:12,720 --> 00:19:20,000
describe that as a an illustration of

517
00:19:16,160 --> 00:19:22,080
how this material can get applied um

518
00:19:20,000 --> 00:19:23,520
now so you know here is what i'm saying

519
00:19:22,080 --> 00:19:25,360
that the tree contains additional

520
00:19:23,520 --> 00:19:28,799
information

521
00:19:25,360 --> 00:19:29,919
now that's also relevant um

522
00:19:28,799 --> 00:19:32,480
if

523
00:19:29,919 --> 00:19:35,280
you happen to have a grammar which might

524
00:19:32,480 --> 00:19:38,160
allow multiple parse trees for the same

525
00:19:35,280 --> 00:19:41,520
string

526
00:19:38,160 --> 00:19:42,480
okay that can happen um

527
00:19:41,520 --> 00:19:44,880
this

528
00:19:42,480 --> 00:19:46,559
particular grammar does not allow that

529
00:19:44,880 --> 00:19:48,559
but you might write other grammars that

530
00:19:46,559 --> 00:19:50,320
as we'll see in a minute that could

531
00:19:48,559 --> 00:19:53,120
generate the same string in multiple

532
00:19:50,320 --> 00:19:55,919
ways with multiple different parse trees

533
00:19:53,120 --> 00:19:57,440
now that might be undesirable

534
00:19:55,919 --> 00:19:58,320
when you have a programming language

535
00:19:57,440 --> 00:20:00,240
because

536
00:19:58,320 --> 00:20:01,679
typically you want it to be only a

537
00:20:00,240 --> 00:20:04,080
single meaning

538
00:20:01,679 --> 00:20:06,559
for your code you don't want it to be

539
00:20:04,080 --> 00:20:07,440
ambiguous and have multiple meanings

540
00:20:06,559 --> 00:20:09,200
but

541
00:20:07,440 --> 00:20:10,720
um

542
00:20:09,200 --> 00:20:14,039
uh

543
00:20:10,720 --> 00:20:16,240
ambiguity is it does occur and it's not

544
00:20:14,039 --> 00:20:19,919
necessarily something we're always going

545
00:20:16,240 --> 00:20:21,760
to uh see is a bad thing um so you know

546
00:20:19,919 --> 00:20:24,240
i think as i mentioned last time a lot

547
00:20:21,760 --> 00:20:26,559
of this subject originated with

548
00:20:24,240 --> 00:20:28,799
linguistics um and that's where the

549
00:20:26,559 --> 00:20:30,400
terminology comes from grammar

550
00:20:28,799 --> 00:20:31,919
and um

551
00:20:30,400 --> 00:20:34,880
uh

552
00:20:31,919 --> 00:20:36,240
languages and so on the terminology for

553
00:20:34,880 --> 00:20:38,400
the subject really comes out of

554
00:20:36,240 --> 00:20:40,080
linguistics in fact one of the key

555
00:20:38,400 --> 00:20:42,400
players for that is an emeritus faculty

556
00:20:40,080 --> 00:20:43,760
member at mit noam chomsky he was

557
00:20:42,400 --> 00:20:47,600
instrumental in setting a lot of this

558
00:20:43,760 --> 00:20:48,640
stuff up um but

559
00:20:47,600 --> 00:20:49,760
the

560
00:20:48,640 --> 00:20:51,440
um

561
00:20:49,760 --> 00:20:52,960
uh

562
00:20:51,440 --> 00:20:54,960
you you can think of grammars as

563
00:20:52,960 --> 00:20:56,640
applying to natural human languages as

564
00:20:54,960 --> 00:20:58,080
well so

565
00:20:56,640 --> 00:21:00,799
let me give you a little example as a

566
00:20:58,080 --> 00:21:03,120
pop-up this is not directly uh pop-up a

567
00:21:00,799 --> 00:21:04,640
check-in not directly relevant uh to the

568
00:21:03,120 --> 00:21:07,760
material i just presented but just sort

569
00:21:04,640 --> 00:21:10,400
of a curiosity um

570
00:21:07,760 --> 00:21:12,960
if you take the english sentence the boy

571
00:21:10,400 --> 00:21:14,000
saw the girl with the mirror

572
00:21:12,960 --> 00:21:15,039
um

573
00:21:14,000 --> 00:21:18,080
you know

574
00:21:15,039 --> 00:21:19,120
does that is there only one

575
00:21:18,080 --> 00:21:21,200
natural

576
00:21:19,120 --> 00:21:22,880
uh interpretation for that sentence or

577
00:21:21,200 --> 00:21:24,960
are there perhaps other natural

578
00:21:22,880 --> 00:21:28,400
interpretations for that sentence so let

579
00:21:24,960 --> 00:21:32,799
me pose that to you as another uh poll

580
00:21:28,400 --> 00:21:34,960
here um and uh

581
00:21:32,799 --> 00:21:37,520
so i ask you to think about how many

582
00:21:34,960 --> 00:21:39,039
different meanings you might find

583
00:21:37,520 --> 00:21:41,440
for

584
00:21:39,039 --> 00:21:42,720
uh reasonable different meanings i mean

585
00:21:41,440 --> 00:21:44,400
you can you know if

586
00:21:42,720 --> 00:21:45,679
you're going to go wild you can think of

587
00:21:44,400 --> 00:21:47,039
zillions of meetings but i think in

588
00:21:45,679 --> 00:21:49,039
terms of reasonable meanings how many

589
00:21:47,039 --> 00:21:49,840
meetings might you get for the sentence

590
00:21:49,039 --> 00:21:51,120
uh

591
00:21:49,840 --> 00:21:52,320
people are seeing more meetings than i'm

592
00:21:51,120 --> 00:21:54,080
seeing

593
00:21:52,320 --> 00:21:55,200
but that's okay

594
00:21:54,080 --> 00:21:57,280
um

595
00:21:55,200 --> 00:21:58,559
so this is a

596
00:21:57,280 --> 00:22:01,360
quick why don't we just give this

597
00:21:58,559 --> 00:22:01,360
another uh

598
00:22:02,000 --> 00:22:05,919
10 seconds here

599
00:22:04,080 --> 00:22:08,240
um

600
00:22:05,919 --> 00:22:11,520
and then um

601
00:22:08,240 --> 00:22:14,240
most of you are in agreement with me um

602
00:22:11,520 --> 00:22:15,679
uh i can see here

603
00:22:14,240 --> 00:22:16,559
that uh

604
00:22:15,679 --> 00:22:18,720
uh

605
00:22:16,559 --> 00:22:21,039
you are

606
00:22:18,720 --> 00:22:22,640
uh seeing that there were two meanings

607
00:22:21,039 --> 00:22:24,960
the two meanings that i see here for

608
00:22:22,640 --> 00:22:26,320
this sentence are um

609
00:22:24,960 --> 00:22:28,799
when you say the boys or the girl with

610
00:22:26,320 --> 00:22:30,960
the mirror is who has the mirror

611
00:22:28,799 --> 00:22:32,000
is it the boy seeing the girl through

612
00:22:30,960 --> 00:22:33,919
the mirror

613
00:22:32,000 --> 00:22:35,840
or is it the girl that has the mirror

614
00:22:33,919 --> 00:22:38,240
and the boy just happens to see her so

615
00:22:35,840 --> 00:22:40,000
two very different meanings for the same

616
00:22:38,240 --> 00:22:42,799
sentence and that's the nature of

617
00:22:40,000 --> 00:22:45,520
english it's just uh the the way um

618
00:22:42,799 --> 00:22:47,840
uh it's it's an it's it's an ambiguous

619
00:22:45,520 --> 00:22:50,000
um structure there and often we resolve

620
00:22:47,840 --> 00:22:53,200
that ambiguity in english with other

621
00:22:50,000 --> 00:22:54,640
information that we might have um but um

622
00:22:53,200 --> 00:22:57,039
typically you don't want there to be

623
00:22:54,640 --> 00:22:58,480
ambiguity when you have this a grammar

624
00:22:57,039 --> 00:23:00,559
say describing a programming like

625
00:22:58,480 --> 00:23:01,440
programming language

626
00:23:00,559 --> 00:23:02,480
okay

627
00:23:01,440 --> 00:23:06,240
um

628
00:23:02,480 --> 00:23:07,600
so let's continue on that um

629
00:23:06,240 --> 00:23:09,679
so talking a little bit more about

630
00:23:07,600 --> 00:23:11,360
ambiguity i was promised you an example

631
00:23:09,679 --> 00:23:12,880
where you might have an ambiguous

632
00:23:11,360 --> 00:23:15,679
grammar um

633
00:23:12,880 --> 00:23:18,720
so uh if you take these two grammars g2

634
00:23:15,679 --> 00:23:19,600
and g3 the g2 from the last slide and g3

635
00:23:18,720 --> 00:23:21,760
is a

636
00:23:19,600 --> 00:23:25,600
similar grammar in fact has it's the

637
00:23:21,760 --> 00:23:25,600
grammar that has the very same language

638
00:23:25,919 --> 00:23:30,720
um that gives you the very same language

639
00:23:27,679 --> 00:23:32,480
so l of g2 equals l of g3 both of them

640
00:23:30,720 --> 00:23:33,679
are describing these arithmetical

641
00:23:32,480 --> 00:23:34,480
expressions

642
00:23:33,679 --> 00:23:38,080
um

643
00:23:34,480 --> 00:23:40,559
but whereas g2 has a unique parse tree

644
00:23:38,080 --> 00:23:42,400
for every string that you generate g3

645
00:23:40,559 --> 00:23:43,679
can have multiple parse trees for the

646
00:23:42,400 --> 00:23:45,279
same string

647
00:23:43,679 --> 00:23:47,120
okay so i'm just going to illustrate

648
00:23:45,279 --> 00:23:49,520
that here so here is the same string

649
00:23:47,120 --> 00:23:50,720
that we generated last time a plus a

650
00:23:49,520 --> 00:23:53,840
times a

651
00:23:50,720 --> 00:23:54,880
in g3 the parse tree is actually even

652
00:23:53,840 --> 00:23:58,080
simpler

653
00:23:54,880 --> 00:23:59,840
here um so here i'm showing you the uh

654
00:23:58,080 --> 00:24:00,640
there's just the two substitutions that

655
00:23:59,840 --> 00:24:04,400
you

656
00:24:00,640 --> 00:24:06,880
uh need to make starting from e and then

657
00:24:04,400 --> 00:24:08,559
to to get the string a plus a times a

658
00:24:06,880 --> 00:24:09,600
it's a it's a it's a simpler grammar in

659
00:24:08,559 --> 00:24:11,440
a sense

660
00:24:09,600 --> 00:24:13,279
um but you there's another parse tree

661
00:24:11,440 --> 00:24:15,279
that'll give you the same

662
00:24:13,279 --> 00:24:17,360
uh result and i've written that down

663
00:24:15,279 --> 00:24:18,559
below here

664
00:24:17,360 --> 00:24:22,720
upside down

665
00:24:18,559 --> 00:24:24,640
um so uh the upper parse tree groups the

666
00:24:22,720 --> 00:24:27,360
times before the plus

667
00:24:24,640 --> 00:24:30,000
or more in more inside uh

668
00:24:27,360 --> 00:24:31,919
than the plus but the lower parse tree

669
00:24:30,000 --> 00:24:34,400
doesn't have that precedence built into

670
00:24:31,919 --> 00:24:36,720
it and can alternatively interpret the

671
00:24:34,400 --> 00:24:39,520
plus as being of higher precedence than

672
00:24:36,720 --> 00:24:43,200
times and so in that sense we have here

673
00:24:39,520 --> 00:24:46,559
um a grammar which is um has two

674
00:24:43,200 --> 00:24:48,880
interpretations for this um

675
00:24:46,559 --> 00:24:50,320
same string and we call that whoops we

676
00:24:48,880 --> 00:24:52,320
call that an

677
00:24:50,320 --> 00:24:53,360
an ambiguous

678
00:24:52,320 --> 00:24:56,640
uh

679
00:24:53,360 --> 00:24:58,159
derivation ambiguously derived string

680
00:24:56,640 --> 00:25:00,400
and the grammar itself is called an

681
00:24:58,159 --> 00:25:02,799
ambiguous grammar

682
00:25:00,400 --> 00:25:02,799
um

683
00:25:03,360 --> 00:25:08,720
uh okay

684
00:25:05,200 --> 00:25:10,320
so let us continue on from that

685
00:25:08,720 --> 00:25:11,360
by the way there's a question here that

686
00:25:10,320 --> 00:25:12,880
came in

687
00:25:11,360 --> 00:25:15,520
uh

688
00:25:12,880 --> 00:25:18,000
uh like for example a plus a is that

689
00:25:15,520 --> 00:25:21,120
ambiguous in g2 no

690
00:25:18,000 --> 00:25:24,080
uh if you if you try to uh apply it

691
00:25:21,120 --> 00:25:27,520
you'll see the way that g2 can produce a

692
00:25:24,080 --> 00:25:29,039
plus a to a plus a plus a

693
00:25:27,520 --> 00:25:31,440
is going to group the first two and then

694
00:25:29,039 --> 00:25:33,279
the and then the the second one then the

695
00:25:31,440 --> 00:25:36,400
last one you can't you can't derive

696
00:25:33,279 --> 00:25:38,480
things in multiple ways um i mean

697
00:25:36,400 --> 00:25:39,760
addition is associative but the grammar

698
00:25:38,480 --> 00:25:42,320
doesn't

699
00:25:39,760 --> 00:25:43,520
it doesn't the grammar for the grammar

700
00:25:42,320 --> 00:25:45,919
um

701
00:25:43,520 --> 00:25:48,640
it's going to have a prescribed order

702
00:25:45,919 --> 00:25:52,559
for the way things get interpreted there

703
00:25:48,640 --> 00:25:56,000
okay um so that's ambiguity um so let's

704
00:25:52,559 --> 00:25:58,880
uh introduce push down automata um which

705
00:25:56,000 --> 00:25:59,840
is going to be our automata counterpart

706
00:25:58,880 --> 00:26:03,520
for

707
00:25:59,840 --> 00:26:03,520
context-free languages

708
00:26:03,679 --> 00:26:08,320
all right um so the way i'm going to

709
00:26:05,919 --> 00:26:10,960
introduce push-down automata uh sort of

710
00:26:08,320 --> 00:26:13,279
shifting gears here and now um

711
00:26:10,960 --> 00:26:13,279
is

712
00:26:13,360 --> 00:26:18,880
by first

713
00:26:14,720 --> 00:26:20,799
uh giving a new view of finite automata

714
00:26:18,880 --> 00:26:23,279
remember before when we presented a

715
00:26:20,799 --> 00:26:25,200
finite automaton we gave it in terms of

716
00:26:23,279 --> 00:26:28,080
a state diagram which i've kind of shown

717
00:26:25,200 --> 00:26:29,440
here in miniature form on the picture

718
00:26:28,080 --> 00:26:30,960
um

719
00:26:29,440 --> 00:26:33,279
uh

720
00:26:30,960 --> 00:26:35,039
we could do that for pushdown automata

721
00:26:33,279 --> 00:26:37,360
but the picture tends to be very

722
00:26:35,039 --> 00:26:40,320
complicated so i'm going to take a bit

723
00:26:37,360 --> 00:26:42,640
of a higher level um

724
00:26:40,320 --> 00:26:45,039
uh description for pushdown automata

725
00:26:42,640 --> 00:26:46,720
which is i'm calling a schematic view or

726
00:26:45,039 --> 00:26:48,240
a schematic diagram

727
00:26:46,720 --> 00:26:50,080
and there i'm really not going to be

728
00:26:48,240 --> 00:26:51,039
showing you the individual states but

729
00:26:50,080 --> 00:26:53,919
i'm going to be showing you the

730
00:26:51,039 --> 00:26:55,840
individual components of the machine at

731
00:26:53,919 --> 00:26:58,799
a sort of more of an abstract

732
00:26:55,840 --> 00:27:01,150
and from a more abstract perspective and

733
00:26:58,799 --> 00:27:02,320
so from that perspective um

734
00:27:01,150 --> 00:27:04,720
[Music]

735
00:27:02,320 --> 00:27:08,000
a finite automaton has here what i'm

736
00:27:04,720 --> 00:27:09,520
going to call the finite control so i'm

737
00:27:08,000 --> 00:27:10,720
going to be suppressing the details of

738
00:27:09,520 --> 00:27:12,880
the states

739
00:27:10,720 --> 00:27:15,279
in this pic in this picture i'm going to

740
00:27:12,880 --> 00:27:16,400
represent uh that those states as the

741
00:27:15,279 --> 00:27:19,520
control

742
00:27:16,400 --> 00:27:21,039
of the um of the dfa or the nfa they're

743
00:27:19,520 --> 00:27:22,159
really going to be the same

744
00:27:21,039 --> 00:27:25,039
from this

745
00:27:22,159 --> 00:27:26,960
pictorial point of view um the input is

746
00:27:25,039 --> 00:27:29,360
going to be appear on

747
00:27:26,960 --> 00:27:30,960
as a string that's written down on what

748
00:27:29,360 --> 00:27:32,840
we're calling a tape

749
00:27:30,960 --> 00:27:35,679
again this is somewhat of an

750
00:27:32,840 --> 00:27:36,559
anachronistic terminology back in my

751
00:27:35,679 --> 00:27:38,960
days

752
00:27:36,559 --> 00:27:42,399
people actually did feed their inputs

753
00:27:38,960 --> 00:27:44,159
into computers on a tape sometimes

754
00:27:42,399 --> 00:27:46,320
we don't do that so much anymore but

755
00:27:44,159 --> 00:27:48,799
that terminology has stuck and it's

756
00:27:46,320 --> 00:27:50,640
going to be a persisting um

757
00:27:48,799 --> 00:27:53,039
uh later on in the course too so you

758
00:27:50,640 --> 00:27:54,960
might as well get used to it um so the

759
00:27:53,039 --> 00:27:57,360
input is going to appear on a tape or

760
00:27:54,960 --> 00:27:58,720
sometimes called an input tape um and

761
00:27:57,360 --> 00:28:01,760
the way the

762
00:27:58,720 --> 00:28:04,799
machine actually will read that input

763
00:28:01,760 --> 00:28:06,480
whoops uh is going to have a head

764
00:28:04,799 --> 00:28:08,880
which is going to be

765
00:28:06,480 --> 00:28:11,120
um starting at the left side and moving

766
00:28:08,880 --> 00:28:12,559
from left to right reading the symbols

767
00:28:11,120 --> 00:28:13,760
on the that appear on the input tape one

768
00:28:12,559 --> 00:28:17,760
by one

769
00:28:13,760 --> 00:28:19,600
okay so this is our picture of a an

770
00:28:17,760 --> 00:28:21,039
a finite automaton

771
00:28:19,600 --> 00:28:23,360
just redone

772
00:28:21,039 --> 00:28:25,840
from uh last time just a different way

773
00:28:23,360 --> 00:28:28,559
of picturing it now that's going to be

774
00:28:25,840 --> 00:28:30,559
setting the stage for the picture of a

775
00:28:28,559 --> 00:28:33,279
push down automaton because the push-on

776
00:28:30,559 --> 00:28:36,320
automaton is like a finite automaton but

777
00:28:33,279 --> 00:28:38,880
it has an extra feature has an extra

778
00:28:36,320 --> 00:28:41,120
device attached to it and that's called

779
00:28:38,880 --> 00:28:42,880
a stack

780
00:28:41,120 --> 00:28:44,640
okay so here's a schematic diagram for

781
00:28:42,880 --> 00:28:47,840
push down automaton

782
00:28:44,640 --> 00:28:49,679
and that's going to be a stack

783
00:28:47,840 --> 00:28:51,120
which is going to be

784
00:28:49,679 --> 00:28:54,159
basically

785
00:28:51,120 --> 00:28:55,520
a form of auxiliary

786
00:28:54,159 --> 00:28:57,679
storage

787
00:28:55,520 --> 00:29:02,000
now remember part of the limitation for

788
00:28:57,679 --> 00:29:04,960
a finite automaton was that we had a

789
00:29:02,000 --> 00:29:05,840
limited amount of memory

790
00:29:04,960 --> 00:29:07,279
um

791
00:29:05,840 --> 00:29:09,039
so

792
00:29:07,279 --> 00:29:11,279
we were not able to do some very simple

793
00:29:09,039 --> 00:29:12,480
things like counting because we had a

794
00:29:11,279 --> 00:29:14,559
limited memory

795
00:29:12,480 --> 00:29:17,039
so the push-on automaton is going to be

796
00:29:14,559 --> 00:29:18,880
able to use its stack as a kind of

797
00:29:17,039 --> 00:29:21,840
unbounded memory

798
00:29:18,880 --> 00:29:24,240
but a memory that's very restricted in

799
00:29:21,840 --> 00:29:28,080
the way it can be used so it's unlimited

800
00:29:24,240 --> 00:29:28,080
but still restricted as we'll see

801
00:29:28,480 --> 00:29:32,240
so

802
00:29:29,200 --> 00:29:35,039
uh the way the push down automaton uses

803
00:29:32,240 --> 00:29:36,880
um this extra memory

804
00:29:35,039 --> 00:29:38,720
on on what we're calling the stack or

805
00:29:36,880 --> 00:29:41,840
push down stack

806
00:29:38,720 --> 00:29:44,880
is that you can write symbols

807
00:29:41,840 --> 00:29:47,360
um instead of only reading symbols but

808
00:29:44,880 --> 00:29:49,200
those symbols can only be read at the

809
00:29:47,360 --> 00:29:51,760
very

810
00:29:49,200 --> 00:29:53,600
written or read at the very top

811
00:29:51,760 --> 00:29:56,000
of this list of symbols

812
00:29:53,600 --> 00:29:58,320
and every time you add a new symbol the

813
00:29:56,000 --> 00:30:01,200
other symbols that are already there get

814
00:29:58,320 --> 00:30:04,320
pushed down hence the name people also

815
00:30:01,200 --> 00:30:06,720
often refer to it as a stack of plates

816
00:30:04,320 --> 00:30:08,559
uh in a cafeteria if you've ever seen

817
00:30:06,720 --> 00:30:10,880
those things or you can remember back to

818
00:30:08,559 --> 00:30:12,799
the days when we went to cafeteria uh

819
00:30:10,880 --> 00:30:14,720
which getting further and further away

820
00:30:12,799 --> 00:30:16,640
but um

821
00:30:14,720 --> 00:30:18,559
uh if you have a cafeteria you had a

822
00:30:16,640 --> 00:30:20,720
stack of plates and you know you as you

823
00:30:18,559 --> 00:30:22,720
removed plates from them they were on a

824
00:30:20,720 --> 00:30:24,720
spring and they kept coming up or if you

825
00:30:22,720 --> 00:30:26,640
add more they would go down and it's the

826
00:30:24,720 --> 00:30:29,919
same idea imagine these symbols here are

827
00:30:26,640 --> 00:30:31,600
sort of on a um on a spring and the more

828
00:30:29,919 --> 00:30:34,240
symbols you add them the more they go

829
00:30:31,600 --> 00:30:36,159
down uh or if you remove them by read

830
00:30:34,240 --> 00:30:39,360
and read them and remove them then they

831
00:30:36,159 --> 00:30:42,559
move back up okay

832
00:30:39,360 --> 00:30:45,039
so a push out of tabaton operates like a

833
00:30:42,559 --> 00:30:47,679
finite like a non-deterministic finite

834
00:30:45,039 --> 00:30:50,159
diameter as we'll see push down automata

835
00:30:47,679 --> 00:30:51,919
for out for us are always going to be

836
00:30:50,159 --> 00:30:54,399
allowed to be non-deterministic so we're

837
00:30:51,919 --> 00:30:56,080
not going to be studying the

838
00:30:54,399 --> 00:30:58,559
push on automata that are restricted to

839
00:30:56,080 --> 00:31:00,399
be only deterministic um

840
00:30:58,559 --> 00:31:03,200
uh i'll say more about that in a second

841
00:31:00,399 --> 00:31:04,880
but like they operate like an nfa except

842
00:31:03,200 --> 00:31:06,559
they can write

843
00:31:04,880 --> 00:31:07,440
uh or

844
00:31:06,559 --> 00:31:09,840
read

845
00:31:07,440 --> 00:31:11,440
symbols from the top of the stack

846
00:31:09,840 --> 00:31:14,320
and when they write they're adding the

847
00:31:11,440 --> 00:31:15,840
symbol on pushing down that stack and

848
00:31:14,320 --> 00:31:17,440
when they're reading they're removing

849
00:31:15,840 --> 00:31:18,720
symbols from the stack

850
00:31:17,440 --> 00:31:20,559
and thereby

851
00:31:18,720 --> 00:31:21,760
lifting up the stack

852
00:31:20,559 --> 00:31:23,360
okay

853
00:31:21,760 --> 00:31:25,200
we give them special names so those of

854
00:31:23,360 --> 00:31:27,760
you who have seen stacks already this is

855
00:31:25,200 --> 00:31:29,200
you know i'm sure old hat for you

856
00:31:27,760 --> 00:31:31,519
uh but

857
00:31:29,200 --> 00:31:34,799
i'm sure now everyone has have seen

858
00:31:31,519 --> 00:31:37,279
stacks before so uh the special name for

859
00:31:34,799 --> 00:31:39,760
writing onto a stack is called a push

860
00:31:37,279 --> 00:31:41,360
operation so that you're pushing a new

861
00:31:39,760 --> 00:31:43,200
symbol down on the top of the stack and

862
00:31:41,360 --> 00:31:45,039
it pushes everything down

863
00:31:43,200 --> 00:31:46,799
whereas when you're reading a symbol and

864
00:31:45,039 --> 00:31:48,320
removing it from the top of the stack

865
00:31:46,799 --> 00:31:50,559
that's called a pop

866
00:31:48,320 --> 00:31:52,159
so that's reading and removing

867
00:31:50,559 --> 00:31:54,240
we we always think of those as going

868
00:31:52,159 --> 00:31:56,240
together writing and editing and reading

869
00:31:54,240 --> 00:31:58,640
and removing are combined

870
00:31:56,240 --> 00:32:00,799
i mean you might wonder why can't i just

871
00:31:58,640 --> 00:32:02,480
read it and leave it alone and not just

872
00:32:00,799 --> 00:32:04,000
have remove it

873
00:32:02,480 --> 00:32:06,080
you uh no

874
00:32:04,000 --> 00:32:07,919
you can get that effect by reading it

875
00:32:06,080 --> 00:32:09,360
and then uh which removes it and then

876
00:32:07,919 --> 00:32:10,559
putting it back if you really want it to

877
00:32:09,360 --> 00:32:12,720
stay there

878
00:32:10,559 --> 00:32:13,760
but the way we're setting it up

879
00:32:12,720 --> 00:32:15,840
is that

880
00:32:13,760 --> 00:32:18,480
reading comes with removing writing

881
00:32:15,840 --> 00:32:20,000
comes with adding

882
00:32:18,480 --> 00:32:21,200
okay and they're called pushing and

883
00:32:20,000 --> 00:32:23,120
popping

884
00:32:21,200 --> 00:32:25,360
okay so let's do an example

885
00:32:23,120 --> 00:32:27,440
um

886
00:32:25,360 --> 00:32:29,519
so we have here a push down automaton

887
00:32:27,440 --> 00:32:32,080
for a language we'll call d

888
00:32:29,519 --> 00:32:35,200
it's a we've seen that language before

889
00:32:32,080 --> 00:32:37,760
it's this uh it was um actually we use

890
00:32:35,200 --> 00:32:40,320
the same uh letter for it the strings of

891
00:32:37,760 --> 00:32:42,720
zeros followed by ones where the numbers

892
00:32:40,320 --> 00:32:44,080
are the same of the two so zero to the k

893
00:32:42,720 --> 00:32:45,440
one to the k

894
00:32:44,080 --> 00:32:47,600
we couldn't do that with a finite

895
00:32:45,440 --> 00:32:49,679
automaton we will be able to do that

896
00:32:47,600 --> 00:32:51,600
with a push down automaton

897
00:32:49,679 --> 00:32:52,960
um

898
00:32:51,600 --> 00:32:54,840
and here i

899
00:32:52,960 --> 00:32:58,000
uh

900
00:32:54,840 --> 00:33:01,360
um i thought i wrote down the input here

901
00:32:58,000 --> 00:33:03,039
but okay so the basic idea is i'm going

902
00:33:01,360 --> 00:33:05,279
to give you a

903
00:33:03,039 --> 00:33:07,360
uh an input

904
00:33:05,279 --> 00:33:08,720
now and the pushdown of the tombiton is

905
00:33:07,360 --> 00:33:10,880
supposed to test

906
00:33:08,720 --> 00:33:13,679
whether that input is in the language

907
00:33:10,880 --> 00:33:14,720
whether it's of this form

908
00:33:13,679 --> 00:33:16,480
um

909
00:33:14,720 --> 00:33:18,720
now it has

910
00:33:16,480 --> 00:33:19,919
the ability to use the stack

911
00:33:18,720 --> 00:33:21,600
because you know it's going to have to

912
00:33:19,919 --> 00:33:23,440
count how many zeros it has and so the

913
00:33:21,600 --> 00:33:25,519
way it's going to do it is you know i

914
00:33:23,440 --> 00:33:27,360
have a bunch of zeros hopefully and then

915
00:33:25,519 --> 00:33:30,000
a bunch of ones and you want to see that

916
00:33:27,360 --> 00:33:31,600
they're uh of the same number it's going

917
00:33:30,000 --> 00:33:32,799
to take the zeros and store them on the

918
00:33:31,600 --> 00:33:34,640
stack

919
00:33:32,799 --> 00:33:36,399
until it sees a one

920
00:33:34,640 --> 00:33:37,760
and then one's going to start to read

921
00:33:36,399 --> 00:33:40,080
the ones and it's going to remove the

922
00:33:37,760 --> 00:33:42,640
zeros matching them off one to one with

923
00:33:40,080 --> 00:33:43,679
the ones that it's seen

924
00:33:42,640 --> 00:33:46,480
okay

925
00:33:43,679 --> 00:33:48,799
so um you initially

926
00:33:46,480 --> 00:33:50,720
first read the zeros and push them onto

927
00:33:48,799 --> 00:33:53,840
the stack until you read a one and then

928
00:33:50,720 --> 00:33:55,840
you read the ones uh while popping zeros

929
00:33:53,840 --> 00:33:59,120
from the stack and you enter the accept

930
00:33:55,840 --> 00:33:59,120
state if the stack is empty

931
00:33:59,279 --> 00:34:03,840
just like with a finite automaton the

932
00:34:01,679 --> 00:34:05,600
except entering the accept state only

933
00:34:03,840 --> 00:34:07,840
counts when you're at the end of the

934
00:34:05,600 --> 00:34:07,840
input

935
00:34:09,119 --> 00:34:14,560
okay so um without me needing to say

936
00:34:12,560 --> 00:34:16,800
anything it's really saying you enter

937
00:34:14,560 --> 00:34:18,320
the accept state if the stack is empty

938
00:34:16,800 --> 00:34:20,399
at the end of the input string but

939
00:34:18,320 --> 00:34:22,480
that's kind of implicit because

940
00:34:20,399 --> 00:34:23,760
it only takes effect at the end of the

941
00:34:22,480 --> 00:34:25,359
input string if you enter an accept

942
00:34:23,760 --> 00:34:26,800
state alone in the middle somewhere it

943
00:34:25,359 --> 00:34:28,079
doesn't matter it doesn't affect

944
00:34:26,800 --> 00:34:30,079
anything

945
00:34:28,079 --> 00:34:32,000
um

946
00:34:30,079 --> 00:34:33,679
okay uh

947
00:34:32,000 --> 00:34:36,399
with that we're going to take a little

948
00:34:33,679 --> 00:34:39,119
break and then we'll be back uh shortly

949
00:34:36,399 --> 00:34:42,320
to look at push down automata again in a

950
00:34:39,119 --> 00:34:44,399
more uh with a more formal definition

951
00:34:42,320 --> 00:34:46,079
um let me put that's going to be five

952
00:34:44,399 --> 00:34:49,440
minutes so if i can figure out how to

953
00:34:46,079 --> 00:34:51,599
get my timer screen up here yes

954
00:34:49,440 --> 00:34:53,200
and we will

955
00:34:51,599 --> 00:34:54,960
uh

956
00:34:53,200 --> 00:34:57,119
the camera when the candle burns down to

957
00:34:54,960 --> 00:35:02,119
nothing

958
00:34:57,119 --> 00:35:02,119
we will return and continue

959
00:35:07,440 --> 00:35:10,960
okay

960
00:35:08,960 --> 00:35:13,359
our candle has

961
00:35:10,960 --> 00:35:14,720
burned down and has gone out i think i

962
00:35:13,359 --> 00:35:16,960
never actually watched to see what would

963
00:35:14,720 --> 00:35:20,880
happen at the end uh

964
00:35:16,960 --> 00:35:22,640
so um we're good to go let's continue

965
00:35:20,880 --> 00:35:24,320
um

966
00:35:22,640 --> 00:35:25,040
uh

967
00:35:24,320 --> 00:35:28,800
good

968
00:35:25,040 --> 00:35:28,800
and let me put myself back in there

969
00:35:29,040 --> 00:35:30,760
all righty

970
00:35:30,320 --> 00:35:32,240
um

971
00:35:30,760 --> 00:35:34,320
[Music]

972
00:35:32,240 --> 00:35:36,960
so we were doing push down automata and

973
00:35:34,320 --> 00:35:38,480
we just did that example of zero to the

974
00:35:36,960 --> 00:35:40,240
k1 to the k

975
00:35:38,480 --> 00:35:42,800
now that you have a stack

976
00:35:40,240 --> 00:35:44,960
we can do uh all sorts of

977
00:35:42,800 --> 00:35:45,920
fancy things that fina tamara could not

978
00:35:44,960 --> 00:35:47,760
do

979
00:35:45,920 --> 00:35:49,040
just with their limited

980
00:35:47,760 --> 00:35:50,640
memory

981
00:35:49,040 --> 00:35:52,400
okay so let's take a look at how we

982
00:35:50,640 --> 00:35:54,960
define

983
00:35:52,400 --> 00:35:55,700
push down automata

984
00:35:54,960 --> 00:35:57,599
um

985
00:35:55,700 --> 00:35:59,839
[Music]

986
00:35:57,599 --> 00:36:01,599
so now uh push down automata is actually

987
00:35:59,839 --> 00:36:03,680
going to be a six

988
00:36:01,599 --> 00:36:06,160
tuple so it's a little bit got some

989
00:36:03,680 --> 00:36:08,000
fancier stuff here to deal with not too

990
00:36:06,160 --> 00:36:09,440
much but a little bit

991
00:36:08,000 --> 00:36:13,200
um

992
00:36:09,440 --> 00:36:14,400
and uh so it has uh let's look at these

993
00:36:13,200 --> 00:36:16,400
a little bit more carefully since

994
00:36:14,400 --> 00:36:19,040
there's some novelty here

995
00:36:16,400 --> 00:36:20,640
we have the uh input alphabet just as we

996
00:36:19,040 --> 00:36:22,000
had before

997
00:36:20,640 --> 00:36:23,920
uh sigma

998
00:36:22,000 --> 00:36:26,960
but we also have gamma

999
00:36:23,920 --> 00:36:28,640
which is the alphabet for uh using the

1000
00:36:26,960 --> 00:36:30,079
stack

1001
00:36:28,640 --> 00:36:31,520
now um

1002
00:36:30,079 --> 00:36:33,359
you might ask why don't we just use the

1003
00:36:31,520 --> 00:36:35,119
same alphabet well it's really a matter

1004
00:36:33,359 --> 00:36:38,720
of convenience um

1005
00:36:35,119 --> 00:36:38,720
that we would like to be able to have

1006
00:36:39,119 --> 00:36:43,680
other symbols that uh could include the

1007
00:36:42,079 --> 00:36:45,680
input alphabet but could include other

1008
00:36:43,680 --> 00:36:47,119
things as well so it just gives you more

1009
00:36:45,680 --> 00:36:50,480
flexibility in terms of what you're

1010
00:36:47,119 --> 00:36:51,839
going to be writing on the stack

1011
00:36:50,480 --> 00:36:53,760
um

1012
00:36:51,839 --> 00:36:56,160
okay the transition function more

1013
00:36:53,760 --> 00:36:57,440
complicated uh so i think i don't know

1014
00:36:56,160 --> 00:36:58,640
if i'm going to even say what the other

1015
00:36:57,440 --> 00:37:00,240
things are but you know these are the

1016
00:36:58,640 --> 00:37:03,839
accepting states this is the starting

1017
00:37:00,240 --> 00:37:06,839
state so that's um the same as before

1018
00:37:03,839 --> 00:37:09,440
but the transition function is is a much

1019
00:37:06,839 --> 00:37:12,320
different animal here in a push-down

1020
00:37:09,440 --> 00:37:15,440
automaton so let's just try to uh unpack

1021
00:37:12,320 --> 00:37:18,000
that and understand what it's saying

1022
00:37:15,440 --> 00:37:19,920
the transition function tells us how the

1023
00:37:18,000 --> 00:37:21,760
machine operates how it goes from state

1024
00:37:19,920 --> 00:37:23,440
to state

1025
00:37:21,760 --> 00:37:25,599
how it's going to read the input how it

1026
00:37:23,440 --> 00:37:27,280
reads from the stack and what it might

1027
00:37:25,599 --> 00:37:28,880
write on the stack too because that's

1028
00:37:27,280 --> 00:37:31,280
going to all happen under program

1029
00:37:28,880 --> 00:37:31,280
control

1030
00:37:31,839 --> 00:37:36,720
so um what this means here

1031
00:37:35,119 --> 00:37:38,160
is that

1032
00:37:36,720 --> 00:37:41,119
you know when the machine is in a

1033
00:37:38,160 --> 00:37:41,119
particular state

1034
00:37:41,520 --> 00:37:44,800
um

1035
00:37:42,640 --> 00:37:46,880
reading a particular input symbol let's

1036
00:37:44,800 --> 00:37:49,040
ignore the empty string uh

1037
00:37:46,880 --> 00:37:50,640
subscript for the monument so it's in a

1038
00:37:49,040 --> 00:37:53,280
particular state

1039
00:37:50,640 --> 00:37:54,720
reading a particular input symbol and

1040
00:37:53,280 --> 00:37:57,280
with a certain

1041
00:37:54,720 --> 00:37:58,960
stack symbol appearing at the top of the

1042
00:37:57,280 --> 00:38:00,800
stack

1043
00:37:58,960 --> 00:38:04,400
so that's all information that's

1044
00:38:00,800 --> 00:38:06,800
available to the controller of this

1045
00:38:04,400 --> 00:38:09,599
pushdown automaton

1046
00:38:06,800 --> 00:38:11,280
the transition function

1047
00:38:09,599 --> 00:38:13,520
the current state

1048
00:38:11,280 --> 00:38:14,960
the next input symbol and the symbol at

1049
00:38:13,520 --> 00:38:17,119
the top of the stack

1050
00:38:14,960 --> 00:38:20,400
and once we have that

1051
00:38:17,119 --> 00:38:22,480
we know what new state we can go into

1052
00:38:20,400 --> 00:38:26,560
and what new symbol

1053
00:38:22,480 --> 00:38:26,560
we can write on the top of the stack

1054
00:38:26,800 --> 00:38:32,240
okay so that's what the uh

1055
00:38:29,040 --> 00:38:35,599
um right-hand side of this function

1056
00:38:32,240 --> 00:38:36,960
specification means so this is where uh

1057
00:38:35,599 --> 00:38:38,160
kind of the input to the function this

1058
00:38:36,960 --> 00:38:41,280
is going to be the output of the

1059
00:38:38,160 --> 00:38:43,280
function state entry and a new symbol to

1060
00:38:41,280 --> 00:38:44,800
appear on the stack so this is the

1061
00:38:43,280 --> 00:38:46,960
popping symbol this is the pushing

1062
00:38:44,800 --> 00:38:48,400
symbol

1063
00:38:46,960 --> 00:38:50,960
so now there are two things that bear

1064
00:38:48,400 --> 00:38:53,680
explanation here first of all now this

1065
00:38:50,960 --> 00:38:55,520
is this is a power set

1066
00:38:53,680 --> 00:38:56,960
so this is going to be representing as

1067
00:38:55,520 --> 00:39:00,400
we did before

1068
00:38:56,960 --> 00:39:02,960
um a non-deterministic machine

1069
00:39:00,400 --> 00:39:05,119
we may have several possibilities and

1070
00:39:02,960 --> 00:39:06,720
we're going to represent that as a set

1071
00:39:05,119 --> 00:39:09,119
of possibilities

1072
00:39:06,720 --> 00:39:11,680
for the machine that it could go to at

1073
00:39:09,119 --> 00:39:11,680
any point

1074
00:39:12,000 --> 00:39:16,480
i will give an example of how a push

1075
00:39:13,839 --> 00:39:18,560
down automaton uses its non-determinism

1076
00:39:16,480 --> 00:39:20,640
in a minute

1077
00:39:18,560 --> 00:39:23,280
the other thing is is these epsilons so

1078
00:39:20,640 --> 00:39:26,240
we have to understand why they are there

1079
00:39:23,280 --> 00:39:28,880
and we remember we had them for the nfas

1080
00:39:26,240 --> 00:39:31,359
corresponding to when the nfa had an

1081
00:39:28,880 --> 00:39:33,680
epsilon transition

1082
00:39:31,359 --> 00:39:35,760
an empty transition so it could go along

1083
00:39:33,680 --> 00:39:37,359
that transition without reading any

1084
00:39:35,760 --> 00:39:39,040
input

1085
00:39:37,359 --> 00:39:40,320
so this is going to play the same role

1086
00:39:39,040 --> 00:39:43,839
here

1087
00:39:40,320 --> 00:39:44,960
so if you have um instead of an input

1088
00:39:43,839 --> 00:39:48,960
symbol

1089
00:39:44,960 --> 00:39:50,400
from sigma appearing in this um uh

1090
00:39:48,960 --> 00:39:51,760
part of the

1091
00:39:50,400 --> 00:39:53,280
you know uh

1092
00:39:51,760 --> 00:39:54,800
for the for the transition function

1093
00:39:53,280 --> 00:39:57,280
instead you have an

1094
00:39:54,800 --> 00:40:00,240
you have an epsilon appearing

1095
00:39:57,280 --> 00:40:02,720
that means that the transition that that

1096
00:40:00,240 --> 00:40:05,920
move of the machine can happen without

1097
00:40:02,720 --> 00:40:05,920
reading any input symbol

1098
00:40:06,240 --> 00:40:09,800
just like for the nfa's

1099
00:40:10,079 --> 00:40:13,920
or if you have an epsilon appearing for

1100
00:40:12,000 --> 00:40:15,680
the stack symbol that means you can make

1101
00:40:13,920 --> 00:40:16,880
that transition without reading any

1102
00:40:15,680 --> 00:40:18,480
stack symbol

1103
00:40:16,880 --> 00:40:21,280
so any whatever's sitting on the top of

1104
00:40:18,480 --> 00:40:23,760
the stack it doesn't matter the machine

1105
00:40:21,280 --> 00:40:25,280
can make that move

1106
00:40:23,760 --> 00:40:26,480
and it won't read anything either we're

1107
00:40:25,280 --> 00:40:29,119
not going to pop anything it's just

1108
00:40:26,480 --> 00:40:31,040
going to uh be proceeding without

1109
00:40:29,119 --> 00:40:33,280
looking at the stack at all

1110
00:40:31,040 --> 00:40:34,560
or it might have both of them which case

1111
00:40:33,280 --> 00:40:36,319
it's going to go from one state to

1112
00:40:34,560 --> 00:40:39,040
another state without looking at the

1113
00:40:36,319 --> 00:40:40,560
input or at the top of the stack

1114
00:40:39,040 --> 00:40:43,680
so um

1115
00:40:40,560 --> 00:40:44,960
that's what the possibility of epsilon

1116
00:40:43,680 --> 00:40:47,040
means

1117
00:40:44,960 --> 00:40:48,880
for the um

1118
00:40:47,040 --> 00:40:50,240
for the transition function in the in

1119
00:40:48,880 --> 00:40:52,480
those places

1120
00:40:50,240 --> 00:40:53,920
the epsilon appearing over here means

1121
00:40:52,480 --> 00:40:56,640
something a little different but very

1122
00:40:53,920 --> 00:40:56,990
similar what that means is that

1123
00:40:56,640 --> 00:40:59,200
um

1124
00:40:56,990 --> 00:41:01,440
[Music]

1125
00:40:59,200 --> 00:41:03,839
we won't write anything on the top of

1126
00:41:01,440 --> 00:41:05,920
the stack that's going to be

1127
00:41:03,839 --> 00:41:07,680
we will go to a new state but without

1128
00:41:05,920 --> 00:41:09,599
doing any writing so we'll leave the

1129
00:41:07,680 --> 00:41:12,000
stack alone

1130
00:41:09,599 --> 00:41:13,040
um so here means we're not going to read

1131
00:41:12,000 --> 00:41:14,960
anything

1132
00:41:13,040 --> 00:41:16,319
if it's in this position in this

1133
00:41:14,960 --> 00:41:18,720
position means we're not going to write

1134
00:41:16,319 --> 00:41:18,720
anything

1135
00:41:18,800 --> 00:41:24,000
okay so all of those things are valid

1136
00:41:21,359 --> 00:41:27,119
and legal from the perspective of you

1137
00:41:24,000 --> 00:41:28,880
know constructing a push-down automaton

1138
00:41:27,119 --> 00:41:30,000
and i've kind of illustrated here you

1139
00:41:28,880 --> 00:41:33,280
know just with a little bit of an

1140
00:41:30,000 --> 00:41:35,839
example if you have delta that applies

1141
00:41:33,280 --> 00:41:38,960
to some state q

1142
00:41:35,839 --> 00:41:41,359
reading an input symbol a and popping a

1143
00:41:38,960 --> 00:41:43,200
c from the top of the stack

1144
00:41:41,359 --> 00:41:44,800
then you might have let's say in this

1145
00:41:43,200 --> 00:41:46,800
case two possibilities that you might

1146
00:41:44,800 --> 00:41:50,400
end up going to you might end up going

1147
00:41:46,800 --> 00:41:51,920
to states r1 or to states r2

1148
00:41:50,400 --> 00:41:54,720
and in the former case you'll end up

1149
00:41:51,920 --> 00:41:56,880
writing a d pushing a d onto this top of

1150
00:41:54,720 --> 00:41:58,560
the stack and in the latter case you

1151
00:41:56,880 --> 00:42:00,720
would be pushing an e onto the top of

1152
00:41:58,560 --> 00:42:03,680
the stack

1153
00:42:00,720 --> 00:42:06,960
okay so this is i'm trying to help you

1154
00:42:03,680 --> 00:42:09,839
look at this notation you can you know

1155
00:42:06,960 --> 00:42:13,040
you know i hope this is clear to you um

1156
00:42:09,839 --> 00:42:14,800
i'm sure for some of you it's too slow

1157
00:42:13,040 --> 00:42:16,640
but others of you i'm trying to help

1158
00:42:14,800 --> 00:42:18,640
along but if you're really struggling

1159
00:42:16,640 --> 00:42:19,920
with this notation at this point you

1160
00:42:18,640 --> 00:42:21,839
know you really have to going to have to

1161
00:42:19,920 --> 00:42:22,800
dig in and make sure you follow it

1162
00:42:21,839 --> 00:42:25,760
because it's only going to get harder

1163
00:42:22,800 --> 00:42:27,839
from there i'm going to stop being uh

1164
00:42:25,760 --> 00:42:29,440
going over these these kinds of points

1165
00:42:27,839 --> 00:42:31,119
and if you're still struggling you can't

1166
00:42:29,440 --> 00:42:33,599
get it this is not the right class for

1167
00:42:31,119 --> 00:42:35,599
you i'll just i'll be honest

1168
00:42:33,599 --> 00:42:37,359
um

1169
00:42:35,599 --> 00:42:39,680
because we're just gonna be

1170
00:42:37,359 --> 00:42:42,800
taking off like you know we're gonna

1171
00:42:39,680 --> 00:42:45,599
start to accelerate fairly quickly

1172
00:42:42,800 --> 00:42:49,359
okay so it's a non-deterministic machine

1173
00:42:45,599 --> 00:42:51,200
um we accept uh like we did before uh

1174
00:42:49,359 --> 00:42:52,800
there might be several different threads

1175
00:42:51,200 --> 00:42:54,960
of the computation you're going to end

1176
00:42:52,800 --> 00:42:56,880
up accepting um

1177
00:42:54,960 --> 00:42:58,640
if some of the threads

1178
00:42:56,880 --> 00:43:00,319
or what at least one of the threads end

1179
00:42:58,640 --> 00:43:03,040
up ends up in an accept state at the end

1180
00:43:00,319 --> 00:43:03,040
of the input string

1181
00:43:03,280 --> 00:43:06,720
okay

1182
00:43:04,079 --> 00:43:08,240
that's when we machine overall accepts

1183
00:43:06,720 --> 00:43:10,000
it's just the way we normally think of

1184
00:43:08,240 --> 00:43:11,839
non-determinism

1185
00:43:10,000 --> 00:43:13,760
again you can use the models that we had

1186
00:43:11,839 --> 00:43:15,920
before in terms of guessing or

1187
00:43:13,760 --> 00:43:17,280
parallelism whatever works for you and

1188
00:43:15,920 --> 00:43:19,440
sometimes different things work in

1189
00:43:17,280 --> 00:43:21,359
different different different occasions

1190
00:43:19,440 --> 00:43:24,560
uh but that's how non-determinism works

1191
00:43:21,359 --> 00:43:26,880
we'll do an example now okay here is a

1192
00:43:24,560 --> 00:43:28,640
push on automaton for a different

1193
00:43:26,880 --> 00:43:31,520
language we haven't seen before i don't

1194
00:43:28,640 --> 00:43:33,119
think well maybe we have um

1195
00:43:31,520 --> 00:43:34,960
which is

1196
00:43:33,119 --> 00:43:37,040
um going to be

1197
00:43:34,960 --> 00:43:39,760
using its non-determinism in an

1198
00:43:37,040 --> 00:43:41,520
essential way this is a

1199
00:43:39,760 --> 00:43:43,680
language that is going to where

1200
00:43:41,520 --> 00:43:44,640
non-determinism is going to be critical

1201
00:43:43,680 --> 00:43:46,720
um

1202
00:43:44,640 --> 00:43:48,720
without it you can't uh a deterministic

1203
00:43:46,720 --> 00:43:50,880
push on automaton which is something by

1204
00:43:48,720 --> 00:43:53,040
the way that people study um and there's

1205
00:43:50,880 --> 00:43:55,520
a section of my book about that section

1206
00:43:53,040 --> 00:43:57,280
2.4 because it has relevance to

1207
00:43:55,520 --> 00:43:58,960
applications we're not going to address

1208
00:43:57,280 --> 00:44:01,359
that in this course so you can just skip

1209
00:43:58,960 --> 00:44:03,920
section 2.4 it's pretty technical uh

1210
00:44:01,359 --> 00:44:05,119
i'll have to say um but still

1211
00:44:03,920 --> 00:44:06,839
quite interesting and beautiful if

1212
00:44:05,119 --> 00:44:09,280
you're if you like that stuff but it's

1213
00:44:06,839 --> 00:44:10,400
technical we won't do it

1214
00:44:09,280 --> 00:44:14,800
um

1215
00:44:10,400 --> 00:44:17,040
so here is um this input string

1216
00:44:14,800 --> 00:44:20,000
w w reverse

1217
00:44:17,040 --> 00:44:22,400
for all possible w's over our alphabet

1218
00:44:20,000 --> 00:44:24,480
zero one and what w reverse by the way

1219
00:44:22,400 --> 00:44:27,599
means is writing w backwards

1220
00:44:24,480 --> 00:44:30,640
uh so this is all strings followed by

1221
00:44:27,599 --> 00:44:33,839
a reversal of the same string

1222
00:44:30,640 --> 00:44:37,520
okay the string written backwards um

1223
00:44:33,839 --> 00:44:40,000
really you can think of these as uh um

1224
00:44:37,520 --> 00:44:43,280
you know so these are strings that um

1225
00:44:40,000 --> 00:44:45,680
well here's an example like 0 1 1

1226
00:44:43,280 --> 00:44:47,520
1 1 0 the string written backwards so

1227
00:44:45,680 --> 00:44:51,200
this is a string in the language

1228
00:44:47,520 --> 00:44:54,319
appearing on a tape as i as i described

1229
00:44:51,200 --> 00:44:55,839
okay so how is the machine going to um

1230
00:44:54,319 --> 00:44:57,119
recognize this language it's kind of

1231
00:44:55,839 --> 00:45:01,119
pretty similar somewhat similar to

1232
00:44:57,119 --> 00:45:01,119
before but with one important difference

1233
00:45:01,200 --> 00:45:06,280
um and if you imagine i think again i

1234
00:45:04,000 --> 00:45:08,480
like to use this kind of and

1235
00:45:06,280 --> 00:45:10,480
anthropomorphizing these things putting

1236
00:45:08,480 --> 00:45:12,560
yourself in the place of the machine

1237
00:45:10,480 --> 00:45:13,760
and thinking how you would do it

1238
00:45:12,560 --> 00:45:15,839
um

1239
00:45:13,760 --> 00:45:18,000
so if you imagine getting these symbols

1240
00:45:15,839 --> 00:45:19,359
one by one zero one one you don't know

1241
00:45:18,000 --> 00:45:20,960
what's coming next as you're getting the

1242
00:45:19,359 --> 00:45:23,119
symbols

1243
00:45:20,960 --> 00:45:24,960
you have to figure out how to match off

1244
00:45:23,119 --> 00:45:26,960
the second half with the first half so

1245
00:45:24,960 --> 00:45:28,160
you're gonna put the first half on the

1246
00:45:26,960 --> 00:45:30,160
stack

1247
00:45:28,160 --> 00:45:31,839
and then

1248
00:45:30,160 --> 00:45:34,160
you're gonna remove the first half and

1249
00:45:31,839 --> 00:45:35,839
match it off with the with the

1250
00:45:34,160 --> 00:45:38,319
with the second half

1251
00:45:35,839 --> 00:45:40,800
con conveniently the first half comes

1252
00:45:38,319 --> 00:45:44,560
out backwards the stack is a first in

1253
00:45:40,800 --> 00:45:46,560
last out kind of thing so um

1254
00:45:44,560 --> 00:45:48,319
it comes out in reverse order so that's

1255
00:45:46,560 --> 00:45:50,640
perfect for matching off with the second

1256
00:45:48,319 --> 00:45:52,880
half

1257
00:45:50,640 --> 00:45:54,640
uh but the tricky part

1258
00:45:52,880 --> 00:45:56,800
with this language

1259
00:45:54,640 --> 00:45:58,560
is how do you know when you're at the

1260
00:45:56,800 --> 00:46:00,400
when you're at the middle because you

1261
00:45:58,560 --> 00:46:02,319
don't get to see

1262
00:46:00,400 --> 00:46:03,839
um the rest

1263
00:46:02,319 --> 00:46:06,160
you only get to see what you've seen so

1264
00:46:03,839 --> 00:46:08,720
far you don't know what's coming

1265
00:46:06,160 --> 00:46:10,079
so you know

1266
00:46:08,720 --> 00:46:12,560
uh

1267
00:46:10,079 --> 00:46:14,720
when you read that second one at this

1268
00:46:12,560 --> 00:46:17,359
point you read zero one one now you're

1269
00:46:14,720 --> 00:46:18,720
reading that second one you don't know

1270
00:46:17,359 --> 00:46:20,400
that perhaps there's just going to be a

1271
00:46:18,720 --> 00:46:21,599
zero following that and it's going to be

1272
00:46:20,400 --> 00:46:24,480
all

1273
00:46:21,599 --> 00:46:28,079
so maybe you should be deciding to that

1274
00:46:24,480 --> 00:46:30,560
this point here that i've marked um uh

1275
00:46:28,079 --> 00:46:33,599
is the

1276
00:46:30,560 --> 00:46:35,599
midpoint and you you

1277
00:46:33,599 --> 00:46:37,760
put zero one on the tape and then start

1278
00:46:35,599 --> 00:46:39,440
popping the second the

1279
00:46:37,760 --> 00:46:41,920
the second one and matching it off with

1280
00:46:39,440 --> 00:46:43,760
the first one um that might that would

1281
00:46:41,920 --> 00:46:45,040
be a tempting thing to do but you just

1282
00:46:43,760 --> 00:46:47,599
don't know

1283
00:46:45,040 --> 00:46:49,200
um and that's where the non-determinism

1284
00:46:47,599 --> 00:46:50,640
is going to be essential so let me let

1285
00:46:49,200 --> 00:46:51,839
me write down more of this so what

1286
00:46:50,640 --> 00:46:54,000
you're going to do is you're going to

1287
00:46:51,839 --> 00:46:55,599
read and push input symbols but not

1288
00:46:54,000 --> 00:46:57,200
deterministically guessing that you're

1289
00:46:55,599 --> 00:46:59,200
at the middle so you're going to now

1290
00:46:57,200 --> 00:47:01,680
deterministically either repeat that and

1291
00:46:59,200 --> 00:47:03,839
continue to read and push symbols onto

1292
00:47:01,680 --> 00:47:05,839
the stack or you're going to go to two

1293
00:47:03,839 --> 00:47:08,880
deciding that

1294
00:47:05,839 --> 00:47:11,200
or guessing that you're at the midpoint

1295
00:47:08,880 --> 00:47:13,760
and now it's time to start reading and

1296
00:47:11,200 --> 00:47:15,119
popping instead of reading and pushing

1297
00:47:13,760 --> 00:47:16,880
so you're going to read input symbols

1298
00:47:15,119 --> 00:47:19,359
and popping that popping the stack

1299
00:47:16,880 --> 00:47:21,440
symbols comparing the

1300
00:47:19,359 --> 00:47:22,960
the two the the symbols that you're

1301
00:47:21,440 --> 00:47:24,559
reading with the top the symbols you're

1302
00:47:22,960 --> 00:47:26,319
removing from the stack

1303
00:47:24,559 --> 00:47:28,160
if they ever disagree

1304
00:47:26,319 --> 00:47:29,520
then this thread of the non-determinism

1305
00:47:28,160 --> 00:47:30,880
rejects

1306
00:47:29,520 --> 00:47:32,800
because

1307
00:47:30,880 --> 00:47:35,119
either the input is not in the language

1308
00:47:32,800 --> 00:47:38,400
or at least you've made a wrong choice

1309
00:47:35,119 --> 00:47:40,160
as to where the midpoint is

1310
00:47:38,400 --> 00:47:41,200
um

1311
00:47:40,160 --> 00:47:44,640
and then you're going to enter the

1312
00:47:41,200 --> 00:47:46,480
accept state if the stack is empty

1313
00:47:44,640 --> 00:47:48,960
and ignore this part for the moment of

1314
00:47:46,480 --> 00:47:51,200
this software reference uh

1315
00:47:48,960 --> 00:47:54,000
let's just um i'll speak to that in a

1316
00:47:51,200 --> 00:47:56,079
second but um i just want to make sure

1317
00:47:54,000 --> 00:47:58,160
we understand that at an intuitive level

1318
00:47:56,079 --> 00:48:00,400
how this machine is using its

1319
00:47:58,160 --> 00:48:01,680
non-determinism

1320
00:48:00,400 --> 00:48:04,079
to

1321
00:48:01,680 --> 00:48:05,599
uh recognize this language because the

1322
00:48:04,079 --> 00:48:08,240
non-determinism is critical and it's

1323
00:48:05,599 --> 00:48:09,920
important that you understand it um

1324
00:48:08,240 --> 00:48:10,960
so let me just make some side comments

1325
00:48:09,920 --> 00:48:14,480
and then we'll come back to this

1326
00:48:10,960 --> 00:48:18,559
software remark so first of all

1327
00:48:14,480 --> 00:48:18,559
one question that comes up a lot

1328
00:48:19,599 --> 00:48:23,280
well um not paying attention to the chat

1329
00:48:21,680 --> 00:48:26,240
here sorry so if you're not getting

1330
00:48:23,280 --> 00:48:28,319
answer from me try the tas but um one of

1331
00:48:26,240 --> 00:48:29,599
the

1332
00:48:28,319 --> 00:48:31,839
uh

1333
00:48:29,599 --> 00:48:32,800
one of the um questions that comes up a

1334
00:48:31,839 --> 00:48:35,440
lot when they're thinking about

1335
00:48:32,800 --> 00:48:38,319
non-determinism for push down automata

1336
00:48:35,440 --> 00:48:41,520
is what happens to the stack

1337
00:48:38,319 --> 00:48:43,520
the stack gets replicated

1338
00:48:41,520 --> 00:48:46,000
in the non-determinism every time the

1339
00:48:43,520 --> 00:48:48,400
machine forks just like everything else

1340
00:48:46,000 --> 00:48:50,400
gets replicated so an entire every time

1341
00:48:48,400 --> 00:48:53,119
there's a fork in the non-determinism

1342
00:48:50,400 --> 00:48:55,839
and the machine branches into multiple

1343
00:48:53,119 --> 00:48:58,079
possibilities the entire machine

1344
00:48:55,839 --> 00:49:00,880
replicates the current state the current

1345
00:48:58,079 --> 00:49:03,200
position of the head the what's the

1346
00:49:00,880 --> 00:49:06,079
stack and its contents all of that gets

1347
00:49:03,200 --> 00:49:07,359
replicated um and the two

1348
00:49:06,079 --> 00:49:09,760
um

1349
00:49:07,359 --> 00:49:12,240
sides of the the two branches or the two

1350
00:49:09,760 --> 00:49:15,200
sides of the fork each go on

1351
00:49:12,240 --> 00:49:16,960
independently in their merry way

1352
00:49:15,200 --> 00:49:18,640
okay doing their own thing independently

1353
00:49:16,960 --> 00:49:20,240
and then if any one of them accepts

1354
00:49:18,640 --> 00:49:21,760
that's the only way there's sort of a

1355
00:49:20,240 --> 00:49:24,880
kind of a communication because the one

1356
00:49:21,760 --> 00:49:27,520
that accepts raises the flag and then uh

1357
00:49:24,880 --> 00:49:29,760
the overall machine is set to accept

1358
00:49:27,520 --> 00:49:32,000
okay so the non-deterministic forks

1359
00:49:29,760 --> 00:49:33,680
replicate the stack of saying it uh just

1360
00:49:32,000 --> 00:49:35,760
want to make sure you've got that

1361
00:49:33,680 --> 00:49:38,319
um and then this language requires

1362
00:49:35,760 --> 00:49:40,960
non-determinism that that i said earlier

1363
00:49:38,319 --> 00:49:42,640
um so our pda push down time model is

1364
00:49:40,960 --> 00:49:43,680
going to be non-deterministic i mean you

1365
00:49:42,640 --> 00:49:45,440
might have examples which are

1366
00:49:43,680 --> 00:49:48,000
deterministic but the model is going to

1367
00:49:45,440 --> 00:49:50,400
always allow non-determinism okay what's

1368
00:49:48,000 --> 00:49:52,400
this bit about the software

1369
00:49:50,400 --> 00:49:55,599
so if you look at this formal definition

1370
00:49:52,400 --> 00:49:58,800
here it doesn't have anywhere in it the

1371
00:49:55,599 --> 00:50:00,400
ability to test if the stack is empty

1372
00:49:58,800 --> 00:50:02,480
that's not part of the hardware

1373
00:50:00,400 --> 00:50:04,400
specification at least as we are

1374
00:50:02,480 --> 00:50:06,559
describing it for a push-down automaton

1375
00:50:04,400 --> 00:50:08,319
you can might imagine someone somebody

1376
00:50:06,559 --> 00:50:09,440
else describes push on the tama in some

1377
00:50:08,319 --> 00:50:11,280
other way which gives that as a

1378
00:50:09,440 --> 00:50:13,200
primitive but we're not going to do that

1379
00:50:11,280 --> 00:50:16,559
why because we don't need a primitive

1380
00:50:13,200 --> 00:50:19,520
for that you can get the effect

1381
00:50:16,559 --> 00:50:21,119
of testing if there's an empty stack

1382
00:50:19,520 --> 00:50:23,280
even if you don't have that as a

1383
00:50:21,119 --> 00:50:24,800
primitive for the machine

1384
00:50:23,280 --> 00:50:27,119
because

1385
00:50:24,800 --> 00:50:29,040
uh what you could do is you can start

1386
00:50:27,119 --> 00:50:30,880
the machine off when it very at the very

1387
00:50:29,040 --> 00:50:34,480
first thing it does is it writes a

1388
00:50:30,880 --> 00:50:35,680
special symbol to mark um the bottom you

1389
00:50:34,480 --> 00:50:36,880
know what's going to eventually be the

1390
00:50:35,680 --> 00:50:38,640
bottom of the stack there's going to be

1391
00:50:36,880 --> 00:50:39,839
some special symbol maybe a dollar sign

1392
00:50:38,640 --> 00:50:40,960
symbol

1393
00:50:39,839 --> 00:50:42,480
that's the very first thing that the

1394
00:50:40,960 --> 00:50:44,960
machine does and then it proceeds as

1395
00:50:42,480 --> 00:50:47,119
before if ever sees that dollar sign

1396
00:50:44,960 --> 00:50:50,079
symbol again it knows the stack is

1397
00:50:47,119 --> 00:50:50,079
effectively empty

1398
00:50:50,240 --> 00:50:54,880
okay so you can get the effect of

1399
00:50:52,400 --> 00:50:56,160
testing for the stack being empty even

1400
00:50:54,880 --> 00:50:57,839
if you don't have a primitive for that

1401
00:50:56,160 --> 00:51:01,599
and we're not going to actually fuss

1402
00:50:57,839 --> 00:51:02,800
about some details like that um so you

1403
00:51:01,599 --> 00:51:05,119
can use when you're writing your

1404
00:51:02,800 --> 00:51:06,960
homework sets you can just use the

1405
00:51:05,119 --> 00:51:08,319
assumption that you can test for empty

1406
00:51:06,960 --> 00:51:10,079
stack which is what i'm going to do

1407
00:51:08,319 --> 00:51:11,760
myself

1408
00:51:10,079 --> 00:51:13,440
okay

1409
00:51:11,760 --> 00:51:17,599
um

1410
00:51:13,440 --> 00:51:19,119
so uh let's continue on um

1411
00:51:17,599 --> 00:51:21,200
all right so

1412
00:51:19,119 --> 00:51:22,880
yeah so now what we're going to do we're

1413
00:51:21,200 --> 00:51:24,319
going to prove our one

1414
00:51:22,880 --> 00:51:26,319
so far we really haven't proved anything

1415
00:51:24,319 --> 00:51:28,640
we've just given some definitions and

1416
00:51:26,319 --> 00:51:30,800
some examples today was going to now

1417
00:51:28,640 --> 00:51:33,440
we're going to come to our big theorem

1418
00:51:30,800 --> 00:51:36,640
which actually is um important and has

1419
00:51:33,440 --> 00:51:38,800
some meat to it um and that is

1420
00:51:36,640 --> 00:51:40,720
how do we convert you know i claim that

1421
00:51:38,800 --> 00:51:42,800
to put context-free grammars and push

1422
00:51:40,720 --> 00:51:44,240
down automata are equivalent

1423
00:51:42,800 --> 00:51:46,319
well we're going to prove that

1424
00:51:44,240 --> 00:51:49,200
equivalence in one direction converting

1425
00:51:46,319 --> 00:51:51,839
the grammars to push down automata

1426
00:51:49,200 --> 00:51:51,839
okay so

1427
00:51:52,240 --> 00:51:55,200
um let me show you how that goes in some

1428
00:51:54,079 --> 00:51:56,400
ways

1429
00:51:55,200 --> 00:51:59,040
um

1430
00:51:56,400 --> 00:52:00,960
it's a nice proof not super complicated

1431
00:51:59,040 --> 00:52:02,079
but it has some meat to it

1432
00:52:00,960 --> 00:52:04,400
uh

1433
00:52:02,079 --> 00:52:06,400
so if i give you a grammar here

1434
00:52:04,400 --> 00:52:08,079
what i'm going to tell you how to do is

1435
00:52:06,400 --> 00:52:12,319
convert that grammar into push down

1436
00:52:08,079 --> 00:52:13,440
automaton which does the same language

1437
00:52:12,319 --> 00:52:14,640
okay so

1438
00:52:13,440 --> 00:52:16,079
if you're

1439
00:52:14,640 --> 00:52:18,079
checked out for a minute please come

1440
00:52:16,079 --> 00:52:20,000
back because we're sort of starting this

1441
00:52:18,079 --> 00:52:20,720
topic now that you can think a bit about

1442
00:52:20,000 --> 00:52:23,280
this

1443
00:52:20,720 --> 00:52:25,839
good good uh re-entry point if you're

1444
00:52:23,280 --> 00:52:29,040
sort of uh been doing something else

1445
00:52:25,839 --> 00:52:31,920
which i can't tell good thing uh

1446
00:52:29,040 --> 00:52:34,480
so all right so converting a given

1447
00:52:31,920 --> 00:52:35,920
grammar to a push down automaton how is

1448
00:52:34,480 --> 00:52:37,920
that going to work

1449
00:52:35,920 --> 00:52:40,240
so the idea is

1450
00:52:37,920 --> 00:52:41,520
okay

1451
00:52:40,240 --> 00:52:44,720
actually before i tell you the idea

1452
00:52:41,520 --> 00:52:44,720
let's just think about it together

1453
00:52:44,960 --> 00:52:48,240
again i like to think about the push

1454
00:52:46,640 --> 00:52:51,040
down automaton building a push on

1455
00:52:48,240 --> 00:52:52,079
automaton the way you would do it

1456
00:52:51,040 --> 00:52:54,800
so

1457
00:52:52,079 --> 00:52:57,599
a grammar is a generation device it

1458
00:52:54,800 --> 00:52:59,680
generates strings a push down automaton

1459
00:52:57,599 --> 00:53:02,079
or thinking about it as you you're a

1460
00:52:59,680 --> 00:53:03,760
recognizer you're given an input and you

1461
00:53:02,079 --> 00:53:07,119
want to know is it in the language so

1462
00:53:03,760 --> 00:53:08,960
you want to know is it possible for that

1463
00:53:07,119 --> 00:53:10,000
grammar to generate that input you're

1464
00:53:08,960 --> 00:53:11,040
given

1465
00:53:10,000 --> 00:53:14,960
so how are you going how are you going

1466
00:53:11,040 --> 00:53:17,119
to how are you going to do that um and

1467
00:53:14,960 --> 00:53:19,599
uh

1468
00:53:17,119 --> 00:53:21,359
are you going how are you going to um

1469
00:53:19,599 --> 00:53:25,359
test if the

1470
00:53:21,359 --> 00:53:26,720
input is in the language of the grammar

1471
00:53:25,359 --> 00:53:28,880
well the thing that you would naturally

1472
00:53:26,720 --> 00:53:31,040
do is you say well can i derive that

1473
00:53:28,880 --> 00:53:33,359
string using the rules of the grammar

1474
00:53:31,040 --> 00:53:36,160
let me start with the start string

1475
00:53:33,359 --> 00:53:38,160
and try to do substitutions

1476
00:53:36,160 --> 00:53:39,359
and see if i get the string

1477
00:53:38,160 --> 00:53:41,280
i'm given

1478
00:53:39,359 --> 00:53:43,119
and if i can get it then i know it's in

1479
00:53:41,280 --> 00:53:44,720
the language

1480
00:53:43,119 --> 00:53:46,640
right that's a natural thing to do

1481
00:53:44,720 --> 00:53:48,160
you're just going to try try to do so

1482
00:53:46,640 --> 00:53:50,160
you know try to do the substitutions

1483
00:53:48,160 --> 00:53:51,760
even get to the string now the thing is

1484
00:53:50,160 --> 00:53:53,280
there are many there might be many

1485
00:53:51,760 --> 00:53:54,079
different substitutions that you could

1486
00:53:53,280 --> 00:53:55,839
make

1487
00:53:54,079 --> 00:53:57,680
and you know that seems like a really

1488
00:53:55,839 --> 00:53:59,200
challenging uh hard thing to figure out

1489
00:53:57,680 --> 00:54:00,880
which substitutions to use among the

1490
00:53:59,200 --> 00:54:03,359
many possibilities that's where

1491
00:54:00,880 --> 00:54:05,040
non-determinism is going to come in

1492
00:54:03,359 --> 00:54:06,720
because you can think of yourself as

1493
00:54:05,040 --> 00:54:07,760
guessing which substitutions to make and

1494
00:54:06,720 --> 00:54:09,040
you're always going to make the right

1495
00:54:07,760 --> 00:54:11,520
guess

1496
00:54:09,040 --> 00:54:13,520
so the choices of which substitutions to

1497
00:54:11,520 --> 00:54:14,480
make that's not going to be a

1498
00:54:13,520 --> 00:54:16,400
problem for you that's going to be

1499
00:54:14,480 --> 00:54:17,839
managed by the non-determinist so

1500
00:54:16,400 --> 00:54:20,400
imagine you're always going to make the

1501
00:54:17,839 --> 00:54:22,880
right substitution but now the challenge

1502
00:54:20,400 --> 00:54:24,800
is how do you keep track

1503
00:54:22,880 --> 00:54:28,079
of the intermediate results as you're

1504
00:54:24,800 --> 00:54:28,079
doing those substitutions

1505
00:54:28,240 --> 00:54:31,520
um

1506
00:54:30,240 --> 00:54:33,359
and

1507
00:54:31,520 --> 00:54:35,520
that's where the stack is going to come

1508
00:54:33,359 --> 00:54:39,359
in the machine is going to write down

1509
00:54:35,520 --> 00:54:42,319
those intermediate results on the stack

1510
00:54:39,359 --> 00:54:44,480
but even there there's a subtlety that's

1511
00:54:42,319 --> 00:54:46,480
an important subtlety that you have to

1512
00:54:44,480 --> 00:54:48,480
look at so let's try

1513
00:54:46,480 --> 00:54:50,160
pulling that together so far before i

1514
00:54:48,480 --> 00:54:52,480
get to that subtlety

1515
00:54:50,160 --> 00:54:54,799
uh okay so as i mentioned

1516
00:54:52,480 --> 00:54:54,799
um

1517
00:54:54,960 --> 00:54:57,920
uh

1518
00:54:55,760 --> 00:54:59,440
the push down automaton is is going to

1519
00:54:57,920 --> 00:55:00,559
start out with the starting variable and

1520
00:54:59,440 --> 00:55:02,640
is going to guess to be guessing the

1521
00:55:00,559 --> 00:55:05,599
substitutions to make it's going to keep

1522
00:55:02,640 --> 00:55:06,880
the intermediate results on the stack

1523
00:55:05,599 --> 00:55:08,880
when it's done doing all the

1524
00:55:06,880 --> 00:55:10,960
substitutions and it has only terminal

1525
00:55:08,880 --> 00:55:12,240
strings on the stack it can compare with

1526
00:55:10,960 --> 00:55:13,200
the input and see if it got the right

1527
00:55:12,240 --> 00:55:15,040
thing

1528
00:55:13,200 --> 00:55:17,520
so if it made it all the right guesses

1529
00:55:15,040 --> 00:55:19,200
so you think of it as guessing doing the

1530
00:55:17,520 --> 00:55:20,799
right guesses but in the end you have to

1531
00:55:19,200 --> 00:55:22,240
check to make sure that you've got the

1532
00:55:20,799 --> 00:55:25,119
right the you that you did all the right

1533
00:55:22,240 --> 00:55:26,960
thing and you accept when when things um

1534
00:55:25,119 --> 00:55:28,720
have matched up you know you and you

1535
00:55:26,960 --> 00:55:30,079
made all the right guesses so you have

1536
00:55:28,720 --> 00:55:31,280
to in the end you have to check that you

1537
00:55:30,079 --> 00:55:33,359
actually got

1538
00:55:31,280 --> 00:55:36,640
that input uh

1539
00:55:33,359 --> 00:55:36,640
from doing those substitutions

1540
00:55:36,799 --> 00:55:40,240
okay so let's let's let's try to see

1541
00:55:39,359 --> 00:55:42,960
this

1542
00:55:40,240 --> 00:55:45,920
operating in action and then you'll see

1543
00:55:42,960 --> 00:55:47,359
the subtlety the the delicacy the the

1544
00:55:45,920 --> 00:55:49,839
the the

1545
00:55:47,359 --> 00:55:51,680
the a problem that's going to arise

1546
00:55:49,839 --> 00:55:53,760
hopefully you're following at least in

1547
00:55:51,680 --> 00:55:56,480
part what i'm just saying so far

1548
00:55:53,760 --> 00:55:58,400
okay so here is the input

1549
00:55:56,480 --> 00:55:59,760
we do know that that's an input in the

1550
00:55:58,400 --> 00:56:01,920
language of the we we've been seeing

1551
00:55:59,760 --> 00:56:03,920
this example multiple times so here's

1552
00:56:01,920 --> 00:56:06,480
the input appearing on the input tape a

1553
00:56:03,920 --> 00:56:08,880
plus a times a

1554
00:56:06,480 --> 00:56:11,119
now the push on automaton is supposed to

1555
00:56:08,880 --> 00:56:14,079
be accepting that input because it's in

1556
00:56:11,119 --> 00:56:14,079
the language of the ground

1557
00:56:14,319 --> 00:56:18,000
okay so it's going to operate by first

1558
00:56:16,559 --> 00:56:21,119
writing

1559
00:56:18,000 --> 00:56:22,559
to start off the starting variable on

1560
00:56:21,119 --> 00:56:24,079
the stack

1561
00:56:22,559 --> 00:56:25,440
and then doing the substitutions as

1562
00:56:24,079 --> 00:56:28,720
we're going along

1563
00:56:25,440 --> 00:56:31,280
okay so um

1564
00:56:28,720 --> 00:56:32,880
we're going to substitute we we we uh e

1565
00:56:31,280 --> 00:56:35,200
goes to e plus t

1566
00:56:32,880 --> 00:56:37,520
so we do that first substitution

1567
00:56:35,200 --> 00:56:40,319
um and then

1568
00:56:37,520 --> 00:56:42,319
we do the next substitution here the e

1569
00:56:40,319 --> 00:56:44,720
so i'm i'm if you're looking at this

1570
00:56:42,319 --> 00:56:47,200
tree here that means this is the right

1571
00:56:44,720 --> 00:56:50,079
tree for that uh

1572
00:56:47,200 --> 00:56:50,960
for that input so we we substitute e by

1573
00:56:50,079 --> 00:56:53,760
t

1574
00:56:50,960 --> 00:56:55,599
uh so far so good the automaton can do

1575
00:56:53,760 --> 00:56:57,680
to make that substitution

1576
00:56:55,599 --> 00:57:01,040
then the next substitution is going to

1577
00:56:57,680 --> 00:57:03,280
be a little uh so we're where e plus t

1578
00:57:01,040 --> 00:57:05,599
we did we substitute here we got t plus

1579
00:57:03,280 --> 00:57:08,720
t and now we're going to substitute the

1580
00:57:05,599 --> 00:57:11,359
t times f which is this t over here we

1581
00:57:08,720 --> 00:57:15,040
want to substitute that and that appears

1582
00:57:11,359 --> 00:57:15,040
as t times f now on the stack

1583
00:57:15,200 --> 00:57:20,799
now if you're following me you should be

1584
00:57:17,680 --> 00:57:22,000
suddenly getting nervous

1585
00:57:20,799 --> 00:57:24,960
because

1586
00:57:22,000 --> 00:57:24,960
we just cheated

1587
00:57:25,119 --> 00:57:29,280
it's okay

1588
00:57:27,280 --> 00:57:30,880
um doing substitution doing these

1589
00:57:29,280 --> 00:57:33,440
replacements at the very top of the

1590
00:57:30,880 --> 00:57:36,000
stack because the push down automaton

1591
00:57:33,440 --> 00:57:37,359
has access to the top that's how stacks

1592
00:57:36,000 --> 00:57:39,680
work

1593
00:57:37,359 --> 00:57:41,119
but it does not have access deep down

1594
00:57:39,680 --> 00:57:42,960
within the stack

1595
00:57:41,119 --> 00:57:44,960
that is

1596
00:57:42,960 --> 00:57:47,520
uh not house style that is not how

1597
00:57:44,960 --> 00:57:48,640
stacks work so that's cheating

1598
00:57:47,520 --> 00:57:50,559
but

1599
00:57:48,640 --> 00:57:54,160
ignoring the cheating for the minute if

1600
00:57:50,559 --> 00:57:56,160
you could replace those um

1601
00:57:54,160 --> 00:57:58,240
do those substitutions deep down within

1602
00:57:56,160 --> 00:58:00,480
the stack this would all work we would

1603
00:57:58,240 --> 00:58:03,200
be good you would do the substitutions

1604
00:58:00,480 --> 00:58:06,240
uh one after another until you ended up

1605
00:58:03,200 --> 00:58:07,760
with no uh variables and then you have

1606
00:58:06,240 --> 00:58:09,200
the string here and you're going to

1607
00:58:07,760 --> 00:58:10,960
match it off and compare it with the

1608
00:58:09,200 --> 00:58:13,280
input it's all done in the right way so

1609
00:58:10,960 --> 00:58:14,160
that the things are in the right order

1610
00:58:13,280 --> 00:58:15,440
so the

1611
00:58:14,160 --> 00:58:17,280
you know the

1612
00:58:15,440 --> 00:58:19,200
after all the substitutions you'd have a

1613
00:58:17,280 --> 00:58:20,400
plus a times a sitting here on the stack

1614
00:58:19,200 --> 00:58:22,079
you match you compare that with the

1615
00:58:20,400 --> 00:58:23,359
input it's going to match up and you'll

1616
00:58:22,079 --> 00:58:25,280
end up accepting

1617
00:58:23,359 --> 00:58:28,079
all good so how do we deal with that

1618
00:58:25,280 --> 00:58:30,720
problem here problem access below the

1619
00:58:28,079 --> 00:58:33,280
stack of step top of stack is cheating

1620
00:58:30,720 --> 00:58:35,599
what are we going to do instead

1621
00:58:33,280 --> 00:58:37,119
so the idea is actually pretty simple

1622
00:58:35,599 --> 00:58:39,440
well if you've understood what i've said

1623
00:58:37,119 --> 00:58:42,319
so far the you know fixing that is

1624
00:58:39,440 --> 00:58:43,599
actually not too bad um

1625
00:58:42,319 --> 00:58:44,799
uh

1626
00:58:43,599 --> 00:58:46,640
uh

1627
00:58:44,799 --> 00:58:47,920
sort of fading out here

1628
00:58:46,640 --> 00:58:49,520
uh

1629
00:58:47,920 --> 00:58:50,720
put some more light on the

1630
00:58:49,520 --> 00:58:52,000
on my image

1631
00:58:50,720 --> 00:58:52,880
um

1632
00:58:52,000 --> 00:58:55,200
so

1633
00:58:52,880 --> 00:58:57,440
how do we do that uh

1634
00:58:55,200 --> 00:58:59,839
how do we get the effect of the access

1635
00:58:57,440 --> 00:59:03,040
below the top of the stack

1636
00:58:59,839 --> 00:59:05,680
and the way we're going to do that is um

1637
00:59:03,040 --> 00:59:07,440
by making the obs what we're going to do

1638
00:59:05,680 --> 00:59:08,960
we're only going to do substitutions

1639
00:59:07,440 --> 00:59:10,480
that we can make at the top of the stack

1640
00:59:08,960 --> 00:59:11,920
so whenever there's a variable at the

1641
00:59:10,480 --> 00:59:14,480
top of the stack we're going to do the

1642
00:59:11,920 --> 00:59:15,920
substitution because we the top we can

1643
00:59:14,480 --> 00:59:17,599
access

1644
00:59:15,920 --> 00:59:19,839
now what happens if we have a terminal

1645
00:59:17,599 --> 00:59:22,240
symbol sitting at the top blocking our

1646
00:59:19,839 --> 00:59:23,599
way from accessing variable variables

1647
00:59:22,240 --> 00:59:24,559
below

1648
00:59:23,599 --> 00:59:26,400
well

1649
00:59:24,559 --> 00:59:28,079
actually that's an easy case to handle

1650
00:59:26,400 --> 00:59:29,920
because we have terminal symbols sitting

1651
00:59:28,079 --> 00:59:32,319
on the top they're never going to change

1652
00:59:29,920 --> 00:59:36,079
anyway so you might as well match them

1653
00:59:32,319 --> 00:59:36,079
with the input at that time

1654
00:59:37,119 --> 00:59:40,880
so when you have a terminal

1655
00:59:38,880 --> 00:59:42,720
sitting at the top we'll just read

1656
00:59:40,880 --> 00:59:44,960
another input symbol and do it and match

1657
00:59:42,720 --> 00:59:46,480
it off there

1658
00:59:44,960 --> 00:59:48,720
and we just keep reading the terminal

1659
00:59:46,480 --> 00:59:49,920
symbols off until we have a variable

1660
00:59:48,720 --> 00:59:52,559
sitting on the top then we do a

1661
00:59:49,920 --> 00:59:52,559
substitution

1662
00:59:53,040 --> 00:59:56,319
um and we keep substituting variables

1663
00:59:54,799 --> 00:59:58,160
until we have a terminal then we read it

1664
00:59:56,319 --> 01:00:00,480
then we compare it with the input

1665
00:59:58,160 --> 01:00:02,640
and in so doing um we will end up

1666
01:00:00,480 --> 01:00:05,440
getting the same effect that i described

1667
01:00:02,640 --> 01:00:08,240
before without ever needing to dig down

1668
01:00:05,440 --> 01:00:09,599
into the into the interior of the stack

1669
01:00:08,240 --> 01:00:12,640
and doing substitutions there they're

1670
01:00:09,599 --> 01:00:15,440
all going to rise up to the top uh and

1671
01:00:12,640 --> 01:00:18,640
we can always do them at the top

1672
01:00:15,440 --> 01:00:20,640
okay um so anyway uh you know i forgot

1673
01:00:18,640 --> 01:00:22,000
to do that here so instead

1674
01:00:20,640 --> 01:00:24,559
only substitute variables when they're

1675
01:00:22,000 --> 01:00:26,480
at the top of the stack uh if a terminal

1676
01:00:24,559 --> 01:00:27,760
is on the top pop it and compare with

1677
01:00:26,480 --> 01:00:29,760
the input and reject if they're not

1678
01:00:27,760 --> 01:00:30,880
equal so if you ever have something

1679
01:00:29,760 --> 01:00:32,400
which is not matching the way it's

1680
01:00:30,880 --> 01:00:33,760
supposed to do that i mean that thread

1681
01:00:32,400 --> 01:00:36,079
is just gonna

1682
01:00:33,760 --> 01:00:37,760
fail you know then it was not

1683
01:00:36,079 --> 01:00:39,760
a bad

1684
01:00:37,760 --> 01:00:41,200
uh non-deterministic choice was made or

1685
01:00:39,760 --> 01:00:43,520
maybe the input was not in the language

1686
01:00:41,200 --> 01:00:44,799
anyway and there are no no good choices

1687
01:00:43,520 --> 01:00:47,200
um

1688
01:00:44,799 --> 01:00:48,000
so here my animation broke here so let

1689
01:00:47,200 --> 01:00:50,079
me just

1690
01:00:48,000 --> 01:00:52,640
put the whole thing up in front of you

1691
01:00:50,079 --> 01:00:54,720
so here is the actual construction

1692
01:00:52,640 --> 01:00:56,960
um

1693
01:00:54,720 --> 01:00:59,440
push the start symbol on the stack

1694
01:00:56,960 --> 01:01:00,720
if the top of the stack uh is a variable

1695
01:00:59,440 --> 01:01:02,079
replace it with a corresponding

1696
01:01:00,720 --> 01:01:03,920
right-hand side

1697
01:01:02,079 --> 01:01:05,839
doing a non-deterministic choice among

1698
01:01:03,920 --> 01:01:07,520
the various possibilities

1699
01:01:05,839 --> 01:01:08,960
if it's a terminal you pop it and match

1700
01:01:07,520 --> 01:01:11,359
it with the next input symbol and if the

1701
01:01:08,960 --> 01:01:13,520
stack is empty you accept

1702
01:01:11,359 --> 01:01:16,160
so here is how the stack would actually

1703
01:01:13,520 --> 01:01:17,599
look for this particular input

1704
01:01:16,160 --> 01:01:19,280
you know it would start off the same

1705
01:01:17,599 --> 01:01:20,319
you'd have e and then substitute with e

1706
01:01:19,280 --> 01:01:21,920
plus t

1707
01:01:20,319 --> 01:01:23,680
and then

1708
01:01:21,920 --> 01:01:25,680
we're going to always substitute do the

1709
01:01:23,680 --> 01:01:28,240
substitutions at the top

1710
01:01:25,680 --> 01:01:29,680
so e gets substituted by f

1711
01:01:28,240 --> 01:01:30,720
oh is that right

1712
01:01:29,680 --> 01:01:32,000
no

1713
01:01:30,720 --> 01:01:33,599
this slide i

1714
01:01:32,000 --> 01:01:36,000
messed up i apologize so e gets

1715
01:01:33,599 --> 01:01:37,040
substituted by t which gets substituted

1716
01:01:36,000 --> 01:01:40,079
by f

1717
01:01:37,040 --> 01:01:42,559
um and the point is that when you get to

1718
01:01:40,079 --> 01:01:44,319
an a sitting at the top uh forgive the

1719
01:01:42,559 --> 01:01:46,319
typos here

1720
01:01:44,319 --> 01:01:48,319
now we have a terminal symbol and that's

1721
01:01:46,319 --> 01:01:50,559
going to get matched off with the next

1722
01:01:48,319 --> 01:01:52,480
input symbol

1723
01:01:50,559 --> 01:01:54,480
and get removed and now we have just the

1724
01:01:52,480 --> 01:01:56,079
plus and the t left

1725
01:01:54,480 --> 01:01:57,680
and then the plus is also a terminal

1726
01:01:56,079 --> 01:01:59,520
symbol that's going to get matched over

1727
01:01:57,680 --> 01:02:00,640
the next thing we just have a t sitting

1728
01:01:59,520 --> 01:02:02,319
on the top and now we can do a

1729
01:02:00,640 --> 01:02:05,440
substitution

1730
01:02:02,319 --> 01:02:07,440
okay so that's how uh it works

1731
01:02:05,440 --> 01:02:10,160
okay i that's all i wanted to say i

1732
01:02:07,440 --> 01:02:11,599
think um oh yeah there's one just

1733
01:02:10,160 --> 01:02:13,680
remarked so this is not we're not going

1734
01:02:11,599 --> 01:02:16,319
to prove this but i think it's uh i i do

1735
01:02:13,680 --> 01:02:19,599
need to say this that actually you can

1736
01:02:16,319 --> 01:02:24,400
do the conversion in the other direction

1737
01:02:19,599 --> 01:02:24,400
too you can convert a um

1738
01:02:24,960 --> 01:02:28,559
so

1739
01:02:25,839 --> 01:02:29,280
a is a context-free language if and only

1740
01:02:28,559 --> 01:02:32,400
if

1741
01:02:29,280 --> 01:02:33,200
some push-down automaton recognizes a

1742
01:02:32,400 --> 01:02:35,200
and

1743
01:02:33,200 --> 01:02:37,200
um if you haven't

1744
01:02:35,200 --> 01:02:38,799
seen if and only if it's a it's an

1745
01:02:37,200 --> 01:02:40,160
expression i'm going to use

1746
01:02:38,799 --> 01:02:42,480
uh

1747
01:02:40,160 --> 01:02:44,799
uh again over and over so you should get

1748
01:02:42,480 --> 01:02:46,160
used to it it stands for if and only if

1749
01:02:44,799 --> 01:02:48,799
and which just means the implication

1750
01:02:46,160 --> 01:02:49,920
goes both ways so a is an uh

1751
01:02:48,799 --> 01:02:52,240
context-free

1752
01:02:49,920 --> 01:02:54,960
context-free language implies that some

1753
01:02:52,240 --> 01:02:56,160
push on time time recognizes a and vice

1754
01:02:54,960 --> 01:02:58,400
versa

1755
01:02:56,160 --> 01:02:59,760
um so there's really two things you need

1756
01:02:58,400 --> 01:03:01,200
to prove whenever you have an if and

1757
01:02:59,760 --> 01:03:03,280
only if you have to prove both

1758
01:03:01,200 --> 01:03:05,599
directions um

1759
01:03:03,280 --> 01:03:08,319
so uh thinking about that way splitting

1760
01:03:05,599 --> 01:03:10,400
them in half um the the forward

1761
01:03:08,319 --> 01:03:12,319
direction we've already proved

1762
01:03:10,400 --> 01:03:13,280
converting a push

1763
01:03:12,319 --> 01:03:15,200
context

1764
01:03:13,280 --> 01:03:17,359
uh free grammar to a push down on

1765
01:03:15,200 --> 01:03:18,960
automaton the reverse direction we're

1766
01:03:17,359 --> 01:03:20,480
not going to prove it's in the book if

1767
01:03:18,960 --> 01:03:22,240
you're curious

1768
01:03:20,480 --> 01:03:24,000
and you're responsible knowing that the

1769
01:03:22,240 --> 01:03:25,039
fact is true but you don't have to know

1770
01:03:24,000 --> 01:03:26,880
the proof

1771
01:03:25,039 --> 01:03:28,240
uh which is a somewhat comp a little bit

1772
01:03:26,880 --> 01:03:29,760
complicated and

1773
01:03:28,240 --> 01:03:31,200
you know i think it would take us too

1774
01:03:29,760 --> 01:03:32,799
long to go through it so you're not

1775
01:03:31,200 --> 01:03:34,720
responsible for it

1776
01:03:32,799 --> 01:03:36,480
um

1777
01:03:34,720 --> 01:03:37,520
so there's a last check in here that i

1778
01:03:36,480 --> 01:03:40,000
have for you

1779
01:03:37,520 --> 01:03:41,760
which is just a question uh

1780
01:03:40,000 --> 01:03:44,400
uh which you can answer based on the

1781
01:03:41,760 --> 01:03:46,480
material that we presented so far is

1782
01:03:44,400 --> 01:03:48,960
every regular language also a

1783
01:03:46,480 --> 01:03:50,640
context-free language

1784
01:03:48,960 --> 01:03:52,079
just yes no or

1785
01:03:50,640 --> 01:03:55,839
you're not sure

1786
01:03:52,079 --> 01:03:58,400
so let me launch that as a poll here

1787
01:03:55,839 --> 01:03:58,970
okay about to close

1788
01:03:58,400 --> 01:04:00,160
um

1789
01:03:58,970 --> 01:04:02,480
[Music]

1790
01:04:00,160 --> 01:04:05,920
ending polling

1791
01:04:02,480 --> 01:04:05,920
and sharing results

1792
01:04:06,400 --> 01:04:11,599
this one i think you you pretty much uh

1793
01:04:08,880 --> 01:04:12,880
most of you got some of you uh

1794
01:04:11,599 --> 01:04:14,480
are not sure

1795
01:04:12,880 --> 01:04:16,880
um

1796
01:04:14,480 --> 01:04:18,160
every language is in fact a context-free

1797
01:04:16,880 --> 01:04:19,359
language

1798
01:04:18,160 --> 01:04:21,760
um

1799
01:04:19,359 --> 01:04:24,480
and the way to see that is that every

1800
01:04:21,760 --> 01:04:27,599
regular language can be done by a dfa or

1801
01:04:24,480 --> 01:04:29,119
an nfa as we already showed

1802
01:04:27,599 --> 01:04:31,599
and um

1803
01:04:29,119 --> 01:04:35,359
dfa or an nfa is really just a push-on

1804
01:04:31,599 --> 01:04:36,559
automaton that never uses its stack

1805
01:04:35,359 --> 01:04:39,119
so

1806
01:04:36,559 --> 01:04:40,880
you can always think of a dfa as a push

1807
01:04:39,119 --> 01:04:42,720
down automaton and we already argued

1808
01:04:40,880 --> 01:04:44,960
that pushdown automata

1809
01:04:42,720 --> 01:04:46,319
are equivalent to context-free grammars

1810
01:04:44,960 --> 01:04:48,000
and so they do the context-free

1811
01:04:46,319 --> 01:04:50,160
languages

1812
01:04:48,000 --> 01:04:51,440
so anything that you can do with a dfa

1813
01:04:50,160 --> 01:04:55,680
you can also do with a push-down

1814
01:04:51,440 --> 01:04:57,200
automaton and so is therefore uh um

1815
01:04:55,680 --> 01:04:59,039
all the regular languages are also

1816
01:04:57,200 --> 01:05:01,920
context-free languages

1817
01:04:59,039 --> 01:05:03,440
okay so with that let's just uh kind of

1818
01:05:01,920 --> 01:05:05,839
pull things together

1819
01:05:03,440 --> 01:05:07,920
um a little quick recap as to what we've

1820
01:05:05,839 --> 01:05:09,200
been doing so far in the class we have

1821
01:05:07,920 --> 01:05:10,880
the regular languages and the

1822
01:05:09,200 --> 01:05:12,960
context-free languages

1823
01:05:10,880 --> 01:05:15,039
we had the two forms of sort of getting

1824
01:05:12,960 --> 01:05:17,359
at them the recognizer form which is

1825
01:05:15,039 --> 01:05:19,520
like the automata based perspective

1826
01:05:17,359 --> 01:05:21,440
like either a dfa or an nfa in the case

1827
01:05:19,520 --> 01:05:24,400
of the regular languages push down

1828
01:05:21,440 --> 01:05:26,240
automaton for the context-free languages

1829
01:05:24,400 --> 01:05:27,920
and for the generators we had the

1830
01:05:26,240 --> 01:05:29,599
regular expression

1831
01:05:27,920 --> 01:05:32,480
uh for the regular languages and the

1832
01:05:29,599 --> 01:05:34,720
context-free grammars for the for the

1833
01:05:32,480 --> 01:05:37,440
contextual languages okay

1834
01:05:34,720 --> 01:05:40,000
um and as we just pointed out in our

1835
01:05:37,440 --> 01:05:42,559
most in our last check-in the regular

1836
01:05:40,000 --> 01:05:44,799
languages form a subset and in fact a

1837
01:05:42,559 --> 01:05:47,119
proper subset of the context-free

1838
01:05:44,799 --> 01:05:48,480
languages uh as shown in this venn

1839
01:05:47,119 --> 01:05:50,240
diagram because we have already

1840
01:05:48,480 --> 01:05:53,599
exhibited languages that are

1841
01:05:50,240 --> 01:05:55,200
context-free but not regular

1842
01:05:53,599 --> 01:05:57,359
all right

1843
01:05:55,200 --> 01:05:58,880
so quick review we've defined the

1844
01:05:57,359 --> 01:06:00,720
context-free grammars and their

1845
01:05:58,880 --> 01:06:03,520
associated languages the context-free

1846
01:06:00,720 --> 01:06:05,440
languages we define push-down automata

1847
01:06:03,520 --> 01:06:07,839
and we showed how to convert context

1848
01:06:05,440 --> 01:06:08,960
free grammars to push down automatic

1849
01:06:07,839 --> 01:06:11,599
um

1850
01:06:08,960 --> 01:06:13,200
and that's all i have for you today

1851
01:06:11,599 --> 01:06:14,720
okay here's a question i'll answer to

1852
01:06:13,200 --> 01:06:16,480
everybody why do we strict ourselves to

1853
01:06:14,720 --> 01:06:19,520
a stack why don't we use random access

1854
01:06:16,480 --> 01:06:22,000
memory we will use random access memory

1855
01:06:19,520 --> 01:06:23,680
um for the next model called the turing

1856
01:06:22,000 --> 01:06:26,240
machine and we're going to introduce

1857
01:06:23,680 --> 01:06:28,400
that i think next to the next lecture so

1858
01:06:26,240 --> 01:06:29,520
that's going to be the

1859
01:06:28,400 --> 01:06:30,880
model that we're going to stick with

1860
01:06:29,520 --> 01:06:34,640
throughout the term

1861
01:06:30,880 --> 01:06:36,480
but we have not uh we were kind of using

1862
01:06:34,640 --> 01:06:39,599
introducing weaker models

1863
01:06:36,480 --> 01:06:42,240
uh as a kind of a prelude uh to the more

1864
01:06:39,599 --> 01:06:43,200
general purpose uh computational model

1865
01:06:42,240 --> 01:06:44,400
um

1866
01:06:43,200 --> 01:06:46,559
uh

1867
01:06:44,400 --> 01:06:47,680
really to get ourselves

1868
01:06:46,559 --> 01:06:50,079
warmed up

1869
01:06:47,680 --> 01:06:51,359
and also um because

1870
01:06:50,079 --> 01:06:53,760
um

1871
01:06:51,359 --> 01:06:55,920
for the weaker models you can fully

1872
01:06:53,760 --> 01:06:58,079
analyze them

1873
01:06:55,920 --> 01:07:00,720
um in a way that you cannot return

1874
01:06:58,079 --> 01:07:02,960
machines you you will be able to as you

1875
01:07:00,720 --> 01:07:05,359
will see

1876
01:07:02,960 --> 01:07:05,359
you can

1877
01:07:05,680 --> 01:07:09,760
determine properties of languages for

1878
01:07:07,839 --> 01:07:13,680
the weaker models that you cannot for

1879
01:07:09,760 --> 01:07:15,119
the more general models and so

1880
01:07:13,680 --> 01:07:16,799
i think that's helpful to have that

1881
01:07:15,119 --> 01:07:19,520
perspective that

1882
01:07:16,799 --> 01:07:21,359
you know for some cases you can get get

1883
01:07:19,520 --> 01:07:23,039
a full analysis and some other cases you

1884
01:07:21,359 --> 01:07:24,960
cannot um

1885
01:07:23,039 --> 01:07:26,480
but anyway um

1886
01:07:24,960 --> 01:07:28,000
that's the reason why we're stricter

1887
01:07:26,480 --> 01:07:30,960
restricted to the stack besides the fact

1888
01:07:28,000 --> 01:07:32,640
that these models have applications um

1889
01:07:30,960 --> 01:07:33,520
that i think are

1890
01:07:32,640 --> 01:07:35,119
worth

1891
01:07:33,520 --> 01:07:36,240
you people seeing

1892
01:07:35,119 --> 01:07:39,599
um

1893
01:07:36,240 --> 01:07:41,520
why yeah some reason we chose a stack

1894
01:07:39,599 --> 01:07:43,920
well why did we choose a stack and not

1895
01:07:41,520 --> 01:07:47,599
some other data structure for our uh

1896
01:07:43,920 --> 01:07:49,359
temporary for our our extra storage

1897
01:07:47,599 --> 01:07:51,039
and the reason

1898
01:07:49,359 --> 01:07:52,799
for a stack for one thing the stack is

1899
01:07:51,039 --> 01:07:54,480
what is exactly what you need to get to

1900
01:07:52,799 --> 01:07:57,119
the correspondence with context-free

1901
01:07:54,480 --> 01:08:00,640
grammars

1902
01:07:57,119 --> 01:08:00,640
um if you use some other

1903
01:08:01,760 --> 01:08:06,000
storage like the queue for example

1904
01:08:03,680 --> 01:08:08,960
instead of a stack in fact you get a

1905
01:08:06,000 --> 01:08:10,720
very different outcome and

1906
01:08:08,960 --> 01:08:12,880
it's an actually interesting exercise to

1907
01:08:10,720 --> 01:08:14,799
see what happens what do you get if you

1908
01:08:12,880 --> 01:08:17,199
use a queue as an external storage

1909
01:08:14,799 --> 01:08:18,480
instead of as a stack uh

1910
01:08:17,199 --> 01:08:19,600
it's a good homework problem maybe i'll

1911
01:08:18,480 --> 01:08:20,640
assign it

1912
01:08:19,600 --> 01:08:24,480
um

1913
01:08:20,640 --> 01:08:26,719
uh let's see um

1914
01:08:24,480 --> 01:08:27,520
nfa

1915
01:08:26,719 --> 01:08:28,799
okay

1916
01:08:27,520 --> 01:08:30,640
uh

1917
01:08:28,799 --> 01:08:31,600
we showed so

1918
01:08:30,640 --> 01:08:32,319
um

1919
01:08:31,600 --> 01:08:34,880
we

1920
01:08:32,319 --> 01:08:37,359
we showed that non-determinism can be

1921
01:08:34,880 --> 01:08:39,279
eliminated for finite automata so nfas

1922
01:08:37,359 --> 01:08:41,920
and dfas are equivalent

1923
01:08:39,279 --> 01:08:43,520
uh what about for for pushdown automata

1924
01:08:41,920 --> 01:08:44,799
uh the answer is no they're not

1925
01:08:43,520 --> 01:08:47,440
equivalent i think i mentioned that

1926
01:08:44,799 --> 01:08:49,279
earlier but i don't mind repeating it

1927
01:08:47,440 --> 01:08:51,600
there are certain languages that can be

1928
01:08:49,279 --> 01:08:53,759
done only with non-deterministic push

1929
01:08:51,600 --> 01:08:55,839
down automata and cannot be done with

1930
01:08:53,759 --> 01:08:58,560
deterministic push down automata for

1931
01:08:55,839 --> 01:09:00,960
example that language w w reverse

1932
01:08:58,560 --> 01:09:02,239
that requires the non-determinism in

1933
01:09:00,960 --> 01:09:04,080
order for the machine to be able to

1934
01:09:02,239 --> 01:09:07,120
guess where the middle is

1935
01:09:04,080 --> 01:09:11,799
so um okay i'm gonna head off uh thank

1936
01:09:07,120 --> 01:09:11,799
you guys see you on tuesday

1937
01:09:22,159 --> 01:09:24,239
you

