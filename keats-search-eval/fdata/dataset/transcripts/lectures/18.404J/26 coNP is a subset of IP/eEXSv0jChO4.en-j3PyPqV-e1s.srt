1
00:00:00,000 --> 00:00:01,497
[SQUEAKING]

2
00:00:01,497 --> 00:00:02,994
[RUSTLING]

3
00:00:02,994 --> 00:00:04,491
[CLICKING]

4
00:00:04,491 --> 00:00:24,960

5
00:00:24,960 --> 00:00:28,150
MICHAEL SIPSER:
Greetings, everybody.

6
00:00:28,150 --> 00:00:31,740
Welcome to our last
lecture of the term.

7
00:00:31,740 --> 00:00:38,620
We have survived a
semester online in 18.404

8
00:00:38,620 --> 00:00:45,160
and we are going to
conclude our last topic

9
00:00:45,160 --> 00:00:49,120
today, which is interactive
proof systems that we started

10
00:00:49,120 --> 00:00:50,080
last time.

11
00:00:50,080 --> 00:00:59,140
And with the big--
well, the big theorem

12
00:00:59,140 --> 00:01:04,209
of interactive proof systems
is that IP equals PSPACE.

13
00:01:04,209 --> 00:01:06,130
And we're going to
give the main idea

14
00:01:06,130 --> 00:01:13,280
for that in a slightly
weaker theorem, as we'll see.

15
00:01:13,280 --> 00:01:16,070
So why don't we jump in?

16
00:01:16,070 --> 00:01:19,510
So we have been doing
interactive proofs.

17
00:01:19,510 --> 00:01:24,610
We gave an example of showing
that the graph isomorphism

18
00:01:24,610 --> 00:01:27,400
problem, the
complement of that is

19
00:01:27,400 --> 00:01:29,590
an IP, as I hope you remember.

20
00:01:29,590 --> 00:01:33,820
We had that interaction with
the approver and a verifier.

21
00:01:33,820 --> 00:01:35,530
We're going to go
through it quickly.

22
00:01:35,530 --> 00:01:38,110
Not that protocol,
but just the setup.

23
00:01:38,110 --> 00:01:44,590
And then we're going to finish
by showing that this number SAT

24
00:01:44,590 --> 00:01:47,080
problem is an IP
and should conclude

25
00:01:47,080 --> 00:01:51,080
that coNP is a subset of IP.

26
00:01:51,080 --> 00:01:56,050
All right, so let's go for it.

27
00:01:56,050 --> 00:01:56,550
Yes.

28
00:01:56,550 --> 00:01:59,400

29
00:01:59,400 --> 00:02:03,360
So just remember,
interactive proof systems,

30
00:02:03,360 --> 00:02:06,090
there are these two parties,
the prover and the verifier.

31
00:02:06,090 --> 00:02:09,960
The prover has unlimited
computational ability.

32
00:02:09,960 --> 00:02:23,400
I kind of model that as an army
of students perhaps who can--

33
00:02:23,400 --> 00:02:27,570
where we don't-- they
can work all night.

34
00:02:27,570 --> 00:02:30,480
They can use
computational resources.

35
00:02:30,480 --> 00:02:34,290
And the prover,
however, we're not

36
00:02:34,290 --> 00:02:36,090
going to measure the
computational power

37
00:02:36,090 --> 00:02:36,870
of the prover.

38
00:02:36,870 --> 00:02:38,950
That's unlimited.

39
00:02:38,950 --> 00:02:43,110
And so the prover can do
things like find certificates.

40
00:02:43,110 --> 00:02:45,720
It can test whether
things are satisfiable.

41
00:02:45,720 --> 00:02:49,410
It can factor numbers.

42
00:02:49,410 --> 00:02:50,220
We don't care.

43
00:02:50,220 --> 00:02:52,560
It can do whatever
we'd like and there

44
00:02:52,560 --> 00:02:57,070
is no charge for the prover's
computational demands.

45
00:02:57,070 --> 00:02:57,570
OK.

46
00:02:57,570 --> 00:03:00,360
So the setup we had was the
prover and the verifier.

47
00:03:00,360 --> 00:03:01,680
Both see the input.

48
00:03:01,680 --> 00:03:04,450
The exchange of polynomial
number of messages.

49
00:03:04,450 --> 00:03:06,285
And then the verifier
accepts or rejects.

50
00:03:06,285 --> 00:03:09,510

51
00:03:09,510 --> 00:03:16,530
And we had this notion
of the probability

52
00:03:16,530 --> 00:03:19,560
that the verifier ends
up accepting when paired

53
00:03:19,560 --> 00:03:22,440
with a particular prover.

54
00:03:22,440 --> 00:03:26,580
And what we want is that
for strings in a language,

55
00:03:26,580 --> 00:03:29,790
that probability should
be high for some prover.

56
00:03:29,790 --> 00:03:32,520
And for strings not
in the language,

57
00:03:32,520 --> 00:03:35,280
that probability should be low
no matter what the prover does.

58
00:03:35,280 --> 00:03:38,130
So there's nothing
the prover can do.

59
00:03:38,130 --> 00:03:41,160
And the way it kind of
suggests that at any prover.

60
00:03:41,160 --> 00:03:48,410
But whatever the prover's
strategy cannot make

61
00:03:48,410 --> 00:03:50,563
the verifier accept
with high probability.

62
00:03:50,563 --> 00:03:52,730
Just doesn't have enough
information or it doesn't--

63
00:03:52,730 --> 00:03:55,520
it's just not able to
make the verifier accept

64
00:03:55,520 --> 00:03:56,570
with high probability.

65
00:03:56,570 --> 00:04:00,080

66
00:04:00,080 --> 00:04:01,880
You might think of
the prover as trying

67
00:04:01,880 --> 00:04:03,140
to make the verifier accept.

68
00:04:03,140 --> 00:04:06,710
So the P tilde is
a crooked prover.

69
00:04:06,710 --> 00:04:09,980
I don't think that went down
very well with everybody.

70
00:04:09,980 --> 00:04:11,160
So I have it here.

71
00:04:11,160 --> 00:04:13,220
Another way of looking
at it, maybe it

72
00:04:13,220 --> 00:04:20,940
looks a little bit
more like NP here where

73
00:04:20,940 --> 00:04:23,490
IP is the collection of
languages where there's

74
00:04:23,490 --> 00:04:25,410
a verifier, just like we had.

75
00:04:25,410 --> 00:04:28,260
You can think of NP as
having a verifier which

76
00:04:28,260 --> 00:04:29,940
can check certificates.

77
00:04:29,940 --> 00:04:32,400
Here the prover is going
to be like the certificate

78
00:04:32,400 --> 00:04:34,860
so that for strings
in the language,

79
00:04:34,860 --> 00:04:38,100
there's a prover which can
interact with the verifier

80
00:04:38,100 --> 00:04:40,260
and make it accept
a high probability.

81
00:04:40,260 --> 00:04:42,090
And you're not in
the language, there

82
00:04:42,090 --> 00:04:45,270
is no prover, which can
interact with the verifier

83
00:04:45,270 --> 00:04:48,540
and make the verifier
accept with even

84
00:04:48,540 --> 00:04:50,400
more than low probability.

85
00:04:50,400 --> 00:04:53,940
What's important is this
gap, just like with BPP,

86
00:04:53,940 --> 00:04:57,060
between acceptance or rejection.

87
00:04:57,060 --> 00:05:01,560
And that gap is
there because we want

88
00:05:01,560 --> 00:05:03,510
to be able to use the
amplification lemma.

89
00:05:03,510 --> 00:05:05,340
And if there was
no gap, then you

90
00:05:05,340 --> 00:05:08,340
wouldn't be able
to amplify and make

91
00:05:08,340 --> 00:05:11,190
the probability of acceptance
extremely high when you want

92
00:05:11,190 --> 00:05:13,830
it to be in the language,
when you're in the language,

93
00:05:13,830 --> 00:05:15,945
and extremely low when
you're not in the language.

94
00:05:15,945 --> 00:05:18,280

95
00:05:18,280 --> 00:05:18,780
OK.

96
00:05:18,780 --> 00:05:23,560
So I hope that refreshes your
memory as to how that works.

97
00:05:23,560 --> 00:05:27,465
We're going to walk
ourselves through the--

98
00:05:27,465 --> 00:05:32,940

99
00:05:32,940 --> 00:05:37,620
well, through what
we did last time.

100
00:05:37,620 --> 00:05:40,660
But let's set the
stage for that.

101
00:05:40,660 --> 00:05:42,670
So the surprising
theorem, as I mentioned,

102
00:05:42,670 --> 00:05:46,110
is that IP equals PSPACE.

103
00:05:46,110 --> 00:05:51,180
One direction of that is a
fairly standard simulation.

104
00:05:51,180 --> 00:05:54,510
With PSPACE, you can
basically work your way

105
00:05:54,510 --> 00:05:56,490
through the tree
of possibilities

106
00:05:56,490 --> 00:05:59,790
for an interactive
proof protocol.

107
00:05:59,790 --> 00:06:02,340
And you can calculate
the probability

108
00:06:02,340 --> 00:06:05,700
that the verifier
would end up accepting

109
00:06:05,700 --> 00:06:08,010
if you had the best possible
prover that would try

110
00:06:08,010 --> 00:06:09,390
to make the verifier accept.

111
00:06:09,390 --> 00:06:11,160
And you can just do
that calculation.

112
00:06:11,160 --> 00:06:12,623
It's in the book.

113
00:06:12,623 --> 00:06:14,790
You're not going to be
responsible for knowing that,

114
00:06:14,790 --> 00:06:15,290
actually.

115
00:06:15,290 --> 00:06:16,710
We haven't covered
it in lecture.

116
00:06:16,710 --> 00:06:19,714
But it's not very hard.

117
00:06:19,714 --> 00:06:21,778
A little technical, I suppose.

118
00:06:21,778 --> 00:06:23,570
The other direction is
the interesting one,

119
00:06:23,570 --> 00:06:25,070
and that's the
direction we're going

120
00:06:25,070 --> 00:06:26,420
to be moving toward today.

121
00:06:26,420 --> 00:06:29,840
We won't quite get there,
but the way it works

122
00:06:29,840 --> 00:06:33,860
is that to show that
everything in PSPACE, which

123
00:06:33,860 --> 00:06:37,190
is kind of amazing, is
contained with an IP.

124
00:06:37,190 --> 00:06:40,520
So everything in PSPACE can be
done with an interactive proof

125
00:06:40,520 --> 00:06:43,010
system.

126
00:06:43,010 --> 00:06:45,650
And the way that
is done is by using

127
00:06:45,650 --> 00:06:49,220
a PSPACE complete problem, TQBF,
and showing that that problem

128
00:06:49,220 --> 00:06:51,590
itself is an IP.

129
00:06:51,590 --> 00:06:54,140
But we're not going
to prove that.

130
00:06:54,140 --> 00:06:55,640
That would be sort
of the next thing

131
00:06:55,640 --> 00:06:57,710
we would prove if we had
a little bit more time.

132
00:06:57,710 --> 00:07:02,120
But we're going to be satisfied
with just the somewhat

133
00:07:02,120 --> 00:07:09,350
weaker but very similar
statement that coNP

134
00:07:09,350 --> 00:07:12,410
is contained in IP here.

135
00:07:12,410 --> 00:07:15,562
Again, still very
surprising, because you

136
00:07:15,562 --> 00:07:18,020
have to be able to show, for
example, that a formula is not

137
00:07:18,020 --> 00:07:19,910
satisfiable with a prover.

138
00:07:19,910 --> 00:07:22,970
How can a prover convince a
verifier that a formula is not

139
00:07:22,970 --> 00:07:26,060
satisfiable?

140
00:07:26,060 --> 00:07:27,740
Showing that it is
satisfiable, you just

141
00:07:27,740 --> 00:07:30,115
give the certificate, which
is the satisfying assignment.

142
00:07:30,115 --> 00:07:32,510
But how do you show
something's not satisfiable?

143
00:07:32,510 --> 00:07:34,940
It's unexpected.

144
00:07:34,940 --> 00:07:38,160
And the proof of that is
pretty much similar, slightly

145
00:07:38,160 --> 00:07:42,650
is one kind of
technical point which

146
00:07:42,650 --> 00:07:43,910
we don't have to get into.

147
00:07:43,910 --> 00:07:49,640
So it's slightly easier but
very much in the same spirit.

148
00:07:49,640 --> 00:07:51,580
So remember this
number set problem

149
00:07:51,580 --> 00:07:56,170
is you're given a
formula and a number,

150
00:07:56,170 --> 00:07:57,970
and that number
is supposed to be

151
00:07:57,970 --> 00:08:02,510
exactly the number of satisfying
assignments of the formula.

152
00:08:02,510 --> 00:08:05,980
So in particular, a formula's
unsatisfiable, then it

153
00:08:05,980 --> 00:08:07,810
would be paired
with the number 0.

154
00:08:07,810 --> 00:08:13,120
And that's why the number
set problem is coNP-hard,

155
00:08:13,120 --> 00:08:18,070
because you can easily reduce
the unsatisfiability to number

156
00:08:18,070 --> 00:08:18,760
set.

157
00:08:18,760 --> 00:08:23,140
An unsatisfiability
is coNP complete.

158
00:08:23,140 --> 00:08:26,680
OK, so remember we introduced
this notation last time.

159
00:08:26,680 --> 00:08:29,480
This is going to be critical
for understanding this proof.

160
00:08:29,480 --> 00:08:31,000
So let's go through
it once again.

161
00:08:31,000 --> 00:08:34,030

162
00:08:34,030 --> 00:08:38,299
So if you have some
formula, what I'd like to do

163
00:08:38,299 --> 00:08:41,760
is preset some of the
variables of that formula.

164
00:08:41,760 --> 00:08:46,500
So that's going to be a formula
on m variables x1 to xm.

165
00:08:46,500 --> 00:08:54,690
And I'd like to preset the first
i variables to zeros or ones

166
00:08:54,690 --> 00:08:57,280
as I wish.

167
00:08:57,280 --> 00:09:02,730
So I'm going to indicate
that by phi with 0 means

168
00:09:02,730 --> 00:09:05,880
I'm setting x1 to 0 and
the rest of the variables

169
00:09:05,880 --> 00:09:08,770
remain variables.

170
00:09:08,770 --> 00:09:15,700
And more generally, phi
of i values a1 to ai,

171
00:09:15,700 --> 00:09:17,830
which to start
off with are going

172
00:09:17,830 --> 00:09:20,380
to be just zeros and
ones, just Boolean values.

173
00:09:20,380 --> 00:09:24,880
That's going to be the
formula with those first x1

174
00:09:24,880 --> 00:09:32,840
to set to a1 dot, dot, dot
xi set to ai for those i

175
00:09:32,840 --> 00:09:37,610
constants, which
were zeros and ones.

176
00:09:37,610 --> 00:09:39,880
I'm going to call those
presets, because we're

177
00:09:39,880 --> 00:09:44,722
presetting some of the
variables in the formula.

178
00:09:44,722 --> 00:09:46,180
And the rest of
the variables we're

179
00:09:46,180 --> 00:09:47,660
going to leave as variables.

180
00:09:47,660 --> 00:09:50,140
So we get a new formula
on fewer variables

181
00:09:50,140 --> 00:09:52,345
by doing this
pre-setting process.

182
00:09:52,345 --> 00:09:54,880

183
00:09:54,880 --> 00:09:57,790
And we're going to get to
do the same thing in terms

184
00:09:57,790 --> 00:10:02,060
of counting the number of
satisfying assignments.

185
00:10:02,060 --> 00:10:06,770
So remember the notation
number phi is the number

186
00:10:06,770 --> 00:10:09,170
of satisfying assignments.

187
00:10:09,170 --> 00:10:11,870
Number phi with a preset
of 0 is the number

188
00:10:11,870 --> 00:10:16,320
of satisfying assignments
when you've set x1 to 0.

189
00:10:16,320 --> 00:10:22,140
And no phi of a1 to ai is where
you set the first i variables

190
00:10:22,140 --> 00:10:24,060
to those i values.

191
00:10:24,060 --> 00:10:29,340
And then you're going to look
at the number of satisfying

192
00:10:29,340 --> 00:10:32,760
assignments with
those presets in mind.

193
00:10:32,760 --> 00:10:34,930
So there were two facts.

194
00:10:34,930 --> 00:10:36,930
I'm going to call them
identities, because we're

195
00:10:36,930 --> 00:10:41,970
going to rely on those and we're
going to actually extend those

196
00:10:41,970 --> 00:10:44,890
to the non Boolean case,
as we'll see shortly.

197
00:10:44,890 --> 00:10:54,710
So these two identities
say that, first of all,

198
00:10:54,710 --> 00:10:57,940
if I preset, I
think understanding

199
00:10:57,940 --> 00:11:00,850
the first one is clear
just by thinking about it

200
00:11:00,850 --> 00:11:03,490
in the case where i equals 0.

201
00:11:03,490 --> 00:11:07,630
So this is the case where
the number of satisfying

202
00:11:07,630 --> 00:11:12,240
assignments altogether is
the number of satisfying

203
00:11:12,240 --> 00:11:15,870
assignments when I've set x1 to
0 plus the number of satisfying

204
00:11:15,870 --> 00:11:19,180
assignments when
I've set x1 to 1.

205
00:11:19,180 --> 00:11:21,490
And this just
generalizes that when

206
00:11:21,490 --> 00:11:27,340
I look at having already
preset the first i variables.

207
00:11:27,340 --> 00:11:32,430
So if I preset the first i
variables to these i values,

208
00:11:32,430 --> 00:11:33,930
the number of
satisfying assignments

209
00:11:33,930 --> 00:11:36,480
I get there is the number
of satisfying assignments

210
00:11:36,480 --> 00:11:39,870
I get with those presets
plus the next variable being

211
00:11:39,870 --> 00:11:41,550
set either to 0 or to 1.

212
00:11:41,550 --> 00:11:42,960
And then you add those up.

213
00:11:42,960 --> 00:11:45,620
The same idea.

214
00:11:45,620 --> 00:11:49,990
And lastly, if I set
all of the variables

215
00:11:49,990 --> 00:11:53,330
to values, so I have no
variables left, and I look

216
00:11:53,330 --> 00:11:55,220
at the number of
satisfying assignments

217
00:11:55,220 --> 00:12:01,320
consistent with that
fully set variables,

218
00:12:01,320 --> 00:12:03,320
so there's no variables
left, everything is set,

219
00:12:03,320 --> 00:12:06,650
everything is preset,
that's just whether or not

220
00:12:06,650 --> 00:12:11,010
those values have satisfied
the formula already or not.

221
00:12:11,010 --> 00:12:13,820
So this is going to be
equal to 0 or 1, the number

222
00:12:13,820 --> 00:12:15,620
of consistent
satisfying assignments

223
00:12:15,620 --> 00:12:18,920
with those m presets where
m is a number of variables

224
00:12:18,920 --> 00:12:22,850
is just whether those m values
satisfy the formula, in which

225
00:12:22,850 --> 00:12:26,270
case, I get 1, or they don't
satisfy the formula, in which

226
00:12:26,270 --> 00:12:29,000
case, I get a 0.

227
00:12:29,000 --> 00:12:31,887
Critical to understand
these in the Boolean case,

228
00:12:31,887 --> 00:12:33,470
because we're going
to generalize this

229
00:12:33,470 --> 00:12:35,600
to the non Boolean
case, and it's

230
00:12:35,600 --> 00:12:37,220
going to be just more abstract.

231
00:12:37,220 --> 00:12:39,410
The formulas are going
to look the same.

232
00:12:39,410 --> 00:12:42,450
We're going to have to kind of--

233
00:12:42,450 --> 00:12:44,160
we're going to
lose the intuition

234
00:12:44,160 --> 00:12:47,990
that those things correspond
to satisfying assignments.

235
00:12:47,990 --> 00:12:51,550
Or counting the number of
satisfying assignments.

236
00:12:51,550 --> 00:12:52,400
All right.

237
00:12:52,400 --> 00:12:55,570
So let's have a
quick check-in here.

238
00:12:55,570 --> 00:12:58,470
So we're just going to
do an example to hope

239
00:12:58,470 --> 00:13:03,130
to nail this in, this idea.

240
00:13:03,130 --> 00:13:04,740
So here's a particular
formula phi.

241
00:13:04,740 --> 00:13:08,970

242
00:13:08,970 --> 00:13:12,100
And now remember,
number phi is the number

243
00:13:12,100 --> 00:13:13,210
of satisfying assignments.

244
00:13:13,210 --> 00:13:15,790
So phi, the number of
satisfying assignments where

245
00:13:15,790 --> 00:13:20,270
I've set x1 to 0 and so on.

246
00:13:20,270 --> 00:13:21,860
And here I'm really
kind of giving you

247
00:13:21,860 --> 00:13:26,720
two options in each
row for the value.

248
00:13:26,720 --> 00:13:28,670
Now you have to check
all that are true.

249
00:13:28,670 --> 00:13:32,140
So it's really going to be at
most one per row, presumably.

250
00:13:32,140 --> 00:13:36,700

251
00:13:36,700 --> 00:13:37,540
All right.

252
00:13:37,540 --> 00:13:41,140
Let's see if you're
with me here.

253
00:13:41,140 --> 00:13:47,880
So the number of satisfying
assignments for altogether,

254
00:13:47,880 --> 00:13:52,170
well, there are two ways
of satisfying this formula.

255
00:13:52,170 --> 00:13:54,660
This is really
like exclusive or.

256
00:13:54,660 --> 00:14:01,140
So either x1 is 1, x2 is
0, or x1 is 0 and x2 is 1.

257
00:14:01,140 --> 00:14:03,540
So one of the variables
has to be true.

258
00:14:03,540 --> 00:14:04,870
The other one has to be false.

259
00:14:04,870 --> 00:14:07,350
And then you're going to end
up satisfying both clauses,

260
00:14:07,350 --> 00:14:09,780
as you can easily see.

261
00:14:09,780 --> 00:14:14,770
So b is correct
in the first line.

262
00:14:14,770 --> 00:14:16,890
Now, if I'm going
to already commit

263
00:14:16,890 --> 00:14:21,640
to saying the first
variable is set to 0, now

264
00:14:21,640 --> 00:14:23,960
how many satisfying
assignments can there be?

265
00:14:23,960 --> 00:14:25,480
Well, the second
variable just has

266
00:14:25,480 --> 00:14:27,970
to be set to 1 in
order to satisfy.

267
00:14:27,970 --> 00:14:31,270
So now there's going to be
only one satisfying assignment

268
00:14:31,270 --> 00:14:34,720
consistent with setting
the first variable to 0.

269
00:14:34,720 --> 00:14:38,470
Now if I set both
variables to 0,

270
00:14:38,470 --> 00:14:41,080
now how many satisfying
assignments can there

271
00:14:41,080 --> 00:14:43,060
be consistent with
that assignment?

272
00:14:43,060 --> 00:14:50,230
There can be 0, because in
order to satisfy this formula,

273
00:14:50,230 --> 00:14:51,730
one of the variables
has to be 0.

274
00:14:51,730 --> 00:14:52,930
The other one has to be 1.

275
00:14:52,930 --> 00:14:54,585
If I'm presenting
them both to 0,

276
00:14:54,585 --> 00:14:56,710
there's not going to be
any satisfying assignments,

277
00:14:56,710 --> 00:15:01,700
because 0, 0 not
satisfy the formula.

278
00:15:01,700 --> 00:15:08,370
OK, apologies for messing up
that check in on the last day.

279
00:15:08,370 --> 00:15:09,000
Oh well.

280
00:15:09,000 --> 00:15:12,420

281
00:15:12,420 --> 00:15:13,290
All right.

282
00:15:13,290 --> 00:15:28,960
Let's first go over the protocol
we attempted for number SAT

283
00:15:28,960 --> 00:15:32,770
last week on Thursday.

284
00:15:32,770 --> 00:15:39,620
So we're given the input,
the formula, and a k.

285
00:15:39,620 --> 00:15:41,760
And remember what
we want to happen.

286
00:15:41,760 --> 00:15:43,790
We want the verifier
to end up accepting

287
00:15:43,790 --> 00:15:47,150
with high probability when
k is the correct value

288
00:15:47,150 --> 00:15:52,040
and with low probability when
k is not the correct value.

289
00:15:52,040 --> 00:15:57,770
Now, this is going to be, as
you may remember from last time,

290
00:15:57,770 --> 00:16:00,230
this is going to end up
being a flawed protocol,

291
00:16:00,230 --> 00:16:01,730
because it's exponential.

292
00:16:01,730 --> 00:16:05,060
We're only allowed to have
a polynomial size protocol.

293
00:16:05,060 --> 00:16:09,260
But just looking ahead
in this protocol,

294
00:16:09,260 --> 00:16:11,420
the verifier is going
to end up accepting

295
00:16:11,420 --> 00:16:17,000
with probability 1 for an honest
prover and with probability 0

296
00:16:17,000 --> 00:16:18,590
no matter what the
prover tries to do.

297
00:16:18,590 --> 00:16:24,080
So for any prover, the verifier
cannot be made to accept.

298
00:16:24,080 --> 00:16:27,470
So this is kind
of an extreme case

299
00:16:27,470 --> 00:16:30,140
where there's not going to end
up being any probabilities.

300
00:16:30,140 --> 00:16:31,880
But it's an
exponential protocol.

301
00:16:31,880 --> 00:16:34,440
So in that sense, it
doesn't do what we need.

302
00:16:34,440 --> 00:16:37,790
So let's go through it,
because it really sets us up

303
00:16:37,790 --> 00:16:43,960
for the polynomial protocol
with the non Boolean values.

304
00:16:43,960 --> 00:16:45,070
All right.

305
00:16:45,070 --> 00:16:48,130
So first the prover sends--

306
00:16:48,130 --> 00:16:50,980
let's just look at
it and not rush it.

307
00:16:50,980 --> 00:16:57,520
The prover sends the number
of satisfying assignments

308
00:16:57,520 --> 00:17:00,150
according to the prover.

309
00:17:00,150 --> 00:17:05,240
The verifier checks
that is equal to k.

310
00:17:05,240 --> 00:17:06,829
And I think it's
best to understand

311
00:17:06,829 --> 00:17:12,170
this first with the case that
the input is in the language.

312
00:17:12,170 --> 00:17:15,937
So k is correct and we
have an honest prover.

313
00:17:15,937 --> 00:17:17,520
And then we'll
understand what happens

314
00:17:17,520 --> 00:17:19,500
if k is not in the language.

315
00:17:19,500 --> 00:17:23,160
And we'll see that no matter
what the prover tries to do,

316
00:17:23,160 --> 00:17:27,079
the verifier is going
to end up not accepting.

317
00:17:27,079 --> 00:17:32,490
And again, this is just a
setup for the real protocol.

318
00:17:32,490 --> 00:17:34,010
So this is kind of
a dopey protocol.

319
00:17:34,010 --> 00:17:36,920
You're going to think, what in
the world, why am I doing this?

320
00:17:36,920 --> 00:17:39,800

321
00:17:39,800 --> 00:17:42,320
It seems like I'm
making something that's

322
00:17:42,320 --> 00:17:45,830
very simple complicated, but
it's really just the framework

323
00:17:45,830 --> 00:17:47,330
that I'm putting together.

324
00:17:47,330 --> 00:17:51,090
Because, well, you'll see.

325
00:17:51,090 --> 00:17:51,590
All right.

326
00:17:51,590 --> 00:17:53,840
So the proof is going
to send the claim

327
00:17:53,840 --> 00:17:56,660
for the number of
satisfying assignments,

328
00:17:56,660 --> 00:17:59,960
which in the honest case is
going to be the correct value.

329
00:17:59,960 --> 00:18:02,870
The verifier checks that
it matches the input.

330
00:18:02,870 --> 00:18:05,540
Now the verifier says,
well, I want to be convinced

331
00:18:05,540 --> 00:18:07,410
that your claim is correct.

332
00:18:07,410 --> 00:18:12,070
So the prover is going
to justify that claim

333
00:18:12,070 --> 00:18:14,320
by saying, well, the
total number of satisfying

334
00:18:14,320 --> 00:18:16,690
assignments is
whatever it is, 100

335
00:18:16,690 --> 00:18:23,590
because the number when
I have x1 set to 0 is 60.

336
00:18:23,590 --> 00:18:26,440
And the number when I
have x1 set to 1 is 40.

337
00:18:26,440 --> 00:18:28,750
And that adds up to
100, which is what

338
00:18:28,750 --> 00:18:30,880
you would need to have happen.

339
00:18:30,880 --> 00:18:35,330
So the verifier checks that the
sum is correct and then says,

340
00:18:35,330 --> 00:18:37,980
well, now how do I know
those two values are right?

341
00:18:37,980 --> 00:18:41,850
So then the prover unpacks
it one level further.

342
00:18:41,850 --> 00:18:46,850
So breaks those two
down by justifying

343
00:18:46,850 --> 00:18:50,000
that phi 0 was correct,
that value 60 was correct,

344
00:18:50,000 --> 00:18:53,180
by saying, well, now if
I set the next variable,

345
00:18:53,180 --> 00:18:57,260
x2 to 0 and 1, that's going
to have to add up to phi 0.

346
00:18:57,260 --> 00:19:01,370
So maybe to get 60,
I had 50 and 10.

347
00:19:01,370 --> 00:19:09,180
And to get 40 for number
phi of one, I had 20 and 20.

348
00:19:09,180 --> 00:19:14,350
So these I have to add up.

349
00:19:14,350 --> 00:19:18,760
So each level justifies
the preceding level.

350
00:19:18,760 --> 00:19:20,410
We're going to have
that happen again.

351
00:19:20,410 --> 00:19:23,480

352
00:19:23,480 --> 00:19:28,250
Now, the prover says, well, I
mean, I need to be convinced.

353
00:19:28,250 --> 00:19:29,000
I don't trust you.

354
00:19:29,000 --> 00:19:32,970
I need to be convinced that
these values are correct.

355
00:19:32,970 --> 00:19:37,130
So level by level,
the prover is going

356
00:19:37,130 --> 00:19:40,910
to be setting more and more
of the variables in all

357
00:19:40,910 --> 00:19:42,680
the possible ways
until it gets down

358
00:19:42,680 --> 00:19:46,430
to the very bottom where
it's setting the variables

359
00:19:46,430 --> 00:19:47,970
in all possible ways.

360
00:19:47,970 --> 00:19:52,740
So exponentially
many settings here.

361
00:19:52,740 --> 00:19:56,950
And the verifier now checks that
the previous round was correct.

362
00:19:56,950 --> 00:20:00,450
So that's where we set
only the first m minus 1,

363
00:20:00,450 --> 00:20:03,510
the very last variable
hadn't yet been set.

364
00:20:03,510 --> 00:20:06,690
So checks all of
those 2 to the n

365
00:20:06,690 --> 00:20:11,130
minus 1 possible
settings in terms

366
00:20:11,130 --> 00:20:14,460
of the new settings
that we got where

367
00:20:14,460 --> 00:20:18,060
we set those m minus 1
settings, but we extended it

368
00:20:18,060 --> 00:20:19,710
by 0 and by 1.

369
00:20:19,710 --> 00:20:23,175
Again, this is the same identity
that we used from before.

370
00:20:23,175 --> 00:20:26,400

371
00:20:26,400 --> 00:20:31,890
And now that the prover has sent
all of those possible values,

372
00:20:31,890 --> 00:20:36,510
the verifier needs to be sure
that those are still correct.

373
00:20:36,510 --> 00:20:39,900
But the thing is
that at this point,

374
00:20:39,900 --> 00:20:42,150
those are all zeros and
ones because they all

375
00:20:42,150 --> 00:20:47,460
say whether that assignment
satisfies the formula

376
00:20:47,460 --> 00:20:49,390
or doesn't satisfy the formula.

377
00:20:49,390 --> 00:20:52,810
So the verifier can
check those directly.

378
00:20:52,810 --> 00:20:55,720
Checks each of
those, whether just

379
00:20:55,720 --> 00:20:58,390
by plugging into the
formula and seeing

380
00:20:58,390 --> 00:20:59,890
does it satisfy
the formula or not.

381
00:20:59,890 --> 00:21:02,240
So each one of these
is a 0, 1 value,

382
00:21:02,240 --> 00:21:05,320
which is supposed to correspond
to whether the formula was

383
00:21:05,320 --> 00:21:06,910
satisfied or not.

384
00:21:06,910 --> 00:21:13,540
Those all are correct and
everything else along the way

385
00:21:13,540 --> 00:21:14,380
has been correct.

386
00:21:14,380 --> 00:21:16,090
The verifier is going to accept.

387
00:21:16,090 --> 00:21:21,490
Otherwise if at any point
one of those checks failed,

388
00:21:21,490 --> 00:21:23,590
the verifier has already
rejected or at this point

389
00:21:23,590 --> 00:21:25,590
it just rejects.

390
00:21:25,590 --> 00:21:34,890
So that is the protocol,
the exponential protocol.

391
00:21:34,890 --> 00:21:39,760
And I'm not sure if this
is helpful to you or not,

392
00:21:39,760 --> 00:21:44,050
but I like to think of it sort
of as a tree of possibilities.

393
00:21:44,050 --> 00:21:49,440
So these yellow values are
what the prover is sending.

394
00:21:49,440 --> 00:21:51,870
So the prover first
sends the number

395
00:21:51,870 --> 00:21:53,910
of satisfying
assignments all together.

396
00:21:53,910 --> 00:21:57,600
The verifier in
white is checking--

397
00:21:57,600 --> 00:21:58,920
are doing these checks.

398
00:21:58,920 --> 00:22:00,420
So it checks that it equals k.

399
00:22:00,420 --> 00:22:06,430

400
00:22:06,430 --> 00:22:11,020
And then the prover
sends the next level.

401
00:22:11,020 --> 00:22:14,440
The verifier checks that
the addition works out.

402
00:22:14,440 --> 00:22:19,870
Then the prover
unpacks it further,

403
00:22:19,870 --> 00:22:22,690
assigns values to the
first two variables,

404
00:22:22,690 --> 00:22:27,640
and the verifier checks that
just the assignments, just

405
00:22:27,640 --> 00:22:31,960
a single variable are
consistent with that and so on.

406
00:22:31,960 --> 00:22:37,540
And to assign all m variables
and then it checks directly

407
00:22:37,540 --> 00:22:40,310
with the formula.

408
00:22:40,310 --> 00:22:44,340
Now, what happens--
and here is the case.

409
00:22:44,340 --> 00:22:47,240
It's going to be important
to understand in both here

410
00:22:47,240 --> 00:22:49,280
and in the non Boolean case.

411
00:22:49,280 --> 00:22:55,500
What happens if we had an
incorrect value for the input?

412
00:22:55,500 --> 00:22:58,800
And what I want to show you is
that the prover is going to--

413
00:22:58,800 --> 00:23:01,620
I want to show you
that the verifier is

414
00:23:01,620 --> 00:23:09,310
going to end up rejecting
in this case with certainty.

415
00:23:09,310 --> 00:23:13,130
Later on it's just going to
reject with high probability.

416
00:23:13,130 --> 00:23:16,970
But for this protocol, it's
going to accept with certainty.

417
00:23:16,970 --> 00:23:18,020
And why is that?

418
00:23:18,020 --> 00:23:27,180
Because first of all, if
the prover, if k was wrong,

419
00:23:27,180 --> 00:23:29,940
so I'm indicating the
wrong values in red.

420
00:23:29,940 --> 00:23:34,080
If k was wrong, so it did not
equal the number of satisfying

421
00:23:34,080 --> 00:23:37,680
assignments, if the prover
sends the correct value,

422
00:23:37,680 --> 00:23:40,860
the verifier is just going
to say it doesn't match up.

423
00:23:40,860 --> 00:23:43,050
I reject right away.

424
00:23:43,050 --> 00:23:46,660
So what can the
prover possibly do

425
00:23:46,660 --> 00:23:48,580
to prevent the verifier
from accepting?

426
00:23:48,580 --> 00:23:51,320
You're going to see that
there's nothing you can do.

427
00:23:51,320 --> 00:23:54,620
But later on, there's a chance
that the prover can get lucky.

428
00:23:54,620 --> 00:23:56,690
But here there's
nothing you can do.

429
00:23:56,690 --> 00:24:02,270
Let's try to humor me and see--

430
00:24:02,270 --> 00:24:07,610
let the prover try to manage
to keep the verifier going

431
00:24:07,610 --> 00:24:09,210
as long as possible.

432
00:24:09,210 --> 00:24:12,230
So the prover in order
to prevent the verifier

433
00:24:12,230 --> 00:24:14,180
from rejecting at
the beginning would

434
00:24:14,180 --> 00:24:19,340
have to lie about the number
of satisfying assignments.

435
00:24:19,340 --> 00:24:24,890
But then the prover is
going to say, well, OK,

436
00:24:24,890 --> 00:24:29,377
you're claiming there's only
99 satisfying assignments.

437
00:24:29,377 --> 00:24:31,460
Prover doesn't know what
the right real answer is.

438
00:24:31,460 --> 00:24:34,910
But we know it was
100, let's say.

439
00:24:34,910 --> 00:24:38,710
But let's say k was equal to 99.

440
00:24:38,710 --> 00:24:42,460
The prover claimed it's 99 now.

441
00:24:42,460 --> 00:24:47,650
And so the verifier
says, OK, well, it's 99.

442
00:24:47,650 --> 00:24:48,513
Convince me of that.

443
00:24:48,513 --> 00:24:49,930
So now the prover
is going to have

444
00:24:49,930 --> 00:24:52,360
to say the number of
satisfying assignments for 0

445
00:24:52,360 --> 00:24:54,318
and the number of satisfying
assignments for 1,

446
00:24:54,318 --> 00:24:55,480
they have to add up.

447
00:24:55,480 --> 00:24:58,070
At least one of those
has to be wrong,

448
00:24:58,070 --> 00:25:00,530
because you can't have the
two correct values adding up

449
00:25:00,530 --> 00:25:04,510
to the false value.

450
00:25:04,510 --> 00:25:08,280
So a lie here has to yield
a lie in at least one

451
00:25:08,280 --> 00:25:10,400
of those two places.

452
00:25:10,400 --> 00:25:12,950
And then a lie there
is going to have

453
00:25:12,950 --> 00:25:14,900
to yield a lie in one
of those two places,

454
00:25:14,900 --> 00:25:18,800
just like each lie kind
of forces more lies.

455
00:25:18,800 --> 00:25:21,080
As you know, you're
trying to lie.

456
00:25:21,080 --> 00:25:25,100
The story gets more and
more complicated in order

457
00:25:25,100 --> 00:25:27,960
to try to justify all this.

458
00:25:27,960 --> 00:25:31,260
And so in the end, you're
going to get an inequality.

459
00:25:31,260 --> 00:25:35,015
And the verifier is going
to end up rejecting.

460
00:25:35,015 --> 00:25:36,390
Somewhere along
the line, there's

461
00:25:36,390 --> 00:25:38,310
going to have to
be an inequality,

462
00:25:38,310 --> 00:25:40,680
if not along the way
then at the very end

463
00:25:40,680 --> 00:25:43,790
when the verifier
does the check itself.

464
00:25:43,790 --> 00:25:46,940
Because one of those, you
could trace that down, there's

465
00:25:46,940 --> 00:25:49,040
going to be lies
and lies and lies

466
00:25:49,040 --> 00:25:54,590
and then there's going to
be at the very bottom one

467
00:25:54,590 --> 00:25:57,297
of these values is
going to be wrong.

468
00:25:57,297 --> 00:25:58,880
And when the verifier
checks them all,

469
00:25:58,880 --> 00:26:02,207
it's going to find out that
there is an inequality there.

470
00:26:02,207 --> 00:26:04,040
And so one of those
checks is going to fail.

471
00:26:04,040 --> 00:26:10,415

472
00:26:10,415 --> 00:26:11,790
So I'm getting
one question here.

473
00:26:11,790 --> 00:26:13,498
Why is this any better
than just checking

474
00:26:13,498 --> 00:26:16,830
all possible assignments
without a prover?

475
00:26:16,830 --> 00:26:18,060
It isn't.

476
00:26:18,060 --> 00:26:20,340
The only reason
I'm doing this is

477
00:26:20,340 --> 00:26:28,030
to get us ready for the
arithmetized protocol

478
00:26:28,030 --> 00:26:31,830
where we have non
Boolean values coming in.

479
00:26:31,830 --> 00:26:33,030
So questions on this?

480
00:26:33,030 --> 00:26:39,080
I think it's important
to understand this one.

481
00:26:39,080 --> 00:26:40,940
Don't ask the question why.

482
00:26:40,940 --> 00:26:43,730
The why is just going
to be we are getting

483
00:26:43,730 --> 00:26:45,290
ourselves ready for
something later,

484
00:26:45,290 --> 00:26:47,450
which you don't know yet.

485
00:26:47,450 --> 00:26:51,260
But I want you to understand
it for what it is,

486
00:26:51,260 --> 00:26:53,956
even if it seems
unnecessarily complicated.

487
00:26:53,956 --> 00:26:57,290

488
00:26:57,290 --> 00:27:00,530
OK, so let's keep going.

489
00:27:00,530 --> 00:27:02,560
So how are we going
to fix that protocol

490
00:27:02,560 --> 00:27:03,940
so it's not exponential?

491
00:27:03,940 --> 00:27:07,510
So again, here is a picture
of that exponential protocol.

492
00:27:07,510 --> 00:27:10,540
And we have that
exponential blow

493
00:27:10,540 --> 00:27:12,910
up occurring because
at every stage,

494
00:27:12,910 --> 00:27:15,400
each value is going to be
justified in terms of two

495
00:27:15,400 --> 00:27:18,080
values at the next stage.

496
00:27:18,080 --> 00:27:22,270
So it's going to be
exponentially many values

497
00:27:22,270 --> 00:27:23,720
after a while.

498
00:27:23,720 --> 00:27:26,890
So instead, we're going to
try to justify each value here

499
00:27:26,890 --> 00:27:29,800
in terms of just a single
value at the next stage.

500
00:27:29,800 --> 00:27:32,800

501
00:27:32,800 --> 00:27:34,690
But it's not going to
be good enough just

502
00:27:34,690 --> 00:27:38,430
to pick either the 0
or the 1 at random.

503
00:27:38,430 --> 00:27:40,470
Because it might be each--

504
00:27:40,470 --> 00:27:42,090
there might be just
a single course

505
00:27:42,090 --> 00:27:45,740
of lies going through here.

506
00:27:45,740 --> 00:27:49,790
And the only way you
would be to catch that

507
00:27:49,790 --> 00:27:55,040
would be to guess correctly at
each stage which was the lie.

508
00:27:55,040 --> 00:27:57,778
And then you would
catch it at the end.

509
00:27:57,778 --> 00:27:59,570
If you're just going
to be randomly picking

510
00:27:59,570 --> 00:28:03,580
zeros and ones, you're
not going to have

511
00:28:03,580 --> 00:28:07,910
a high probability of catching
the prover when it's lying.

512
00:28:07,910 --> 00:28:12,250
And so that's not going
to be good enough.

513
00:28:12,250 --> 00:28:16,220
The input might
be the wrong value

514
00:28:16,220 --> 00:28:17,770
and you might have
a prover which

515
00:28:17,770 --> 00:28:23,800
just has one path of lies,
and then your probability,

516
00:28:23,800 --> 00:28:25,600
you would still have
a high probability

517
00:28:25,600 --> 00:28:30,020
of accepting in that case, even
though the input was wrong.

518
00:28:30,020 --> 00:28:31,120
It's not what you want.

519
00:28:31,120 --> 00:28:33,490
When the input is
wrong, you have

520
00:28:33,490 --> 00:28:38,795
to have only a tiny chance, a
very small chance of accepting.

521
00:28:38,795 --> 00:28:40,170
So the way we're
going to achieve

522
00:28:40,170 --> 00:28:42,930
that is by having these--

523
00:28:42,930 --> 00:28:48,600
instead of picking a 0 or a
1 for these random values,

524
00:28:48,600 --> 00:28:52,980
we're going to have non Boolean
assignments to the variables.

525
00:28:52,980 --> 00:28:54,910
And we have to
make sense of that.

526
00:28:54,910 --> 00:28:56,660
And we've already seen
an example of that.

527
00:28:56,660 --> 00:28:58,160
It's going to be
very much the same.

528
00:28:58,160 --> 00:29:01,670

529
00:29:01,670 --> 00:29:03,428
All right.

530
00:29:03,428 --> 00:29:09,070
Are we all together here?

531
00:29:09,070 --> 00:29:11,250
So this is a place
where we could

532
00:29:11,250 --> 00:29:21,460
try, if you have a question,
we can try to answer that.

533
00:29:21,460 --> 00:29:22,410
Are we good?

534
00:29:22,410 --> 00:29:24,240
Let's keep moving.

535
00:29:24,240 --> 00:29:27,660
OK, so how are we going to
arithmetize Boolean formulas?

536
00:29:27,660 --> 00:29:29,940
It's, again, the same
idea we had before.

537
00:29:29,940 --> 00:29:33,180
Simulating ands and ors
with plus and times.

538
00:29:33,180 --> 00:29:35,900
So we had this from
before, same exact picture.

539
00:29:35,900 --> 00:29:37,940
Actually it's even
simpler, because now we're

540
00:29:37,940 --> 00:29:43,040
going to be using the true
simulation of or instead

541
00:29:43,040 --> 00:29:46,040
of some kind of a special
case simulation of

542
00:29:46,040 --> 00:29:49,670
or, which we had in the
branching program case.

543
00:29:49,670 --> 00:29:54,762
So these faithfully
do what and and

544
00:29:54,762 --> 00:30:01,380
or does when you plug in 0
for false and 1 for true.

545
00:30:01,380 --> 00:30:04,910
So that means that we can
take an entire formula

546
00:30:04,910 --> 00:30:06,200
and arithmetize it.

547
00:30:06,200 --> 00:30:09,500
The formula built out of
ands and ors and negations.

548
00:30:09,500 --> 00:30:11,720
And you're going to get a
polynomial that comes out.

549
00:30:11,720 --> 00:30:15,250

550
00:30:15,250 --> 00:30:17,710
And that polynomial, what's
going to be important for us

551
00:30:17,710 --> 00:30:20,800
is not going to be of
extremely high degree.

552
00:30:20,800 --> 00:30:23,350
The actual degree is going
to be at most the length

553
00:30:23,350 --> 00:30:25,870
of the formula in terms of
the number of symbols it has.

554
00:30:25,870 --> 00:30:28,330
You can check that on your own.

555
00:30:28,330 --> 00:30:30,310
But for now you
can just trust me.

556
00:30:30,310 --> 00:30:33,760
The degree of the polynomial,
because it only goes up

557
00:30:33,760 --> 00:30:39,040
during the multiplications,
but the degree doesn't

558
00:30:39,040 --> 00:30:39,700
become too big.

559
00:30:39,700 --> 00:30:46,910

560
00:30:46,910 --> 00:30:48,260
And we're going to be doing--

561
00:30:48,260 --> 00:30:50,450
and I don't want this to
be a confusing issue here.

562
00:30:50,450 --> 00:30:57,215
We're going to be doing--
but we have to be correct.

563
00:30:57,215 --> 00:30:58,590
I don't want to
be cheating here.

564
00:30:58,590 --> 00:31:02,700
So all of the arithmetic is
going to be done in a field.

565
00:31:02,700 --> 00:31:12,840
So we have to do plus and
times mod some number, which

566
00:31:12,840 --> 00:31:15,030
turns out needs to be a
prime number for reasons

567
00:31:15,030 --> 00:31:17,070
I'm not going to get into.

568
00:31:17,070 --> 00:31:18,300
But it doesn't really matter.

569
00:31:18,300 --> 00:31:19,800
It's just modular arithmetic.

570
00:31:19,800 --> 00:31:21,240
And that's one
thing that enables

571
00:31:21,240 --> 00:31:23,880
us to pick random
values in a natural way,

572
00:31:23,880 --> 00:31:26,830
because there's only finitely
many values in the field.

573
00:31:26,830 --> 00:31:29,210
And so you're just going
to pick one at random.

574
00:31:29,210 --> 00:31:33,850
But here we want to
be able to represent--

575
00:31:33,850 --> 00:31:36,790
it's going to be more important
for us to have a larger

576
00:31:36,790 --> 00:31:40,120
field, because we want
to be able to represent

577
00:31:40,120 --> 00:31:42,520
the number of satisfying
assignments which

578
00:31:42,520 --> 00:31:46,000
can be a number between
0 and 2 to the m.

579
00:31:46,000 --> 00:31:48,040
So we have to have a
field which has at least 2

580
00:31:48,040 --> 00:31:52,030
to the m elements in it so
that we can in a sensible way

581
00:31:52,030 --> 00:31:53,230
write down those numbers.

582
00:31:53,230 --> 00:31:57,790

583
00:31:57,790 --> 00:31:59,950
Let's not get
caught up with that.

584
00:31:59,950 --> 00:32:04,870
But we can try to answer those
questions offline if you want.

585
00:32:04,870 --> 00:32:07,990
But just think about
it for this first pass.

586
00:32:07,990 --> 00:32:10,750
We're doing the
arithmetic mod sum prime.

587
00:32:10,750 --> 00:32:14,740

588
00:32:14,740 --> 00:32:21,090
So now we have the same notion
of presets as we had before.

589
00:32:21,090 --> 00:32:26,210
So if we have a formula and
we preset some of the values

590
00:32:26,210 --> 00:32:28,775
but now those values may
be non Boolean values.

591
00:32:28,775 --> 00:32:31,620

592
00:32:31,620 --> 00:32:35,820
We may be plugging in
values for the formula.

593
00:32:35,820 --> 00:32:39,000
Not just zeros and ones, but
we might be plugging in sevens

594
00:32:39,000 --> 00:32:41,340
or 23's or whatever.

595
00:32:41,340 --> 00:32:44,400
And the formula is
going to in order

596
00:32:44,400 --> 00:32:47,430
to have a value,
a meaning to that,

597
00:32:47,430 --> 00:32:49,890
we're going to treat that
formula as the polynomial

598
00:32:49,890 --> 00:32:51,780
from the arithmetization.

599
00:32:51,780 --> 00:32:54,180
And just plug in those
values into the polynomial

600
00:32:54,180 --> 00:32:57,920
and see what the
polynomial does for you.

601
00:32:57,920 --> 00:32:59,620
So here we're going
to be presetting

602
00:32:59,620 --> 00:33:02,270
some of the values of the
formula like we did before.

603
00:33:02,270 --> 00:33:04,750
And now it's going
to be the same thing.

604
00:33:04,750 --> 00:33:06,640
But now in the
polynomial, we're going

605
00:33:06,640 --> 00:33:10,510
to be pre-assigning some of
the values of the variables

606
00:33:10,510 --> 00:33:14,050
to these a's from the field.

607
00:33:14,050 --> 00:33:16,870
And the remaining variables
are going to stay as unset.

608
00:33:16,870 --> 00:33:21,820

609
00:33:21,820 --> 00:33:24,170
Now we have to give
an interpretation.

610
00:33:24,170 --> 00:33:27,210

611
00:33:27,210 --> 00:33:29,325
So the new polynomial here.

612
00:33:29,325 --> 00:33:32,417

613
00:33:32,417 --> 00:33:33,500
So I'm getting a question.

614
00:33:33,500 --> 00:33:35,180
Well, maybe I better take this.

615
00:33:35,180 --> 00:33:39,890
Let me hold off on that
for now what the degree is.

616
00:33:39,890 --> 00:33:47,880

617
00:33:47,880 --> 00:33:51,000
I'll answer the
questions in a second.

618
00:33:51,000 --> 00:33:57,260
So now remember from
before, number phi

619
00:33:57,260 --> 00:33:59,840
was the number of
satisfying assignments when

620
00:33:59,840 --> 00:34:04,438
I preset the first i values.

621
00:34:04,438 --> 00:34:07,740
It no longer makes sense to talk
about satisfying assignments,

622
00:34:07,740 --> 00:34:12,050
because these values may
no longer be Booleans.

623
00:34:12,050 --> 00:34:19,510
So I'm going to have
to write this formally

624
00:34:19,510 --> 00:34:27,380
as I'm going to plug in
those values, those i values,

625
00:34:27,380 --> 00:34:28,969
for the first i variables.

626
00:34:28,969 --> 00:34:34,130
And the remaining are
variables which I have not set.

627
00:34:34,130 --> 00:34:36,350
I'm going to assign
them to zeros and ones

628
00:34:36,350 --> 00:34:37,580
in all possible ways.

629
00:34:37,580 --> 00:34:38,870
Only to zeros and ones.

630
00:34:38,870 --> 00:34:41,449

631
00:34:41,449 --> 00:34:45,112
Because what I want to
have, you might think, well,

632
00:34:45,112 --> 00:34:47,570
why aren't we assigning these
to other values in the field?

633
00:34:47,570 --> 00:34:51,455
Well, because what I'm aiming
at is that if I were to plug

634
00:34:51,455 --> 00:34:57,870
in zeros and ones at this
point into the polynomial,

635
00:34:57,870 --> 00:35:00,750
I'm supposed to get exactly the
same values as I had before,

636
00:35:00,750 --> 00:35:03,390
because I'm simulating
and's and or's.

637
00:35:03,390 --> 00:35:11,820
So I'm just extending the
definition, the evaluation

638
00:35:11,820 --> 00:35:13,320
into a new realm.

639
00:35:13,320 --> 00:35:15,330
But I shouldn't
change the values

640
00:35:15,330 --> 00:35:19,070
on the old Boolean realm.

641
00:35:19,070 --> 00:35:23,540
So I'm going to be adding up the
unassigned, the unset variables

642
00:35:23,540 --> 00:35:25,700
in all possible Boolean ways.

643
00:35:25,700 --> 00:35:30,520
And the first i values
could be non Boolean values.

644
00:35:30,520 --> 00:35:34,980
So you have to just accept
this as an abstract notion.

645
00:35:34,980 --> 00:35:38,478
No longer has an interpretation
as satisfying assignments.

646
00:35:38,478 --> 00:35:41,890

647
00:35:41,890 --> 00:35:43,990
So as I said,
what's important is

648
00:35:43,990 --> 00:35:49,090
that if I happen to put
Boolean values in now,

649
00:35:49,090 --> 00:35:54,790
then phi and number phi
give the same values

650
00:35:54,790 --> 00:35:57,380
as they would have before.

651
00:35:57,380 --> 00:36:02,270
Because the polynomial
acts identically

652
00:36:02,270 --> 00:36:04,715
to the formula on
Boolean values.

653
00:36:04,715 --> 00:36:08,710

654
00:36:08,710 --> 00:36:09,210
OK.

655
00:36:09,210 --> 00:36:11,100
So this is what I'm
repeating what I said.

656
00:36:11,100 --> 00:36:15,820
And there's another point
that also you have to check,

657
00:36:15,820 --> 00:36:20,800
which is that the identities
that we had earlier

658
00:36:20,800 --> 00:36:24,730
that connected up what happens
when I set the first i values

659
00:36:24,730 --> 00:36:30,870
and I set the first i plus
1 values, those still hold.

660
00:36:30,870 --> 00:36:37,200
So if I set the first i values
now to possibly some non

661
00:36:37,200 --> 00:36:40,520
Boolean assignment,
that's what I

662
00:36:40,520 --> 00:36:48,410
get when I extend those values
to one more variable being

663
00:36:48,410 --> 00:36:49,010
assigned.

664
00:36:49,010 --> 00:36:52,160
But I just need to assign
that variable to 0 and to 1

665
00:36:52,160 --> 00:36:53,960
and add those up
because of the way

666
00:36:53,960 --> 00:36:56,250
I've defined things over here.

667
00:36:56,250 --> 00:37:02,030
So I've assigned those variables
to zeros-- the unset variable

668
00:37:02,030 --> 00:37:07,280
to zeros and ones when I'm
defining the number phi

669
00:37:07,280 --> 00:37:09,910
function.

670
00:37:09,910 --> 00:37:13,750
And then lastly, when
I assign everything

671
00:37:13,750 --> 00:37:18,970
now to possibly non Boolean
values, that's going to be--

672
00:37:18,970 --> 00:37:20,890
there's no longer
anything to add up.

673
00:37:20,890 --> 00:37:25,990
So I'm going to get exactly
the same as I got from

674
00:37:25,990 --> 00:37:27,490
before when I--

675
00:37:27,490 --> 00:37:31,330
so assigning number phi
of totally preset input,

676
00:37:31,330 --> 00:37:35,540
it's the same as phi with
a totally preset input.

677
00:37:35,540 --> 00:37:37,910
Because in that case,
there are no variables

678
00:37:37,910 --> 00:37:39,980
left to add up over.

679
00:37:39,980 --> 00:37:41,660
So there's just one.

680
00:37:41,660 --> 00:37:44,480
I just get one single.

681
00:37:44,480 --> 00:37:46,010
I sum it as just
one element in it.

682
00:37:46,010 --> 00:37:48,600

683
00:37:48,600 --> 00:37:53,000
So I got a question
here for earlier.

684
00:37:53,000 --> 00:37:55,670
What happens to the
degrees of the polynomials?

685
00:37:55,670 --> 00:37:58,540

686
00:37:58,540 --> 00:38:01,480
Well, the degree
of number phi is

687
00:38:01,480 --> 00:38:03,730
going to be at most
the degree of phi,

688
00:38:03,730 --> 00:38:05,230
because I'm just
adding things up.

689
00:38:05,230 --> 00:38:06,730
And addition doesn't
change degrees.

690
00:38:06,730 --> 00:38:10,860

691
00:38:10,860 --> 00:38:14,920
As I preset values, the
number of variables goes down,

692
00:38:14,920 --> 00:38:19,320
but the degree may not
necessarily go down.

693
00:38:19,320 --> 00:38:23,210
So the question was I got are
the new polynomials having

694
00:38:23,210 --> 00:38:24,170
lower degrees?

695
00:38:24,170 --> 00:38:27,400
Not necessarily.

696
00:38:27,400 --> 00:38:30,445
They have fewer variables
but not a smaller degree.

697
00:38:30,445 --> 00:38:37,000

698
00:38:37,000 --> 00:38:38,488
So let's do this check.

699
00:38:38,488 --> 00:38:39,280
Let's see if that--

700
00:38:39,280 --> 00:38:42,820

701
00:38:42,820 --> 00:38:46,030
now again, this is I think
I have messed up on this.

702
00:38:46,030 --> 00:38:49,270

703
00:38:49,270 --> 00:38:51,880
Well, there's one
of these that's--

704
00:38:51,880 --> 00:38:55,366

705
00:38:55,366 --> 00:38:57,280
I'll give it away in part.

706
00:38:57,280 --> 00:38:59,950
There's only one of them
that was true anyway.

707
00:38:59,950 --> 00:39:04,090
So you can check the one
that's true according

708
00:39:04,090 --> 00:39:07,000
to the way we've defined it.

709
00:39:07,000 --> 00:39:08,890
So this is a little
bit of a trick question

710
00:39:08,890 --> 00:39:10,695
here, as I'll explain.

711
00:39:10,695 --> 00:39:12,070
But there's only
one of them that

712
00:39:12,070 --> 00:39:15,070
faithfully does
the arithmetization

713
00:39:15,070 --> 00:39:17,830
as I described on this page.

714
00:39:17,830 --> 00:39:20,910
And that's the one
you should check.

715
00:39:20,910 --> 00:39:25,370
So remember, over here
this is the formula.

716
00:39:25,370 --> 00:39:29,770
This is the recipe for how
I'm doing the arithmetization.

717
00:39:29,770 --> 00:39:33,020
This whole process here.

718
00:39:33,020 --> 00:39:37,360
So one of these lines,
one of these, a, b, or c,

719
00:39:37,360 --> 00:39:38,470
corresponds to doing that.

720
00:39:38,470 --> 00:39:42,622

721
00:39:42,622 --> 00:39:43,830
I'm going to close this down.

722
00:39:43,830 --> 00:39:45,450
So are we all in?

723
00:39:45,450 --> 00:39:48,920

724
00:39:48,920 --> 00:39:50,090
Yeah.

725
00:39:50,090 --> 00:39:51,335
So a is the correct answer.

726
00:39:51,335 --> 00:39:55,000

727
00:39:55,000 --> 00:39:58,930
A does the arithmetization
according to the recipe

728
00:39:58,930 --> 00:40:00,430
that I just described.

729
00:40:00,430 --> 00:40:04,030
Because if you look
at x1 or x2, we

730
00:40:04,030 --> 00:40:10,480
can just check it in the very
first part of the polynomial.

731
00:40:10,480 --> 00:40:12,070
x1 or x2.

732
00:40:12,070 --> 00:40:15,142
Well, it's x1 plus x2
minus the product x1 x2.

733
00:40:15,142 --> 00:40:16,600
So you can just
see it right there.

734
00:40:16,600 --> 00:40:19,110
The others don't have that.

735
00:40:19,110 --> 00:40:23,130
And similarly for
x1 bar and x2 bar.

736
00:40:23,130 --> 00:40:25,510
It becomes 1 minus
x1, 1 minus x2,

737
00:40:25,510 --> 00:40:26,760
and then the product of those.

738
00:40:26,760 --> 00:40:29,540

739
00:40:29,540 --> 00:40:35,570
So a is pretty straightforward
as the arithmetization of phi.

740
00:40:35,570 --> 00:40:39,020
Now, in fact, any
of those would work.

741
00:40:39,020 --> 00:40:40,400
I don't want to
confuse you here.

742
00:40:40,400 --> 00:40:43,010
But any of those would have
worked, because they all agree

743
00:40:43,010 --> 00:40:44,612
on the Boolean assignment.

744
00:40:44,612 --> 00:40:46,070
And that's all that
really matters.

745
00:40:46,070 --> 00:40:48,810

746
00:40:48,810 --> 00:40:50,360
So if you have any--

747
00:40:50,360 --> 00:40:52,430
all I care about
is that they agree.

748
00:40:52,430 --> 00:40:55,670
The formula agrees
with the polynomial

749
00:40:55,670 --> 00:40:57,530
and the Boolean
cases, and these all

750
00:40:57,530 --> 00:41:00,890
happen to agree
and zeros and ones.

751
00:41:00,890 --> 00:41:02,330
Doesn't matter though.

752
00:41:02,330 --> 00:41:04,730
I put those there just
in case you tried it

753
00:41:04,730 --> 00:41:07,250
by just substitution
of zeros and ones in.

754
00:41:07,250 --> 00:41:08,990
You might have picked
the wrong thing.

755
00:41:08,990 --> 00:41:11,490

756
00:41:11,490 --> 00:41:11,990
OK.

757
00:41:11,990 --> 00:41:16,160
So let's take a break
here, and then we

758
00:41:16,160 --> 00:41:22,250
will see about how to go
about fixing the protocol

759
00:41:22,250 --> 00:41:25,130
after the break.

760
00:41:25,130 --> 00:41:26,590
All right.

761
00:41:26,590 --> 00:41:28,312
So also happy to
take any questions.

762
00:41:28,312 --> 00:41:29,770
We haven't really
done a whole lot.

763
00:41:29,770 --> 00:41:32,740
We basically, this
has all been review

764
00:41:32,740 --> 00:41:36,070
of what we did last time.

765
00:41:36,070 --> 00:41:41,315
But let me start the timer.

766
00:41:41,315 --> 00:41:45,260

767
00:41:45,260 --> 00:41:46,890
But feel free to ask questions.

768
00:41:46,890 --> 00:41:49,460

769
00:41:49,460 --> 00:41:51,770
I'll tell you where we're going.

770
00:41:51,770 --> 00:41:54,830
This whole proof
really comes down

771
00:41:54,830 --> 00:41:57,710
to understanding
one line, which is

772
00:41:57,710 --> 00:41:59,930
going to be in the second half.

773
00:41:59,930 --> 00:42:02,990

774
00:42:02,990 --> 00:42:04,490
So I'm really kind of--

775
00:42:04,490 --> 00:42:07,070
this is all big
setup here to get

776
00:42:07,070 --> 00:42:09,050
you ready to be able
to understand that one.

777
00:42:09,050 --> 00:42:10,342
I'll tell you when it's coming.

778
00:42:10,342 --> 00:42:14,270
So you won't have to
worry that you'll miss it.

779
00:42:14,270 --> 00:42:17,580
But that line is not
easy to understand.

780
00:42:17,580 --> 00:42:20,810
So I think it's important
to get all of the framework

781
00:42:20,810 --> 00:42:27,110
and all of the context all
set up for you so then you

782
00:42:27,110 --> 00:42:30,860
can understand that line and
hopefully you see that line

783
00:42:30,860 --> 00:42:32,120
and understand it.

784
00:42:32,120 --> 00:42:37,535
OK, so the important fact.

785
00:42:37,535 --> 00:42:42,230

786
00:42:42,230 --> 00:42:42,998
So let's go back.

787
00:42:42,998 --> 00:42:44,540
You wanted to see
the important fact.

788
00:42:44,540 --> 00:42:51,405

789
00:42:51,405 --> 00:42:51,905
OK.

790
00:42:51,905 --> 00:43:01,130

791
00:43:01,130 --> 00:43:02,960
So this is what I
was saying before.

792
00:43:02,960 --> 00:43:08,040

793
00:43:08,040 --> 00:43:14,110
If I plug in Boolean values
into the arithmetization,

794
00:43:14,110 --> 00:43:16,150
I get the same exact
thing as I would

795
00:43:16,150 --> 00:43:19,420
have if I applied the
Boolean operations before I

796
00:43:19,420 --> 00:43:22,320
did the arithmetization.

797
00:43:22,320 --> 00:43:25,400
So plus and times in
the arithmetization

798
00:43:25,400 --> 00:43:30,890
give a faithful simulation
of and and or according

799
00:43:30,890 --> 00:43:35,780
to these little formulas.

800
00:43:35,780 --> 00:43:38,090
That's all I'm saying with this.

801
00:43:38,090 --> 00:43:45,630
And so if I plug in
Boolean values for the a's

802
00:43:45,630 --> 00:43:48,230
I get exactly the same as I
would have gotten before I

803
00:43:48,230 --> 00:43:49,230
did the arithmetization.

804
00:43:49,230 --> 00:43:52,823
Because the arithmetization
is a faithful simulation.

805
00:43:52,823 --> 00:43:53,990
Not sure how else to say it.

806
00:43:53,990 --> 00:43:55,940
Let's see.

807
00:43:55,940 --> 00:43:57,980
What does the or rule now--

808
00:43:57,980 --> 00:44:01,490
why does the or rule now
contain the minus ab term while

809
00:44:01,490 --> 00:44:06,170
the previous instance of
arithmetization didn't?

810
00:44:06,170 --> 00:44:08,000
Remember in the case
of branching programs,

811
00:44:08,000 --> 00:44:14,080
we didn't need the
minus ab term over here.

812
00:44:14,080 --> 00:44:16,740
And that was because we could
argue that it was a disjoint

813
00:44:16,740 --> 00:44:20,200
or in the case of the
branching programs.

814
00:44:20,200 --> 00:44:24,620
I don't want to get confusing by
trying to explain why that was.

815
00:44:24,620 --> 00:44:31,290
But in that earlier case, we
never took an or of two ones.

816
00:44:31,290 --> 00:44:38,160
It was an of 0, 0 or possibly
0, 1 or possibly 1, 0.

817
00:44:38,160 --> 00:44:40,170
So therefore we never
had to deal with a case

818
00:44:40,170 --> 00:44:42,600
when we had an or of a 1, 1.

819
00:44:42,600 --> 00:44:44,910
And here we can have that.

820
00:44:44,910 --> 00:44:47,730
So we have to subtract
off that ab term,

821
00:44:47,730 --> 00:44:49,470
because otherwise we'd have--

822
00:44:49,470 --> 00:44:53,110
if we just had a plus
b, then the 1, 1 case,

823
00:44:53,110 --> 00:44:55,050
we would end up with a 2.

824
00:44:55,050 --> 00:44:57,150
And that would not be
a faithful simulation

825
00:44:57,150 --> 00:45:02,700
of the or operation, because 1
or 1 should be just 1, not 2.

826
00:45:02,700 --> 00:45:04,785
So this is a good question here.

827
00:45:04,785 --> 00:45:06,660
Do all the numbers need
to be zeros and ones?

828
00:45:06,660 --> 00:45:09,210
I'm not sure how negation
would work with larger numbers.

829
00:45:09,210 --> 00:45:12,880

830
00:45:12,880 --> 00:45:15,580
The negation, you just
blindly follow it.

831
00:45:15,580 --> 00:45:22,810
Even though we're going to be
plugging in non Boolean values,

832
00:45:22,810 --> 00:45:24,653
it's going to be 1 minus 7.

833
00:45:24,653 --> 00:45:25,945
So you're going to get minus 6.

834
00:45:25,945 --> 00:45:31,600
You have to do that mod P, mod
Q, whatever that value you get.

835
00:45:31,600 --> 00:45:35,200
But you can no
longer think about it

836
00:45:35,200 --> 00:45:38,720
as negation in the former sense.

837
00:45:38,720 --> 00:45:41,410
Now it just becomes
a formal thing.

838
00:45:41,410 --> 00:45:45,910
You're just plugging along
doing what the polynomial says.

839
00:45:45,910 --> 00:45:47,750
Numbers are coming out.

840
00:45:47,750 --> 00:45:49,263
You think this is just nonsense.

841
00:45:49,263 --> 00:45:51,430
But the thing is it's going
to have a meaning that's

842
00:45:51,430 --> 00:45:52,840
going to be useful to us.

843
00:45:52,840 --> 00:45:54,670
That's what this protocol
is going to show.

844
00:45:54,670 --> 00:45:57,410

845
00:45:57,410 --> 00:46:00,660
So you can't think about
it as negation anymore.

846
00:46:00,660 --> 00:46:03,590
It's just negation
becomes 1 minus x

847
00:46:03,590 --> 00:46:07,020
in the arithmetized
world and you just

848
00:46:07,020 --> 00:46:08,810
have to live with that.

849
00:46:08,810 --> 00:46:09,380
Let's see.

850
00:46:09,380 --> 00:46:16,210

851
00:46:16,210 --> 00:46:17,950
Another question here.

852
00:46:17,950 --> 00:46:21,910
If all the phi are equivalent
for Boolean inputs in the check

853
00:46:21,910 --> 00:46:24,950
in, so this is back
into this check in here,

854
00:46:24,950 --> 00:46:26,050
so if all of the--

855
00:46:26,050 --> 00:46:33,670

856
00:46:33,670 --> 00:46:34,570
yeah.

857
00:46:34,570 --> 00:46:38,260
So the question is if they're
all equivalent in the Boolean

858
00:46:38,260 --> 00:46:42,580
case, why is only a correct?

859
00:46:42,580 --> 00:46:48,500
Because I defined P sub
phi in a particular way.

860
00:46:48,500 --> 00:46:51,160
And so this was the value
you got if you follow

861
00:46:51,160 --> 00:46:53,350
the way I define P sub phi.

862
00:46:53,350 --> 00:46:56,650
The others would work, they just
weren't the way I defined it.

863
00:46:56,650 --> 00:47:01,948

864
00:47:01,948 --> 00:47:02,990
Any other questions here?

865
00:47:02,990 --> 00:47:05,450
We should probably move on.

866
00:47:05,450 --> 00:47:07,490
Can arithmetization be
used in other contexts?

867
00:47:07,490 --> 00:47:13,240

868
00:47:13,240 --> 00:47:15,380
Offhand, I don't know.

869
00:47:15,380 --> 00:47:17,660
There are these two cases
where arithmetization works.

870
00:47:17,660 --> 00:47:21,350
Whether there are other cases
too, I'm actually not sure.

871
00:47:21,350 --> 00:47:23,850
OK, so let's move on.

872
00:47:23,850 --> 00:47:31,180
So our timer is up.

873
00:47:31,180 --> 00:47:33,440
The candle has burned down.

874
00:47:33,440 --> 00:47:33,940
OK.

875
00:47:33,940 --> 00:47:35,680
So this was--

876
00:47:35,680 --> 00:47:37,540
OK, here we go.

877
00:47:37,540 --> 00:47:38,820
This is the real protocol.

878
00:47:38,820 --> 00:47:42,440

879
00:47:42,440 --> 00:47:45,730
So I'm going to present it
to you the way I did before.

880
00:47:45,730 --> 00:47:47,740
Let's think about
it with the case

881
00:47:47,740 --> 00:47:50,470
first where the input
is in the language

882
00:47:50,470 --> 00:47:51,750
and we have an honest prover.

883
00:47:51,750 --> 00:47:55,810

884
00:47:55,810 --> 00:48:00,140
So we start off the same way.

885
00:48:00,140 --> 00:48:06,200
The prover sends phi,
sends number phi.

886
00:48:06,200 --> 00:48:07,747
Which in the old
sense was the number

887
00:48:07,747 --> 00:48:08,830
of satisfying assignments.

888
00:48:08,830 --> 00:48:11,820
It actually still is,
because since we're not

889
00:48:11,820 --> 00:48:15,890
presetting anything, there's
no non Booleans in the picture

890
00:48:15,890 --> 00:48:16,390
yet.

891
00:48:16,390 --> 00:48:18,730
So this is going to be
the same value as before.

892
00:48:18,730 --> 00:48:21,610
The verifier checks that
k equals number phi.

893
00:48:21,610 --> 00:48:24,250
So that's why we have to have
a big enough field there,

894
00:48:24,250 --> 00:48:27,370
so that we can
represent numbers up

895
00:48:27,370 --> 00:48:30,380
to the number of potential
number of satisfying

896
00:48:30,380 --> 00:48:30,880
assignments.

897
00:48:30,880 --> 00:48:33,010
But that's a side note.

898
00:48:33,010 --> 00:48:36,230
But anyway, this is
exactly what we did before.

899
00:48:36,230 --> 00:48:37,830
No change.

900
00:48:37,830 --> 00:48:40,140
The number of satisfying
assignments if you like.

901
00:48:40,140 --> 00:48:41,100
Now, let's just see.

902
00:48:41,100 --> 00:48:42,090
Let's remember.

903
00:48:42,090 --> 00:48:44,760
And this is one of those
cases where not having

904
00:48:44,760 --> 00:48:47,580
a big blackboard hampers us.

905
00:48:47,580 --> 00:48:50,280
So I'm just going to remind
you what we did last time.

906
00:48:50,280 --> 00:48:51,880
But I'm going to change this.

907
00:48:51,880 --> 00:48:55,110
So remember before P sent--

908
00:48:55,110 --> 00:48:57,030
and unpacked at one level.

909
00:48:57,030 --> 00:48:59,640
Sent the number of
satisfying assignments

910
00:48:59,640 --> 00:49:03,360
said number phi of 0
and number phi of 1.

911
00:49:03,360 --> 00:49:05,970
And then we did that
check to justify

912
00:49:05,970 --> 00:49:08,545
the previous value, which the
verifier doesn't necessarily

913
00:49:08,545 --> 00:49:09,045
trust.

914
00:49:09,045 --> 00:49:11,640

915
00:49:11,640 --> 00:49:12,810
OK.

916
00:49:12,810 --> 00:49:14,640
Fasten your
seatbelts, everybody.

917
00:49:14,640 --> 00:49:18,150
This is the whole
proof in the next line.

918
00:49:18,150 --> 00:49:21,630

919
00:49:21,630 --> 00:49:22,545
But it's a doozy.

920
00:49:22,545 --> 00:49:26,960

921
00:49:26,960 --> 00:49:29,930
All right.

922
00:49:29,930 --> 00:49:37,670
P is going to send phi of
z as a polynomial in z.

923
00:49:37,670 --> 00:49:40,070
It's going to send
just a single object.

924
00:49:40,070 --> 00:49:42,290
But that object is
an entire polynomial.

925
00:49:42,290 --> 00:49:44,910

926
00:49:44,910 --> 00:49:46,410
And the way it's
going to send that

927
00:49:46,410 --> 00:49:51,180
is by sending the coefficients
of that polynomial.

928
00:49:51,180 --> 00:50:02,050
So let's digest that statement.

929
00:50:02,050 --> 00:50:08,210
So first of all,
let's understand

930
00:50:08,210 --> 00:50:09,510
the value of doing that.

931
00:50:09,510 --> 00:50:13,070
So if I can send the
entire polynomial phi

932
00:50:13,070 --> 00:50:17,320
sub z represented
as a polynomial,

933
00:50:17,320 --> 00:50:21,715
I can plug in 0 and 1
into that polynomial

934
00:50:21,715 --> 00:50:24,340
and allow the verifier
to do the check

935
00:50:24,340 --> 00:50:32,600
that it needs to
do to demonstrate

936
00:50:32,600 --> 00:50:36,540
that number phi is correct.

937
00:50:36,540 --> 00:50:40,940
So it's going to check that
number phi is number phi of 0

938
00:50:40,940 --> 00:50:43,220
plus number phi of 1.

939
00:50:43,220 --> 00:50:45,290
But instead of getting
those values directly

940
00:50:45,290 --> 00:50:48,890
from the prover, it's going
to take that polynomial it got

941
00:50:48,890 --> 00:50:51,980
and evaluate that
polynomial at 0 and 1.

942
00:50:51,980 --> 00:50:56,040

943
00:50:56,040 --> 00:50:59,840
And just to remember,
let's go back

944
00:50:59,840 --> 00:51:03,200
and remember how we defined--

945
00:51:03,200 --> 00:51:06,620
defined number phi
to make sure that we

946
00:51:06,620 --> 00:51:11,580
understand what it means
to have a polynomial here.

947
00:51:11,580 --> 00:51:16,710
So remember, here we're just
taking the very first value.

948
00:51:16,710 --> 00:51:19,380
But you are OK with
putting a constant 0 or 1

949
00:51:19,380 --> 00:51:24,240
and then adding up over
all possible extensions,

950
00:51:24,240 --> 00:51:27,990
all possible Boolean
extensions to that.

951
00:51:27,990 --> 00:51:32,880
And maybe it's OK to put in a
non Boolean value here, like 7.

952
00:51:32,880 --> 00:51:34,800
And then you take the
remaining variables

953
00:51:34,800 --> 00:51:37,350
and assign them zeros and
ones in all possibilities

954
00:51:37,350 --> 00:51:38,820
and add it up.

955
00:51:38,820 --> 00:51:41,010
Now I'm going to do something
even a little wilder.

956
00:51:41,010 --> 00:51:45,190
I'm going to put in
a variable for a1.

957
00:51:45,190 --> 00:51:51,560
Some symbolic, if you
want, symbolic value.

958
00:51:51,560 --> 00:51:54,070
So I'm going to put
in a value z for a1.

959
00:51:54,070 --> 00:51:56,920
So now I plug in z for a1 here.

960
00:51:56,920 --> 00:52:00,370
And a2 through am are
going to be zeros and ones

961
00:52:00,370 --> 00:52:02,710
in all possible ways.

962
00:52:02,710 --> 00:52:05,280
So I just get a polynomial in z.

963
00:52:05,280 --> 00:52:08,580
The other variables get
assigned and added up

964
00:52:08,580 --> 00:52:10,710
over the various
Boolean assignments.

965
00:52:10,710 --> 00:52:12,510
And now I get some polynomial.

966
00:52:12,510 --> 00:52:14,880
So I get some expression in z.

967
00:52:14,880 --> 00:52:17,310
That's just going to be a
single variable polynomial.

968
00:52:17,310 --> 00:52:21,348

969
00:52:21,348 --> 00:52:22,640
Whose degree is it going to be?

970
00:52:22,640 --> 00:52:26,940
At most the degree
of number phi.

971
00:52:26,940 --> 00:52:28,740
So degree is not
going to be too big.

972
00:52:28,740 --> 00:52:32,470

973
00:52:32,470 --> 00:52:34,440
So it sends the
coefficients so the degree

974
00:52:34,440 --> 00:52:35,512
of that is not too big.

975
00:52:35,512 --> 00:52:37,470
So there are not too many
coefficients to send.

976
00:52:37,470 --> 00:52:43,140

977
00:52:43,140 --> 00:52:45,180
So the coefficients are
in terms of the xi's.

978
00:52:45,180 --> 00:52:45,690
No.

979
00:52:45,690 --> 00:52:47,898
I'm not sure what the mean--
the coefficients are not

980
00:52:47,898 --> 00:52:50,760
in terms-- the xi's
are gone at this point.

981
00:52:50,760 --> 00:52:54,000
The xi's, we've
added up the xi's

982
00:52:54,000 --> 00:52:56,790
being assigned to zeros and
ones in all possible ways.

983
00:52:56,790 --> 00:52:59,608

984
00:52:59,608 --> 00:53:01,150
So there are no
other variables left.

985
00:53:01,150 --> 00:53:04,290
There's only z.

986
00:53:04,290 --> 00:53:07,020
So I'm going to do the
same protocol in a more

987
00:53:07,020 --> 00:53:09,730
pictorial way in a minute.

988
00:53:09,730 --> 00:53:12,150
So you're going to see
this whole thing twice.

989
00:53:12,150 --> 00:53:13,650
But try to get it.

990
00:53:13,650 --> 00:53:15,150
You'll have two
chances to get this.

991
00:53:15,150 --> 00:53:17,160
Try to get it.

992
00:53:17,160 --> 00:53:18,150
Try hard each time.

993
00:53:18,150 --> 00:53:20,880

994
00:53:20,880 --> 00:53:23,660
So I've got send phi of
z as a polynomial in z.

995
00:53:23,660 --> 00:53:26,240
Now, that's going to be
enough for me to figure out

996
00:53:26,240 --> 00:53:29,180
what number phi of 0
and number phi of 1

997
00:53:29,180 --> 00:53:33,710
is, because I plug it
in for 0 and 1 for z.

998
00:53:33,710 --> 00:53:37,880
But now I can figure
out what number phi of 2

999
00:53:37,880 --> 00:53:41,660
is also, because I can plug 2
in for z or number phi of 7.

1000
00:53:41,660 --> 00:53:42,970
I plug 7 in for z.

1001
00:53:42,970 --> 00:53:45,810

1002
00:53:45,810 --> 00:53:49,420
So let's stop here and see
are there other questions.

1003
00:53:49,420 --> 00:53:54,110
So is the size of number phi--

1004
00:53:54,110 --> 00:53:56,660
I don't understand.

1005
00:53:56,660 --> 00:53:59,300
This question about
the size of no phi.

1006
00:53:59,300 --> 00:54:01,280
Is it 2 to the m?

1007
00:54:01,280 --> 00:54:06,830
No, it's not 2 to the m, because
the degree of that polynomial,

1008
00:54:06,830 --> 00:54:12,480
number phi of z, I mean,
it's a very large expression

1009
00:54:12,480 --> 00:54:15,720
if you want to initially--
yes, it's going

1010
00:54:15,720 --> 00:54:17,250
to be an exponentially big sum.

1011
00:54:17,250 --> 00:54:20,940
But the prover adds
it all up for you,

1012
00:54:20,940 --> 00:54:24,810
and you're just going to
have at most a small number

1013
00:54:24,810 --> 00:54:27,600
of coefficients, because
the polynomial is only

1014
00:54:27,600 --> 00:54:29,130
of a certain degree.

1015
00:54:29,130 --> 00:54:33,030
And a polynomial in one
variable of degree d

1016
00:54:33,030 --> 00:54:35,820
has at most d or d plus 1
coefficients to worry about.

1017
00:54:35,820 --> 00:54:40,460
So it's not that many
coefficients as an expression.

1018
00:54:40,460 --> 00:54:44,920
So shouldn't the summation
take 2 to the m time?

1019
00:54:44,920 --> 00:54:46,630
I'm not caring about
the prover's time.

1020
00:54:46,630 --> 00:54:48,830
The prover has a
lot of work to do.

1021
00:54:48,830 --> 00:54:52,600
But the prover sends phi of z.

1022
00:54:52,600 --> 00:54:58,070
So yes, the prover has
an exponential job.

1023
00:54:58,070 --> 00:54:59,230
I don't care.

1024
00:54:59,230 --> 00:55:02,728
The verifier needs to be able
to check it in polynomial time.

1025
00:55:02,728 --> 00:55:05,020
And that checking is going
to, well, we'll have to see.

1026
00:55:05,020 --> 00:55:08,860
How does the verifier know
that that polynomial is right?

1027
00:55:08,860 --> 00:55:11,200
That's a question maybe
you should be asking.

1028
00:55:11,200 --> 00:55:17,270

1029
00:55:17,270 --> 00:55:17,900
Yeah.

1030
00:55:17,900 --> 00:55:19,610
I'm getting lots of
questions about how much time

1031
00:55:19,610 --> 00:55:20,420
the prover needs to take.

1032
00:55:20,420 --> 00:55:22,878
Yeah, the prover is going to
have to spend exponential time

1033
00:55:22,878 --> 00:55:24,480
to figure out that polynomial.

1034
00:55:24,480 --> 00:55:25,767
That's all right.

1035
00:55:25,767 --> 00:55:27,350
We don't care about
the prover's time.

1036
00:55:27,350 --> 00:55:32,470

1037
00:55:32,470 --> 00:55:33,400
Yeah.

1038
00:55:33,400 --> 00:55:36,108
So the summation here is going
to be adding up polynomials.

1039
00:55:36,108 --> 00:55:36,775
That is correct.

1040
00:55:36,775 --> 00:55:40,540

1041
00:55:40,540 --> 00:55:42,970
I'm happy to spend time,
because really here this

1042
00:55:42,970 --> 00:55:44,202
is the whole proof.

1043
00:55:44,202 --> 00:55:45,160
You have to understand.

1044
00:55:45,160 --> 00:55:47,260
Well, we have to
understand why this works.

1045
00:55:47,260 --> 00:55:51,290
But we kind of
understand half of it,

1046
00:55:51,290 --> 00:55:57,530
because knowing that
polynomial is enough to--

1047
00:55:57,530 --> 00:56:02,270
if you could certify that that
was the correct polynomial

1048
00:56:02,270 --> 00:56:07,760
for number phi of z, then
we can use that polynomial

1049
00:56:07,760 --> 00:56:12,130
to confirm the previous
value, what number phi was,

1050
00:56:12,130 --> 00:56:14,980
because you just plug
in zeros and ones for z,

1051
00:56:14,980 --> 00:56:15,970
and you add it up.

1052
00:56:15,970 --> 00:56:19,150

1053
00:56:19,150 --> 00:56:20,978
But now how are we
going to justify

1054
00:56:20,978 --> 00:56:22,270
that the polynomial is correct?

1055
00:56:22,270 --> 00:56:23,978
Because this looks
like even a worse job.

1056
00:56:23,978 --> 00:56:25,780
Now we have a whole
bunch of coefficients

1057
00:56:25,780 --> 00:56:27,770
and have to make sure all of
those coefficients are right.

1058
00:56:27,770 --> 00:56:29,230
And so instead of
just two values,

1059
00:56:29,230 --> 00:56:33,050
now we have d values where d is
the degree of that polynomial,

1060
00:56:33,050 --> 00:56:36,770
which could be at most
the length of the formula.

1061
00:56:36,770 --> 00:56:42,280

1062
00:56:42,280 --> 00:56:44,260
So here is the next idea.

1063
00:56:44,260 --> 00:56:47,930

1064
00:56:47,930 --> 00:56:51,520
So the prover needs to show
that phi of z is correct.

1065
00:56:51,520 --> 00:56:57,130

1066
00:56:57,130 --> 00:57:01,150
The way it's going to do that,
so even before we do that,

1067
00:57:01,150 --> 00:57:06,940
so phi of z is going
to be some polynomial.

1068
00:57:06,940 --> 00:57:09,580
Now, the prover may
be lying, may be

1069
00:57:09,580 --> 00:57:11,290
sending the wrong polynomial.

1070
00:57:11,290 --> 00:57:15,490

1071
00:57:15,490 --> 00:57:17,730
How does the prover
convince the verifier

1072
00:57:17,730 --> 00:57:22,830
that the polynomial is
the right polynomial?

1073
00:57:22,830 --> 00:57:24,960
Well, that seems
like a tough job.

1074
00:57:24,960 --> 00:57:28,450
So what it's going to do
is remember that the--

1075
00:57:28,450 --> 00:57:32,930

1076
00:57:32,930 --> 00:57:37,760
so there is a correct
polynomial that you

1077
00:57:37,760 --> 00:57:39,860
would get by plugging
in to this expression

1078
00:57:39,860 --> 00:57:41,400
for the correct value.

1079
00:57:41,400 --> 00:57:43,220
So there's some
correct polynomial.

1080
00:57:43,220 --> 00:57:48,830
The prover may be sending
some incorrect polynomial.

1081
00:57:48,830 --> 00:57:51,460
So now we have the correct
polynomial and the possibly

1082
00:57:51,460 --> 00:57:54,010
incorrect polynomial.

1083
00:57:54,010 --> 00:57:57,130
And the point is
those two can only

1084
00:57:57,130 --> 00:57:59,650
agree in a small
number of places

1085
00:57:59,650 --> 00:58:05,110
by that fact we proved a couple
of lectures back regarding

1086
00:58:05,110 --> 00:58:06,560
polynomials.

1087
00:58:06,560 --> 00:58:10,840
So two different polynomials
can agree only rarely.

1088
00:58:10,840 --> 00:58:12,790
So what we're going
to do, the way

1089
00:58:12,790 --> 00:58:15,670
the prover is going to justify
that this polynomial was

1090
00:58:15,670 --> 00:58:21,210
the correct one, is by
evaluating it at a random place

1091
00:58:21,210 --> 00:58:24,150
and then demonstrating
that that value you get

1092
00:58:24,150 --> 00:58:27,800
is a correct value.

1093
00:58:27,800 --> 00:58:32,410
If the polynomial was
the wrong polynomial,

1094
00:58:32,410 --> 00:58:34,990
then evaluating it
at a random place

1095
00:58:34,990 --> 00:58:38,560
is probably going to disagree
with the correct polynomial

1096
00:58:38,560 --> 00:58:40,810
at that place, because
they can only agree rarely.

1097
00:58:40,810 --> 00:58:43,780

1098
00:58:43,780 --> 00:58:46,780
So the prover is going
to demonstrate that

1099
00:58:46,780 --> 00:58:52,720
by evaluating that polynomial at
a random place, that value you

1100
00:58:52,720 --> 00:58:54,730
get is going to be
the correct value,

1101
00:58:54,730 --> 00:58:57,740
and it's going to continue
to do that in the way,

1102
00:58:57,740 --> 00:59:00,613
using the same
protocol, as we'll see.

1103
00:59:00,613 --> 00:59:01,780
So that's where we're going.

1104
00:59:01,780 --> 00:59:04,950
So in order to show that
phi of z is correct,

1105
00:59:04,950 --> 00:59:09,150
the verifier now gets to pick
a random value in the field.

1106
00:59:09,150 --> 00:59:13,230
And the prover is going to show
that evaluating that polynomial

1107
00:59:13,230 --> 00:59:16,590
at r1 is correct.

1108
00:59:16,590 --> 00:59:19,530
Remember this looks a lot
like what we had from before

1109
00:59:19,530 --> 00:59:23,310
where we were showing that
number phi of 0 is correct

1110
00:59:23,310 --> 00:59:25,210
and number phi of 1 is correct.

1111
00:59:25,210 --> 00:59:27,570
Now we're trying to show
that number phi of r1,

1112
00:59:27,570 --> 00:59:31,870
this random value from
the field is correct.

1113
00:59:31,870 --> 00:59:34,530
So the way we're going
to do that is now

1114
00:59:34,530 --> 00:59:40,380
by unpacking it one level down.

1115
00:59:40,380 --> 00:59:46,590
And we're going to be using that
identity, because this value

1116
00:59:46,590 --> 00:59:51,270
here is going to be equal
to number phi of r1 comma

1117
00:59:51,270 --> 00:59:55,500
0 plus number phi of r1 comma 1.

1118
00:59:55,500 --> 00:59:57,340
But we don't want to
send both of those.

1119
00:59:57,340 --> 00:59:59,130
So we're going to
send them combined

1120
00:59:59,130 --> 01:00:04,080
into a polynomial of
number phi of r1 of z

1121
01:00:04,080 --> 01:00:05,340
as a polynomial in z.

1122
01:00:05,340 --> 01:00:09,350
This is a new polynomial in z.

1123
01:00:09,350 --> 01:00:13,370
So now if you understood
the previous line,

1124
01:00:13,370 --> 01:00:16,380
then hopefully this one
won't be too hard to swallow.

1125
01:00:16,380 --> 01:00:24,190
Because now we're going to
check the identity, but here

1126
01:00:24,190 --> 01:00:29,200
by evaluating the polynomial
again but one level

1127
01:00:29,200 --> 01:00:31,980
at the next level.

1128
01:00:31,980 --> 01:00:39,060
So this is perhaps a good
place to take questions,

1129
01:00:39,060 --> 01:00:40,660
because this is the--

1130
01:00:40,660 --> 01:00:44,490
this is really what I spent
all the time setting things up

1131
01:00:44,490 --> 01:00:47,910
for so that you would be ready
to get this thing hopefully

1132
01:00:47,910 --> 01:00:49,280
without--

1133
01:00:49,280 --> 01:00:51,770
and hopefully be
able to appreciate it

1134
01:00:51,770 --> 01:00:52,520
and understand it.

1135
01:00:52,520 --> 01:01:01,970

1136
01:01:01,970 --> 01:01:03,710
So I'm not getting questions.

1137
01:01:03,710 --> 01:01:05,310
Let's move on a little further.

1138
01:01:05,310 --> 01:01:11,140
So now again, the
prover had sent

1139
01:01:11,140 --> 01:01:15,520
this polynomial in stage two.

1140
01:01:15,520 --> 01:01:18,370

1141
01:01:18,370 --> 01:01:20,230
Now the verifier
needs to be sure

1142
01:01:20,230 --> 01:01:21,860
that that polynomial is correct.

1143
01:01:21,860 --> 01:01:27,370
So it's going to evaluate
that new polynomial

1144
01:01:27,370 --> 01:01:28,660
at a random location.

1145
01:01:28,660 --> 01:01:31,790

1146
01:01:31,790 --> 01:01:37,050
So by picking a random
value r2 in the field.

1147
01:01:37,050 --> 01:01:42,970
And now we need to show
that this value is correct,

1148
01:01:42,970 --> 01:01:46,330
because if that polynomial
had been the wrong polynomial,

1149
01:01:46,330 --> 01:01:48,970
it disagreed with the correct
polynomial almost everywhere.

1150
01:01:48,970 --> 01:01:51,280
And by picking a
random place, it's

1151
01:01:51,280 --> 01:01:56,060
probably not going to be
the right value and so on.

1152
01:01:56,060 --> 01:02:06,960
Until we get to the end where
we have almost all of the values

1153
01:02:06,960 --> 01:02:11,220
have been picked, and so
we have one last value

1154
01:02:11,220 --> 01:02:12,870
to select a 0 and 1.

1155
01:02:12,870 --> 01:02:15,660
This corresponds to the n-th.

1156
01:02:15,660 --> 01:02:20,310
It would be great if I could put
both pictures on your screen,

1157
01:02:20,310 --> 01:02:22,140
but I can't.

1158
01:02:22,140 --> 01:02:23,730
So this very much
corresponds to what

1159
01:02:23,730 --> 01:02:25,920
happened in the
exponential protocol

1160
01:02:25,920 --> 01:02:32,100
but just along sort of this
arithmetization single path.

1161
01:02:32,100 --> 01:02:38,120
So it checks that
the previous value

1162
01:02:38,120 --> 01:02:42,260
is correct in terms of
expanding it with 0 and 1.

1163
01:02:42,260 --> 01:02:45,710
But again, the 0 and 1 comes
from evaluating the polynomial.

1164
01:02:45,710 --> 01:02:49,040

1165
01:02:49,040 --> 01:02:52,060
And now the verifier
needs to be convinced

1166
01:02:52,060 --> 01:02:54,670
that that polynomial was right.

1167
01:02:54,670 --> 01:02:57,160
So it picks a random
value, but now it

1168
01:02:57,160 --> 01:02:59,200
doesn't rely on
the prover anymore.

1169
01:02:59,200 --> 01:03:10,950
It's going to see whether
that assignment that it gets

1170
01:03:10,950 --> 01:03:14,950
by evaluating the polynomial
with that random value rn

1171
01:03:14,950 --> 01:03:18,510
plugged in is the same as
what I get by evaluating

1172
01:03:18,510 --> 01:03:22,820
the polynomial for
the formula itself

1173
01:03:22,820 --> 01:03:25,850
that the verifier
can do directly.

1174
01:03:25,850 --> 01:03:30,050
Because this is now a
polynomial now just plugging

1175
01:03:30,050 --> 01:03:32,270
into the formula and
using the arithmetization

1176
01:03:32,270 --> 01:03:33,110
to get a value out.

1177
01:03:33,110 --> 01:03:36,350

1178
01:03:36,350 --> 01:03:39,290
So this was the last
line of the identity.

1179
01:03:39,290 --> 01:03:42,740

1180
01:03:42,740 --> 01:03:45,000
We had those two identities.

1181
01:03:45,000 --> 01:03:47,107
So this is the second identity.

1182
01:03:47,107 --> 01:03:48,815
And we had to check
that this is correct.

1183
01:03:48,815 --> 01:03:52,530

1184
01:03:52,530 --> 01:03:54,735
So I'm going to show
this to you in a picture.

1185
01:03:54,735 --> 01:03:58,760

1186
01:03:58,760 --> 01:04:02,880
Not sure it'll help
if you're confused.

1187
01:04:02,880 --> 01:04:05,430
But why don't we take
some questions on this?

1188
01:04:05,430 --> 01:04:07,410
So as I said, I'm
going to give you

1189
01:04:07,410 --> 01:04:09,780
two chances to understand this.

1190
01:04:09,780 --> 01:04:11,790
Because I know it's tough.

1191
01:04:11,790 --> 01:04:13,980
Especially with the
constraints of Zoom,

1192
01:04:13,980 --> 01:04:16,680
this is a particularly
challenging idea to explain.

1193
01:04:16,680 --> 01:04:21,510

1194
01:04:21,510 --> 01:04:22,680
OK, so let's see.

1195
01:04:22,680 --> 01:04:26,790
So the benefit of this approach
is that the prover only

1196
01:04:26,790 --> 01:04:29,490
sends one item for each
depth level instead

1197
01:04:29,490 --> 01:04:30,390
of multiple items.

1198
01:04:30,390 --> 01:04:31,290
That's right.

1199
01:04:31,290 --> 01:04:35,280
But that one item
is the polynomial.

1200
01:04:35,280 --> 01:04:40,700
So that captures all of the
values for the entire field.

1201
01:04:40,700 --> 01:04:43,880
But taking advantage
of the arithmetization,

1202
01:04:43,880 --> 01:04:48,860
that one polynomial has a
lot of information in it.

1203
01:04:48,860 --> 01:04:50,780
And what's nice is
that you can check

1204
01:04:50,780 --> 01:04:53,510
that polynomial by just
evaluating it at one

1205
01:04:53,510 --> 01:04:54,293
random place.

1206
01:04:54,293 --> 01:04:56,210
You can check that that
polynomial is correct.

1207
01:04:56,210 --> 01:05:09,310

1208
01:05:09,310 --> 01:05:11,860
So I'm getting
another question here.

1209
01:05:11,860 --> 01:05:14,150
Where does this come from here?

1210
01:05:14,150 --> 01:05:16,010
V checks that this here.

1211
01:05:16,010 --> 01:05:18,580
So this where does this--

1212
01:05:18,580 --> 01:05:20,860
so you have to look--
to understand where

1213
01:05:20,860 --> 01:05:23,720
this is coming from, you have
to-- we're at the n-th round

1214
01:05:23,720 --> 01:05:24,220
now.

1215
01:05:24,220 --> 01:05:26,320
So you have to look
back like at round two.

1216
01:05:26,320 --> 01:05:30,700
V has to check that
phi of r1, which

1217
01:05:30,700 --> 01:05:34,510
comes from the end
of the first round.

1218
01:05:34,510 --> 01:05:36,820
So this checks
that this phi of r1

1219
01:05:36,820 --> 01:05:42,610
is correct because that was
how we justified the polynomial

1220
01:05:42,610 --> 01:05:44,580
with just a single variable.

1221
01:05:44,580 --> 01:05:48,860
The very first
polynomial was correct.

1222
01:05:48,860 --> 01:05:50,710
A little hard to say.

1223
01:05:50,710 --> 01:05:54,520
But this comes from the
previous round, this guy here.

1224
01:05:54,520 --> 01:06:00,230

1225
01:06:00,230 --> 01:06:02,600
So this is the polynomial
for the current round.

1226
01:06:02,600 --> 01:06:06,410
This is the value from
the previous round.

1227
01:06:06,410 --> 01:06:07,850
All right.

1228
01:06:07,850 --> 01:06:08,840
More questions.

1229
01:06:08,840 --> 01:06:17,060

1230
01:06:17,060 --> 01:06:18,972
So why doesn't this run
in exponential time?

1231
01:06:18,972 --> 01:06:20,180
Another question I'm getting.

1232
01:06:20,180 --> 01:06:22,280
Doesn't V need to check
twice at each layer?

1233
01:06:22,280 --> 01:06:24,650
Yes.

1234
01:06:24,650 --> 01:06:26,420
The verifier needs to check--

1235
01:06:26,420 --> 01:06:29,580

1236
01:06:29,580 --> 01:06:31,920
gets two values,
but those two values

1237
01:06:31,920 --> 01:06:36,040
come from the one polynomial.

1238
01:06:36,040 --> 01:06:38,820
So there's no blow up anymore.

1239
01:06:38,820 --> 01:06:39,528
Those two values.

1240
01:06:39,528 --> 01:06:41,945
Maybe you'll see it in the
picture that I'm going to show.

1241
01:06:41,945 --> 01:06:43,680
So maybe just hold
that question.

1242
01:06:43,680 --> 01:06:45,915
Maybe this will become
clearer in the diagram.

1243
01:06:45,915 --> 01:06:52,717

1244
01:06:52,717 --> 01:06:53,550
So another question.

1245
01:06:53,550 --> 01:06:56,850
Does this work because the
polynomial kind of encodes

1246
01:06:56,850 --> 01:06:59,080
all the possible
values together?

1247
01:06:59,080 --> 01:07:01,080
I think that's sort of true.

1248
01:07:01,080 --> 01:07:03,810
It sort of mixes them all
together into one object.

1249
01:07:03,810 --> 01:07:05,620
Then you have to
check that one object,

1250
01:07:05,620 --> 01:07:08,040
which can be done with this
sort of random probing of it.

1251
01:07:08,040 --> 01:07:17,770

1252
01:07:17,770 --> 01:07:20,020
So this is another good
question that we'll see

1253
01:07:20,020 --> 01:07:21,430
explained in the next slide.

1254
01:07:21,430 --> 01:07:24,040

1255
01:07:24,040 --> 01:07:25,960
So similarly in
attempt one, the prover

1256
01:07:25,960 --> 01:07:31,480
can keep lying by
picking polynomials

1257
01:07:31,480 --> 01:07:33,460
by continuing to
pick polynomials,

1258
01:07:33,460 --> 01:07:35,320
by lying about the polynomials.

1259
01:07:35,320 --> 01:07:38,788
But eventually it's going to get
caught, because this value is

1260
01:07:38,788 --> 01:07:39,955
going to be the wrong value.

1261
01:07:39,955 --> 01:07:42,490

1262
01:07:42,490 --> 01:07:45,160
If the polynomial in the
previous stage and the m

1263
01:07:45,160 --> 01:07:46,750
minus--

1264
01:07:46,750 --> 01:07:49,900
if a polynomial that the
prover sent in the m stage

1265
01:07:49,900 --> 01:07:53,200
is the wrong polynomial,
then you evaluate it,

1266
01:07:53,200 --> 01:07:57,670
you're going to get the
wrong value probably.

1267
01:07:57,670 --> 01:07:59,860
And so then that
wrong value is not

1268
01:07:59,860 --> 01:08:02,620
going to match the
correct value, which

1269
01:08:02,620 --> 01:08:06,670
is you can read off yourself
by reading the formula.

1270
01:08:06,670 --> 01:08:08,560
I think we need to move
on to the next slide.

1271
01:08:08,560 --> 01:08:12,090

1272
01:08:12,090 --> 01:08:13,960
All right.

1273
01:08:13,960 --> 01:08:19,330
So same proof, version
two, but looks different.

1274
01:08:19,330 --> 01:08:20,680
Again, the input is that.

1275
01:08:20,680 --> 01:08:22,720
Here is what the prover sends.

1276
01:08:22,720 --> 01:08:24,790
Here is what the verifier sends.

1277
01:08:24,790 --> 01:08:31,149
I'm going to sort of whimsically
design this as a telephone chat

1278
01:08:31,149 --> 01:08:35,229
where they're sending each other
messages through messaging.

1279
01:08:35,229 --> 01:08:40,450
So the prover sends the
number phi to start off with.

1280
01:08:40,450 --> 01:08:42,380
And then off on the side,
these are the checks

1281
01:08:42,380 --> 01:08:45,160
that the verifier is
going to be doing.

1282
01:08:45,160 --> 01:08:48,540
So here in our first
round of the chat,

1283
01:08:48,540 --> 01:08:51,750
the prover is going
to send phi of z.

1284
01:08:51,750 --> 01:08:55,979
Remember this is
just a polynomial

1285
01:08:55,979 --> 01:08:58,120
in not too many coefficients.

1286
01:08:58,120 --> 01:09:01,380
So it's a polynomial
in one variable.

1287
01:09:01,380 --> 01:09:02,319
The degree is small.

1288
01:09:02,319 --> 01:09:04,960
So there are not too
many coefficients here.

1289
01:09:04,960 --> 01:09:09,090
So this is just pretending this
is what it might look like.

1290
01:09:09,090 --> 01:09:15,430
So from that polynomial, the
verifier can plug in 0 and 1

1291
01:09:15,430 --> 01:09:16,870
and see that that adds up.

1292
01:09:16,870 --> 01:09:19,899

1293
01:09:19,899 --> 01:09:23,140
Now the verifier, to check that
this polynomial is correct,

1294
01:09:23,140 --> 01:09:26,290
it picks a random value to
evaluate this polynomial on.

1295
01:09:26,290 --> 01:09:29,220

1296
01:09:29,220 --> 01:09:31,740
And so now it's going to have
to check that this is correct.

1297
01:09:31,740 --> 01:09:32,907
So this is nothing to check.

1298
01:09:32,907 --> 01:09:37,520
You're just writing this down in
anticipation of the next check.

1299
01:09:37,520 --> 01:09:44,470
Now, the prover to justify
that this value is right,

1300
01:09:44,470 --> 01:09:50,700
that this polynomial is
right, so we evaluate--

1301
01:09:50,700 --> 01:09:55,800
the prover in order to check
that this value is right

1302
01:09:55,800 --> 01:10:01,260
is going to send the
polynomial for the next level.

1303
01:10:01,260 --> 01:10:05,550
Now, we can from that, we
can plug in 0 and 1 for z.

1304
01:10:05,550 --> 01:10:08,250
See if that adds up.

1305
01:10:08,250 --> 01:10:12,090
And now to be sure that
this polynomial is right,

1306
01:10:12,090 --> 01:10:17,800
we evaluate it at a random
place, calculate that value,

1307
01:10:17,800 --> 01:10:28,330
and then have to see that
this value is correct.

1308
01:10:28,330 --> 01:10:31,330
So now we expand to
one level further.

1309
01:10:31,330 --> 01:10:35,330
We take a polynomial
for the next variable.

1310
01:10:35,330 --> 01:10:37,720
And we see that adds up.

1311
01:10:37,720 --> 01:10:44,060
OK, I'm not sure whether
this is helping or not.

1312
01:10:44,060 --> 01:10:45,970
But we keep doing
that until we get

1313
01:10:45,970 --> 01:10:50,970
to the very last round with a
prover sending a polynomial.

1314
01:10:50,970 --> 01:10:54,210
Make sure that this
adds up correctly.

1315
01:10:54,210 --> 01:10:58,840
And the verifier to see that
this polynomial is right

1316
01:10:58,840 --> 01:11:05,260
picks a random value and
evaluates it and now checks

1317
01:11:05,260 --> 01:11:07,690
that this agrees
with the formula.

1318
01:11:07,690 --> 01:11:10,190
Because we've now assigned
all of the variables.

1319
01:11:10,190 --> 01:11:13,870
And then we can check
this number phi directly

1320
01:11:13,870 --> 01:11:19,120
in terms of the phi,
because they have to agree.

1321
01:11:19,120 --> 01:11:22,310
And so the verifier would
accept if everything checks out.

1322
01:11:22,310 --> 01:11:23,600
Let's see what happens.

1323
01:11:23,600 --> 01:11:25,810
So this answer will
answer some questions.

1324
01:11:25,810 --> 01:11:29,400

1325
01:11:29,400 --> 01:11:36,120
Why don't I walk through what
happens if the input was wrong.

1326
01:11:36,120 --> 01:11:41,160
And we'll see how
the verifier is

1327
01:11:41,160 --> 01:11:44,280
likely to catch the prover
but not guaranteed to catch

1328
01:11:44,280 --> 01:11:45,285
the prover in this case.

1329
01:11:45,285 --> 01:11:48,540

1330
01:11:48,540 --> 01:11:50,990
So if k was correct,
the verifier

1331
01:11:50,990 --> 01:11:53,000
will accept with
the honest prover.

1332
01:11:53,000 --> 01:11:55,740
But if k was wrong,
so I'm going to,

1333
01:11:55,740 --> 01:11:57,900
again, indicate the
wrong values in red.

1334
01:11:57,900 --> 01:12:00,510

1335
01:12:00,510 --> 01:12:03,210
I want to show you that the
verifier is almost certainly

1336
01:12:03,210 --> 01:12:07,370
going to accept
but not guaranteed.

1337
01:12:07,370 --> 01:12:11,170
So did I say that wrong?

1338
01:12:11,170 --> 01:12:14,558
So if k is wrong, the verifier
is going to probably reject,

1339
01:12:14,558 --> 01:12:15,975
but it's not
guaranteed to reject.

1340
01:12:15,975 --> 01:12:18,800

1341
01:12:18,800 --> 01:12:22,810
So first of all, if the
prover does not lie,

1342
01:12:22,810 --> 01:12:25,080
does not send the wrong
value for number phi,

1343
01:12:25,080 --> 01:12:26,830
The verifier is certainly
going to reject,

1344
01:12:26,830 --> 01:12:28,960
because it's not going
to get any quality there.

1345
01:12:28,960 --> 01:12:31,540

1346
01:12:31,540 --> 01:12:34,010
So the prover has to lie.

1347
01:12:34,010 --> 01:12:39,530
Say if k was 99 but
the real value was

1348
01:12:39,530 --> 01:12:42,830
100, the prover if it
says 100, the verifier's

1349
01:12:42,830 --> 01:12:44,040
going to reject immediately.

1350
01:12:44,040 --> 01:12:47,390
So the prover's
going to say, well,

1351
01:12:47,390 --> 01:12:53,990
let's see what the prover can do
to make the verifier hopefully

1352
01:12:53,990 --> 01:12:56,310
accept from the
prover's standpoint.

1353
01:12:56,310 --> 01:12:58,250
So the prover is
going to send 99.

1354
01:12:58,250 --> 01:13:01,100
Well, the verifier
says, OK, 99, fine.

1355
01:13:01,100 --> 01:13:01,910
Convince me.

1356
01:13:01,910 --> 01:13:06,290
So the prover-- now one of
these two is going to be wrong.

1357
01:13:06,290 --> 01:13:08,860

1358
01:13:08,860 --> 01:13:11,110
Because the two correct
values can't add up

1359
01:13:11,110 --> 01:13:12,170
to the wrong value.

1360
01:13:12,170 --> 01:13:13,240
So one of these is wrong.

1361
01:13:13,240 --> 01:13:17,820
So that means the prover had
to send the wrong polynomial.

1362
01:13:17,820 --> 01:13:20,940
Because the correct polynomial
would evaluate the correct

1363
01:13:20,940 --> 01:13:21,580
answers here.

1364
01:13:21,580 --> 01:13:24,130
So the prover had to send
the wrong polynomial.

1365
01:13:24,130 --> 01:13:26,820
So now when we evaluate
it at a random place,

1366
01:13:26,820 --> 01:13:30,860
chances are this is going to
be the wrong-- this is not

1367
01:13:30,860 --> 01:13:33,360
going to be the same value that
the correct polynomial would

1368
01:13:33,360 --> 01:13:35,330
have given you.

1369
01:13:35,330 --> 01:13:37,850
The prover could get lucky.

1370
01:13:37,850 --> 01:13:39,620
The verifier might
have just happened

1371
01:13:39,620 --> 01:13:42,200
to pick a place where
the correct polynomial

1372
01:13:42,200 --> 01:13:44,420
and the incorrect
polynomial agree.

1373
01:13:44,420 --> 01:13:48,080
In that place, the prover
will think, huh, I'm saved.

1374
01:13:48,080 --> 01:13:52,850
Now I can act like the honest
prover from this point on

1375
01:13:52,850 --> 01:13:57,340
and the verifier
will never catch me.

1376
01:13:57,340 --> 01:14:00,230
It's sort of a little bit
analogous to the situation

1377
01:14:00,230 --> 01:14:00,730
maybe--

1378
01:14:00,730 --> 01:14:03,610

1379
01:14:03,610 --> 01:14:06,770
I'm trying to see if you really
studied the whole course.

1380
01:14:06,770 --> 01:14:10,360
So I'm giving you an exam by
picking sort of random places

1381
01:14:10,360 --> 01:14:11,020
there.

1382
01:14:11,020 --> 01:14:16,690
But maybe you just studied
a few facts from the course.

1383
01:14:16,690 --> 01:14:17,560
You might get lucky.

1384
01:14:17,560 --> 01:14:20,290
I might happen to ask
just about those facts.

1385
01:14:20,290 --> 01:14:23,590
And then you give the appearance
of having studied everything,

1386
01:14:23,590 --> 01:14:25,120
but you really didn't.

1387
01:14:25,120 --> 01:14:28,180
So here the prover might
send the wrong polynomial,

1388
01:14:28,180 --> 01:14:30,030
but the verifier
just queries that

1389
01:14:30,030 --> 01:14:32,050
at the place where
it happens to agree

1390
01:14:32,050 --> 01:14:34,870
with the correct polynomial,
and the prover just gets lucky.

1391
01:14:34,870 --> 01:14:37,180
And the verifier is going
to accept, in that case.

1392
01:14:37,180 --> 01:14:39,140
But there are very few of those.

1393
01:14:39,140 --> 01:14:41,890
So that's why the prover
is almost certainly

1394
01:14:41,890 --> 01:14:44,110
to be caught if it tries to lie.

1395
01:14:44,110 --> 01:14:47,570
But not guaranteed.

1396
01:14:47,570 --> 01:14:50,920
So just tracing this down.

1397
01:14:50,920 --> 01:14:54,940
If this was a lie, then one
of those two has to be a lie.

1398
01:14:54,940 --> 01:14:57,970
So therefore, the next
polynomial has to be a lie.

1399
01:14:57,970 --> 01:14:58,878
And so we continue.

1400
01:14:58,878 --> 01:15:01,420
So then the next value is almost
certainly going to be a lie.

1401
01:15:01,420 --> 01:15:02,590
Not guaranteed.

1402
01:15:02,590 --> 01:15:06,210
And so then one of those
two values has to be a lie.

1403
01:15:06,210 --> 01:15:08,700
At least one has to be a lie.

1404
01:15:08,700 --> 01:15:14,903
Therefore, the polynomial has
to be a lie and so on until--

1405
01:15:14,903 --> 01:15:17,070
unless the prover got lucky
along the way somewhere,

1406
01:15:17,070 --> 01:15:18,720
which is very unlikely,
even though it

1407
01:15:18,720 --> 01:15:21,120
has a several opportunities.

1408
01:15:21,120 --> 01:15:24,510
We've arranged it so that
the chance of getting lucky

1409
01:15:24,510 --> 01:15:26,290
is tiny at each stage.

1410
01:15:26,290 --> 01:15:27,840
So even though he
has a few chances,

1411
01:15:27,840 --> 01:15:29,965
there's still going to be
a tiny chance that you're

1412
01:15:29,965 --> 01:15:31,320
going to get lucky somewhere.

1413
01:15:31,320 --> 01:15:35,980
And so this is wrong, then
chances are that's wrong.

1414
01:15:35,980 --> 01:15:38,850
And so therefore, this is
going to be a disagreement.

1415
01:15:38,850 --> 01:15:42,480
And the verifier at that
point when it doesn't agree

1416
01:15:42,480 --> 01:15:44,323
is going to reject.

1417
01:15:44,323 --> 01:15:46,490
Unless the prover got lucky
somewhere along the way,

1418
01:15:46,490 --> 01:15:48,460
which is unlikely.

1419
01:15:48,460 --> 01:15:53,040
So I don't know if you had--

1420
01:15:53,040 --> 01:15:56,337
so that's all I was going
to say about this proof.

1421
01:15:56,337 --> 01:15:58,170
I don't know if you had
any questions on it,

1422
01:15:58,170 --> 01:16:00,990
but let's just see.

1423
01:16:00,990 --> 01:16:01,490
OK.

1424
01:16:01,490 --> 01:16:07,840
So do we have any
questions I can answer?

1425
01:16:07,840 --> 01:16:10,170
How the prover gets--

1426
01:16:10,170 --> 01:16:13,800
how does a prover get number--

1427
01:16:13,800 --> 01:16:16,740
how does the prover
get number phi of z?

1428
01:16:16,740 --> 01:16:22,430

1429
01:16:22,430 --> 01:16:23,510
So you have to--

1430
01:16:23,510 --> 01:16:27,680
why is number phi of z
have no other variables?

1431
01:16:27,680 --> 01:16:29,900
You have to go back and
look at the definition

1432
01:16:29,900 --> 01:16:32,480
of number phi of a.

1433
01:16:32,480 --> 01:16:35,760
Because you add up over
all the other variables.

1434
01:16:35,760 --> 01:16:38,940
So now instead of a, we're
plugging a variable for that.

1435
01:16:38,940 --> 01:16:41,310
But you're still adding up
over the other variables.

1436
01:16:41,310 --> 01:16:48,230
So this is a function in just
one variable, because it--

1437
01:16:48,230 --> 01:16:50,210
the original thing
was a polynomial.

1438
01:16:50,210 --> 01:16:53,060
This is also going
to be polynomial.

1439
01:16:53,060 --> 01:16:55,140
I think we're starting
to run low on time.

1440
01:16:55,140 --> 01:16:59,910
So this is our very last check
in for the semester here.

1441
01:16:59,910 --> 01:17:05,580
So of course there's one
natural question to ask you all.

1442
01:17:05,580 --> 01:17:08,580
And for our very last
check in, as we're

1443
01:17:08,580 --> 01:17:11,790
in our last couple of minutes
of the course or at least

1444
01:17:11,790 --> 01:17:17,500
the lectures, does P equal NP?

1445
01:17:17,500 --> 01:17:18,325
What do you think?

1446
01:17:18,325 --> 01:17:24,660

1447
01:17:24,660 --> 01:17:29,520
Will maybe PB equal NPB solved
by a deep learning algorithm?

1448
01:17:29,520 --> 01:17:33,050
Or maybe we'll never prove it.

1449
01:17:33,050 --> 01:17:35,060
Give me your best guess.

1450
01:17:35,060 --> 01:17:37,020
We're kind of
running out of time.

1451
01:17:37,020 --> 01:17:41,470
So let's not think
too hard here.

1452
01:17:41,470 --> 01:17:42,760
Another five seconds.

1453
01:17:42,760 --> 01:17:46,850

1454
01:17:46,850 --> 01:17:47,350
All right.

1455
01:17:47,350 --> 01:17:49,900
Ending polling.

1456
01:17:49,900 --> 01:17:52,070
I'll share that with you.

1457
01:17:52,070 --> 01:17:53,540
Oh, I did share.

1458
01:17:53,540 --> 01:17:54,440
So what did we get?

1459
01:17:54,440 --> 01:17:55,850
D here.

1460
01:17:55,850 --> 01:17:59,310
We will prove it in somewhere
between 20 and 100 years

1461
01:17:59,310 --> 01:17:59,810
from now.

1462
01:17:59,810 --> 01:18:01,655
That seems to be the
majority opinion.

1463
01:18:01,655 --> 01:18:04,460

1464
01:18:04,460 --> 01:18:06,460
I don't know.

1465
01:18:06,460 --> 01:18:09,430
I hope it'll be sooner
than that, because I'd

1466
01:18:09,430 --> 01:18:10,520
like to see the answer.

1467
01:18:10,520 --> 01:18:11,770
But we don't know.

1468
01:18:11,770 --> 01:18:15,670

1469
01:18:15,670 --> 01:18:18,940
Yeah, if you can prove
P different from NP,

1470
01:18:18,940 --> 01:18:20,020
I'll give you an A+.

1471
01:18:20,020 --> 01:18:21,395
You won't have to
take the final.

1472
01:18:21,395 --> 01:18:24,160
But you better be
sure you're right.

1473
01:18:24,160 --> 01:18:24,790
All right.

1474
01:18:24,790 --> 01:18:27,850
So that is our quick review.

1475
01:18:27,850 --> 01:18:32,140
We finished number set in
IP and therefore that coNP

1476
01:18:32,140 --> 01:18:35,410
is a subset of IP.

1477
01:18:35,410 --> 01:18:39,010
If you're interested in further
pursuit of this material,

1478
01:18:39,010 --> 01:18:40,690
I got a couple of
questions on that.

1479
01:18:40,690 --> 01:18:44,890
These are some courses
you may want to look at.

1480
01:18:44,890 --> 01:18:47,980
I know I checked
with Ryan Williams.

1481
01:18:47,980 --> 01:18:53,680
He's planning to teach
Advanced Complexity fall 2021.

1482
01:18:53,680 --> 01:18:59,140
So that's going to be the
most natural follow-on subject

1483
01:18:59,140 --> 01:19:00,440
to this one.

1484
01:19:00,440 --> 01:19:02,650
There's the crypto
classes also are

1485
01:19:02,650 --> 01:19:05,025
kind of make use of
some of the same ideas.

1486
01:19:05,025 --> 01:19:07,150
And there's, of course,
also randomness computation

1487
01:19:07,150 --> 01:19:09,205
that Ronitt Rubinfeld teaches.

1488
01:19:09,205 --> 01:19:10,330
If I didn't check with her.

1489
01:19:10,330 --> 01:19:12,788
I'm not sure the next time
she's going to be teaching that.

1490
01:19:12,788 --> 01:19:15,710

1491
01:19:15,710 --> 01:19:22,912
And good luck on the
final and best wishes.

1492
01:19:22,912 --> 01:19:24,370
And I'm going to
have office hours.

1493
01:19:24,370 --> 01:19:29,320
So if you have any questions,
happy to answer those.

1494
01:19:29,320 --> 01:19:32,480
But otherwise, see you all.

1495
01:19:32,480 --> 01:19:33,005
Good luck.

1496
01:19:33,005 --> 01:19:35,705

1497
01:19:35,705 --> 01:19:36,830
Thank you for the comments.

1498
01:19:36,830 --> 01:19:39,280
Yeah, I enjoyed having
you all as students.

1499
01:19:39,280 --> 01:19:41,000
It was a fun time.

1500
01:19:41,000 --> 01:19:43,780
A lot of work, but
it was a fun time.

1501
01:19:43,780 --> 01:19:46,720
I've always been intrigued
by the P versus NP problem,

1502
01:19:46,720 --> 01:19:48,580
and I proved a kind of a--

1503
01:19:48,580 --> 01:19:53,490

1504
01:19:53,490 --> 01:19:56,490
I proved the
exponential complexity

1505
01:19:56,490 --> 01:20:00,210
of computing the parity
function in a certain weak model

1506
01:20:00,210 --> 01:20:01,350
of computation.

1507
01:20:01,350 --> 01:20:06,690
So parity function is obviously
very trivial function.

1508
01:20:06,690 --> 01:20:12,610
But for the parity function,
if you can't count,

1509
01:20:12,610 --> 01:20:15,040
whatever that means,
but there is a model

1510
01:20:15,040 --> 01:20:17,980
you can kind of set up
where you can't count.

1511
01:20:17,980 --> 01:20:23,020
Then parity requires
exponential complexity.

1512
01:20:23,020 --> 01:20:25,480
And surprisingly,
not easy to prove.

1513
01:20:25,480 --> 01:20:30,010
But that's probably the theorem
that I'm most known for.

1514
01:20:30,010 --> 01:20:30,640
Anyway.

1515
01:20:30,640 --> 01:20:34,912
But that would be a
topic for another day.

1516
01:20:34,912 --> 01:20:35,620
Another question.

1517
01:20:35,620 --> 01:20:40,918
Why not include
Myhill-Nerode theorem.

1518
01:20:40,918 --> 01:20:41,460
I don't know.

1519
01:20:41,460 --> 01:20:43,200
That's a theorem
about finite automata

1520
01:20:43,200 --> 01:20:45,420
and all of those ways
of characterizing

1521
01:20:45,420 --> 01:20:46,620
the regular languages.

1522
01:20:46,620 --> 01:20:48,930
That seems kind of
a technical theorem.

1523
01:20:48,930 --> 01:20:51,990
I don't see much
point in covering it.

1524
01:20:51,990 --> 01:20:54,510
And another question that
some of my colleagues

1525
01:20:54,510 --> 01:20:57,000
ask me is why don't I
have Rice's theorem, which

1526
01:20:57,000 --> 01:20:58,620
sort of provides a
kind of a machine

1527
01:20:58,620 --> 01:21:00,600
for proving undecidability.

1528
01:21:00,600 --> 01:21:02,730
And I don't know.

1529
01:21:02,730 --> 01:21:06,940
I think that you can use Rice's
theorem without understanding

1530
01:21:06,940 --> 01:21:08,680
how to prove undecidability.

1531
01:21:08,680 --> 01:21:12,000

1532
01:21:12,000 --> 01:21:15,650
It's like checking off a box.

1533
01:21:15,650 --> 01:21:18,770
Checking some boxes and then you
conclude something's undecided.

1534
01:21:18,770 --> 01:21:21,830
I'd rather have
somebody understand it

1535
01:21:21,830 --> 01:21:23,900
rather than be able to
use some powerful tool.

1536
01:21:23,900 --> 01:21:27,720

1537
01:21:27,720 --> 01:21:30,630
Can we understand that
proof about the parity

1538
01:21:30,630 --> 01:21:33,530
function that I just alluded to?

1539
01:21:33,530 --> 01:21:36,518
It's super hard.

1540
01:21:36,518 --> 01:21:38,685
With the knowledge from
this class, I think you can.

1541
01:21:38,685 --> 01:21:41,780

1542
01:21:41,780 --> 01:21:45,440
That theorem relies
on a certain technique

1543
01:21:45,440 --> 01:21:49,310
which we didn't cover called
the probabilistic method, which

1544
01:21:49,310 --> 01:21:51,260
is a kind of an amazing method.

1545
01:21:51,260 --> 01:21:54,500
Not hard to explain,
but basically you

1546
01:21:54,500 --> 01:21:56,900
show that something
exists by showing

1547
01:21:56,900 --> 01:22:01,750
that the probability
that a random object has

1548
01:22:01,750 --> 01:22:05,585
the property you're
looking for is more than 0.

1549
01:22:05,585 --> 01:22:07,210
And so therefore,
the thing that you're

1550
01:22:07,210 --> 01:22:09,210
looking for that has that
property has to exist.

1551
01:22:09,210 --> 01:22:11,863

1552
01:22:11,863 --> 01:22:13,780
There are lots of examples
of that these days.

1553
01:22:13,780 --> 01:22:15,920
But it's kind of
an amazing method.

1554
01:22:15,920 --> 01:22:17,500
So we use that method.

1555
01:22:17,500 --> 01:22:19,990
Do I think quantum computing
can solve useful problems

1556
01:22:19,990 --> 01:22:22,758
beyond the capability
of computers?

1557
01:22:22,758 --> 01:22:24,300
I have no idea
whether one can really

1558
01:22:24,300 --> 01:22:25,470
build a quantum computer.

1559
01:22:25,470 --> 01:22:27,510
It seems to be always
20 years off at least

1560
01:22:27,510 --> 01:22:28,960
to doing one that factors.

1561
01:22:28,960 --> 01:22:32,640
And I've been literally
I remember people

1562
01:22:32,640 --> 01:22:34,470
20 years ago saying
it's 20 years off.

1563
01:22:34,470 --> 01:22:38,530
So I don't think
it's converging.

1564
01:22:38,530 --> 01:22:41,350
I'm skeptical that they'll ever
build a quantum computer that

1565
01:22:41,350 --> 01:22:42,010
can factor.

1566
01:22:42,010 --> 01:22:44,230
I'll go out on a
limb and say that.

1567
01:22:44,230 --> 01:22:45,954
But that's controversial.

1568
01:22:45,954 --> 01:22:49,372

1569
01:22:49,372 --> 01:22:51,330
And whether it can solve
other useful problems,

1570
01:22:51,330 --> 01:22:53,413
I'm not sure what other
useful problems are there.

1571
01:22:53,413 --> 01:22:55,620
Well, I guess they're
simulating quantum systems.

1572
01:22:55,620 --> 01:22:57,500
So maybe that might be possible.

1573
01:22:57,500 --> 01:23:00,600

1574
01:23:00,600 --> 01:23:01,100
All right.

1575
01:23:01,100 --> 01:23:06,370
I think I'm going
to end this now.

1576
01:23:06,370 --> 01:23:09,440
But thank you, everybody.

1577
01:23:09,440 --> 01:23:09,940
Take care.

1578
01:23:09,940 --> 01:23:11,610
Bye bye.

1579
01:23:11,610 --> 01:23:29,000

