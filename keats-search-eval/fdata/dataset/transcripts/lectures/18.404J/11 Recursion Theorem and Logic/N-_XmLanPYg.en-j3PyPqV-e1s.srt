1
00:00:00,000 --> 00:00:03,944
[SQUEAKING][RUSTLING][CLICKING]

2
00:00:03,944 --> 00:00:25,190

3
00:00:25,190 --> 00:00:27,800
MICHAEL SIPSER: So we are--

4
00:00:27,800 --> 00:00:31,830
welcome back, everybody.

5
00:00:31,830 --> 00:00:39,300
And we are going to
continue our discussion

6
00:00:39,300 --> 00:00:46,050
of computability theory,
Turing machines, and how

7
00:00:46,050 --> 00:00:51,100
to prove things undecidable,
which is what we've been doing.

8
00:00:51,100 --> 00:00:54,480
So we talked about this
more advanced method

9
00:00:54,480 --> 00:00:56,820
of proving things undecidable
last lecture, called

10
00:00:56,820 --> 00:01:01,260
the computation history
method, which comes up

11
00:01:01,260 --> 00:01:06,900
in all sorts of proofs of
undecidability, usually more

12
00:01:06,900 --> 00:01:08,220
complex ones.

13
00:01:08,220 --> 00:01:13,193
Such as, for example, the
proof of Hilbert's 10th problem

14
00:01:13,193 --> 00:01:14,610
that I mentioned,
whether you want

15
00:01:14,610 --> 00:01:19,170
to-- if you want to test
whether a polynomial has

16
00:01:19,170 --> 00:01:23,220
a solution in integers.

17
00:01:23,220 --> 00:01:25,710
It's a reduction from
ATM, just like we've

18
00:01:25,710 --> 00:01:26,850
been doing all along.

19
00:01:26,850 --> 00:01:29,160
All of those proofs are
pretty much reductional

20
00:01:29,160 --> 00:01:30,690
from something undecidable.

21
00:01:30,690 --> 00:01:35,730
This reduction from ATM is as
good a starting point as any.

22
00:01:35,730 --> 00:01:40,360
And it uses the
computation history method.

23
00:01:40,360 --> 00:01:43,200
So what they end up doing
is, given a Turing machine

24
00:01:43,200 --> 00:01:46,600
and an input, you
construct a polynomial

25
00:01:46,600 --> 00:01:48,460
that has several variables.

26
00:01:48,460 --> 00:01:54,930
And where in order to
get an integer root,

27
00:01:54,930 --> 00:01:58,470
an integer solution
of that polynomial,

28
00:01:58,470 --> 00:02:00,600
one of the variables
is going to have

29
00:02:00,600 --> 00:02:03,780
to be assigned to
some kind of encoding

30
00:02:03,780 --> 00:02:09,600
of a computation history of
the Turing machine of M on w.

31
00:02:09,600 --> 00:02:14,280
One of those variables is going
to be a computation history--

32
00:02:14,280 --> 00:02:19,320
an integer which represents the
computation history for m on W.

33
00:02:19,320 --> 00:02:22,770
And the other
variables are there

34
00:02:22,770 --> 00:02:25,260
to help you kind
of decode that so

35
00:02:25,260 --> 00:02:29,590
that the polynomial can actually
check and make a solution.

36
00:02:29,590 --> 00:02:31,540
It becomes a solution
if that actually

37
00:02:31,540 --> 00:02:35,048
is a legitimate computation
history of m on W.

38
00:02:35,048 --> 00:02:37,090
So it really uses the very
same method that we've

39
00:02:37,090 --> 00:02:42,310
been using all along,
but it's pretty hairy

40
00:02:42,310 --> 00:02:47,170
to construct that polynomial
and do the check in the way

41
00:02:47,170 --> 00:02:48,830
that you need to do.

42
00:02:48,830 --> 00:02:50,420
So for the Post
Correspondence problem

43
00:02:50,420 --> 00:02:53,380
which we introduced last
time, doing the check

44
00:02:53,380 --> 00:02:55,400
is relatively simple.

45
00:02:55,400 --> 00:03:00,010
You know that the match is
the computation history,

46
00:03:00,010 --> 00:03:03,190
and following the
rules of the match,

47
00:03:03,190 --> 00:03:08,230
it's fairly simple to construct
that Post Correspondence

48
00:03:08,230 --> 00:03:09,260
problem instance.

49
00:03:09,260 --> 00:03:12,460
We talked about linearly
bounded automata.

50
00:03:12,460 --> 00:03:15,700
Of course, we defined
configurations and computation

51
00:03:15,700 --> 00:03:18,400
histories along the way and
proved certain problem--

52
00:03:18,400 --> 00:03:22,940
other problems are undecidable
as well using the same method.

53
00:03:22,940 --> 00:03:28,100
OK, so today, we're
going to shift gears.

54
00:03:28,100 --> 00:03:30,380
We're going to--
in our last lecture

55
00:03:30,380 --> 00:03:35,070
on the computability
section of the course,

56
00:03:35,070 --> 00:03:37,820
we're going to talk about
something called the recursion

57
00:03:37,820 --> 00:03:44,060
theorem, which basically gives
Turing machines the ability

58
00:03:44,060 --> 00:03:45,410
to refer to themselves.

59
00:03:45,410 --> 00:03:47,630
Turing machines in
any program, to do

60
00:03:47,630 --> 00:03:50,090
self-reference so
that you can actually

61
00:03:50,090 --> 00:03:52,400
get at the code of
the Turing machine

62
00:03:52,400 --> 00:03:55,160
or the code of the program
that you're writing.

63
00:03:55,160 --> 00:03:59,523
Even if that's not a built-in
primitive of the programming

64
00:03:59,523 --> 00:04:01,940
language or the operating
system that you're working with,

65
00:04:01,940 --> 00:04:04,410
it still gives you that access.

66
00:04:04,410 --> 00:04:06,660
And also, we're going to--
if we have time at the end,

67
00:04:06,660 --> 00:04:09,243
I'm going to talk a little bit
about mathematical logic, which

68
00:04:09,243 --> 00:04:11,630
is sort of a nice application
of the recursion theorem.

69
00:04:11,630 --> 00:04:13,910
And it's a beautiful
subject on its own.

70
00:04:13,910 --> 00:04:16,519
And it's something that I can
give a brief introduction to.

71
00:04:16,519 --> 00:04:24,850
OK, so today's topic is
about self-reference,

72
00:04:24,850 --> 00:04:28,540
self-reproducing machines,
and the broader topic

73
00:04:28,540 --> 00:04:31,270
called the recursion theorem.

74
00:04:31,270 --> 00:04:34,210
So let me introduce it
with what I would call

75
00:04:34,210 --> 00:04:37,190
the self-reproduction paradox.

76
00:04:37,190 --> 00:04:43,775
And that is, suppose you have
a factory, like a Tesla effect

77
00:04:43,775 --> 00:04:46,280
or a car manufacturing factory.

78
00:04:46,280 --> 00:04:48,980

79
00:04:48,980 --> 00:04:52,430
See, there's a picture
of the factory,

80
00:04:52,430 --> 00:04:55,160
and it's producing cars.

81
00:04:55,160 --> 00:04:56,590
All right?

82
00:04:56,590 --> 00:04:58,870
So we have a factory
that makes cars.

83
00:04:58,870 --> 00:05:07,690
And what can we say about the
relative complexity of the cars

84
00:05:07,690 --> 00:05:10,375
compared with the factory,
in some informal sense?

85
00:05:10,375 --> 00:05:13,370

86
00:05:13,370 --> 00:05:15,610
So I would argue
that you would be

87
00:05:15,610 --> 00:05:21,460
reasonable to say that the
complexity of the factory

88
00:05:21,460 --> 00:05:26,200
is going to have to be greater
than the complexity of the cars

89
00:05:26,200 --> 00:05:28,250
that it makes.

90
00:05:28,250 --> 00:05:30,590
Because not only
does the factory

91
00:05:30,590 --> 00:05:32,420
have to know how
to make the cars,

92
00:05:32,420 --> 00:05:34,130
so it has to have
all the instructions

93
00:05:34,130 --> 00:05:36,410
and whatever things
that go into a car,

94
00:05:36,410 --> 00:05:42,695
it has to be included in
at least some kind of--

95
00:05:42,695 --> 00:05:47,030
it has to be, in some sense,
represented in the factory.

96
00:05:47,030 --> 00:05:51,480
But the factory also has
to have other stuff--

97
00:05:51,480 --> 00:05:56,460
the robots, and the other
manufacturing items,

98
00:05:56,460 --> 00:05:59,100
tools, and so on--
for making the cars.

99
00:05:59,100 --> 00:06:02,460
So the factory has to
have all the complexity

100
00:06:02,460 --> 00:06:06,100
of a car incorporated
plus other things as well.

101
00:06:06,100 --> 00:06:09,030
And for that reason,
one could imagine

102
00:06:09,030 --> 00:06:15,250
that the factory's complexity is
more than the car's complexity.

103
00:06:15,250 --> 00:06:18,610
But now, suppose you want
to have a factory that

104
00:06:18,610 --> 00:06:21,093
makes factories--

105
00:06:21,093 --> 00:06:22,385
so imagine here's the picture--

106
00:06:22,385 --> 00:06:25,370

107
00:06:25,370 --> 00:06:29,360
or in general, a machine
that makes copies of itself.

108
00:06:29,360 --> 00:06:35,900
Well, that seems, at first
glance, to be impossible.

109
00:06:35,900 --> 00:06:39,650
Because not only does
the factory obviously

110
00:06:39,650 --> 00:06:42,860
have to have all of the
instructions for what

111
00:06:42,860 --> 00:06:47,960
a factory is like, but it needs
to have all of the extra things

112
00:06:47,960 --> 00:06:49,790
that it would need to
do the manufacturing.

113
00:06:49,790 --> 00:06:52,340

114
00:06:52,340 --> 00:06:55,610
And so for that reason,
it seems like it's not

115
00:06:55,610 --> 00:07:00,980
possible to have a machine
make copies of itself.

116
00:07:00,980 --> 00:07:04,190
I mean, you would run
into the very same problem

117
00:07:04,190 --> 00:07:08,660
if I asked you to
produce a program

118
00:07:08,660 --> 00:07:14,330
in your favorite language
that prints out itself--

119
00:07:14,330 --> 00:07:17,450
an exact copy of the same code.

120
00:07:17,450 --> 00:07:19,340
You can always write
a program which

121
00:07:19,340 --> 00:07:23,150
is going to print out some
string, like Hello, world.

122
00:07:23,150 --> 00:07:25,640
That's easy because you
just put Hello, world

123
00:07:25,640 --> 00:07:32,000
into some kind of a variable
or some sort of a table

124
00:07:32,000 --> 00:07:34,710
into the program and
say print that table.

125
00:07:34,710 --> 00:07:40,730
But if you want the program
to print out a copy of itself,

126
00:07:40,730 --> 00:07:44,000
you can't take the whole program
and stick that into a table

127
00:07:44,000 --> 00:07:48,050
because the program
is going to have

128
00:07:48,050 --> 00:07:50,090
to be bigger than the table.

129
00:07:50,090 --> 00:07:53,240
And so, you're going to
end up with something

130
00:07:53,240 --> 00:07:54,620
impossible happening.

131
00:07:54,620 --> 00:07:57,710
Because the program-- an
entire copy of the program

132
00:07:57,710 --> 00:08:00,890
can't fit inside the program.

133
00:08:00,890 --> 00:08:05,240
You just get the program
inside itself, inside itself,

134
00:08:05,240 --> 00:08:07,050
inside itself, forever.

135
00:08:07,050 --> 00:08:11,010
And so, you end up with an
infinite program that way.

136
00:08:11,010 --> 00:08:16,350
So if you just kind of
naively approach the problem

137
00:08:16,350 --> 00:08:17,850
for how to make a
program which is

138
00:08:17,850 --> 00:08:22,390
going to print out a copy of
itself, it's not so easy to do.

139
00:08:22,390 --> 00:08:25,900
But hopefully, after
today's lecture,

140
00:08:25,900 --> 00:08:29,770
you will see that it is possible
and in fact, how to do it.

141
00:08:29,770 --> 00:08:35,250
And not only that is an
idle bit of curiosity,

142
00:08:35,250 --> 00:08:37,530
but there are
actually applications

143
00:08:37,530 --> 00:08:39,960
for why you might want
to do that, mainly

144
00:08:39,960 --> 00:08:45,000
within mathematics and in
computer science theory.

145
00:08:45,000 --> 00:08:47,890
But there's even a kind of
a real-world application,

146
00:08:47,890 --> 00:08:49,697
if you will, in a way too.

147
00:08:49,697 --> 00:08:51,030
So we'll get to that at the end.

148
00:08:51,030 --> 00:08:54,130

149
00:08:54,130 --> 00:08:56,620
So it seems, as I'm
saying, impossible to have

150
00:08:56,620 --> 00:08:57,910
a self-reproducing machine.

151
00:08:57,910 --> 00:09:00,820
But we know that
in the world, there

152
00:09:00,820 --> 00:09:06,290
are things that make copies
of themselves-- living things.

153
00:09:06,290 --> 00:09:09,220
So it seems like a paradox.

154
00:09:09,220 --> 00:09:12,430
Cells can make copies
exactly of themselves.

155
00:09:12,430 --> 00:09:15,230
All living things can
make copies of themselves.

156
00:09:15,230 --> 00:09:19,720
So how do they manage to
get around this paradox?

157
00:09:19,720 --> 00:09:24,370
Well, in fact, it is no
paradox because it is possible

158
00:09:24,370 --> 00:09:27,610
to make a machine
that self-reproduces,

159
00:09:27,610 --> 00:09:29,000
that makes copies of itself.

160
00:09:29,000 --> 00:09:32,830
And this has been
known for many years.

161
00:09:32,830 --> 00:09:35,860
Probably, it goes
back to Von Neumann

162
00:09:35,860 --> 00:09:40,280
who wrote a famous paper on
self-reproducing machines.

163
00:09:40,280 --> 00:09:43,475
OK, so self-reproducing
machines are, in fact, possible.

164
00:09:43,475 --> 00:09:47,140

165
00:09:47,140 --> 00:09:48,880
So let me give you
an example of how

166
00:09:48,880 --> 00:09:51,010
you would make a
self-reproducing Turing

167
00:09:51,010 --> 00:09:52,360
machine.

168
00:09:52,360 --> 00:09:54,460
What do we mean by that?

169
00:09:54,460 --> 00:09:55,810
I mean a machine--

170
00:09:55,810 --> 00:09:58,190
I'm going to call it SELF--

171
00:09:58,190 --> 00:10:01,150
which ignores its input.

172
00:10:01,150 --> 00:10:05,950
So on any input, you turn it
on, the machine grinds around

173
00:10:05,950 --> 00:10:10,330
for a while, and halts with
a description of itself

174
00:10:10,330 --> 00:10:11,740
on the tape--

175
00:10:11,740 --> 00:10:14,500
with the description
of SELF, its own code,

176
00:10:14,500 --> 00:10:16,060
sitting on the tape.

177
00:10:16,060 --> 00:10:19,330
So very much like
producing a program which

178
00:10:19,330 --> 00:10:24,670
would print out its own code,
that's really what we're doing.

179
00:10:24,670 --> 00:10:27,280

180
00:10:27,280 --> 00:10:29,230
So for that, we're
going to first need

181
00:10:29,230 --> 00:10:31,790
a little lemma, which
is a very simple lemma,

182
00:10:31,790 --> 00:10:35,780
but it looks worse than it is.

183
00:10:35,780 --> 00:10:38,530
So let me just
read it out to you,

184
00:10:38,530 --> 00:10:40,210
and then I'll explain
what its saying.

185
00:10:40,210 --> 00:10:43,640
Because what it's saying
is extremely simple.

186
00:10:43,640 --> 00:10:45,370
So there's a
computable function,

187
00:10:45,370 --> 00:10:47,600
I'm going to call
it q, that maps

188
00:10:47,600 --> 00:10:52,470
strings to strings, which
will take any string,

189
00:10:52,470 --> 00:10:58,155
w, and produce from w a Turing
machine which will print w.

190
00:10:58,155 --> 00:11:01,040

191
00:11:01,040 --> 00:11:01,540
OK?

192
00:11:01,540 --> 00:11:02,350
That's all it does.

193
00:11:02,350 --> 00:11:05,440
So as you know, if I
give you a string, w,

194
00:11:05,440 --> 00:11:07,330
you could produce
a Turing machine

195
00:11:07,330 --> 00:11:12,790
which would have w
represented in the states

196
00:11:12,790 --> 00:11:14,500
and transitions of the machine.

197
00:11:14,500 --> 00:11:19,120
So that if you turn the machine
on, the machine will output w.

198
00:11:19,120 --> 00:11:22,930
If I want you to give
me a Turing machine that

199
00:11:22,930 --> 00:11:26,950
prints the string 1, 1, 0, 1 on
the tape, you could do that--

200
00:11:26,950 --> 00:11:28,720
I hope.

201
00:11:28,720 --> 00:11:31,900
And no matter what that
string was, instead of 1, 1,

202
00:11:31,900 --> 00:11:38,560
0, 0, or whatever, it's
20 0's and then five 1's,

203
00:11:38,560 --> 00:11:40,120
you could do that too.

204
00:11:40,120 --> 00:11:44,140
And in fact, there's
a simple procedure

205
00:11:44,140 --> 00:11:46,900
that takes a string
and maps that

206
00:11:46,900 --> 00:11:51,090
onto a Turing machine which
prints out that string.

207
00:11:51,090 --> 00:11:58,710
So that's a computable function,
which basically takes a string

208
00:11:58,710 --> 00:12:04,050
and converts it to something
that evaluates to that string.

209
00:12:04,050 --> 00:12:06,303
And I'm calling it q.

210
00:12:06,303 --> 00:12:08,220
I don't know if this is
helpful to you or not.

211
00:12:08,220 --> 00:12:12,480
It's kind of like it converts
the string w to w in quotes.

212
00:12:12,480 --> 00:12:17,380
So q stands for
quotes, in a way.

213
00:12:17,380 --> 00:12:23,360
So if that's helpful, then good.

214
00:12:23,360 --> 00:12:26,680
But anyway, Pw is
a Turing machine.

215
00:12:26,680 --> 00:12:32,580
When you turn it on, it
just prints out w and halts.

216
00:12:32,580 --> 00:12:34,740
And I can find Pw from w--

217
00:12:34,740 --> 00:12:37,630

218
00:12:37,630 --> 00:12:40,060
straightforward proof.

219
00:12:40,060 --> 00:12:43,300
So now, I'm going to
tell you, assuming

220
00:12:43,300 --> 00:12:51,420
that we have that
computable function, q,

221
00:12:51,420 --> 00:12:55,970
I'm going to tell you how
to make this machine SELF.

222
00:12:55,970 --> 00:12:57,620
And it's not complicated.

223
00:12:57,620 --> 00:13:00,320

224
00:13:00,320 --> 00:13:04,570
The Turing machine
SELF is going to have

225
00:13:04,570 --> 00:13:07,330
two parts I'll call
A and B. Here's

226
00:13:07,330 --> 00:13:09,710
a schematic for the machine.

227
00:13:09,710 --> 00:13:10,960
So here's SELF.

228
00:13:10,960 --> 00:13:12,970
It's in two parts A and B.

229
00:13:12,970 --> 00:13:16,750
And what I mean by A and B,
it's like two separate teams.

230
00:13:16,750 --> 00:13:19,120
SELF is going to
start out running A,

231
00:13:19,120 --> 00:13:22,090
and when A is finished, it's
going to pass control to B.

232
00:13:22,090 --> 00:13:23,860
And then B is going
to finish the job.

233
00:13:23,860 --> 00:13:26,320
And when it's done, you're
going to have the description

234
00:13:26,320 --> 00:13:29,790
SELF sitting here on the tape.

235
00:13:29,790 --> 00:13:31,580
All right?

236
00:13:31,580 --> 00:13:38,060
So what's left is to give
you the code for A and for B.

237
00:13:38,060 --> 00:13:43,820
So A is going to be
something super simple.

238
00:13:43,820 --> 00:13:48,950
A is going to be that
machine which prints out B--

239
00:13:48,950 --> 00:13:52,040
prints out a description
of B. The one

240
00:13:52,040 --> 00:13:54,940
that I described up here.

241
00:13:54,940 --> 00:14:00,450
So remember, Pw is the
machine which prints out w.

242
00:14:00,450 --> 00:14:03,360
And P sub the description
of B is simply

243
00:14:03,360 --> 00:14:08,610
going to machine that has
this string, PB, stored

244
00:14:08,610 --> 00:14:10,540
in its states and transitions.

245
00:14:10,540 --> 00:14:13,110
You turn on that machine,
and it prints out B,

246
00:14:13,110 --> 00:14:15,180
and then it's done.

247
00:14:15,180 --> 00:14:16,310
So this is a very simple--

248
00:14:16,310 --> 00:14:17,760
A is very simple.

249
00:14:17,760 --> 00:14:29,040
So here, PB is a part of
A. And when it's done,

250
00:14:29,040 --> 00:14:30,390
B appears on the tape.

251
00:14:30,390 --> 00:14:34,510
So that's at the point when
A has finished its work.

252
00:14:34,510 --> 00:14:37,340
Now it's going to
pass control to B.

253
00:14:37,340 --> 00:14:40,190
So we're not obviously done
yet, because what we want

254
00:14:40,190 --> 00:14:42,450
is A and B both
to be on the tape,

255
00:14:42,450 --> 00:14:45,030
not just B. Because SELF
is a combination of A and B

256
00:14:45,030 --> 00:14:45,530
together.

257
00:14:45,530 --> 00:14:48,860

258
00:14:48,860 --> 00:14:53,920
So I have to tell you how
B works to finish the job.

259
00:14:53,920 --> 00:14:56,860

260
00:14:56,860 --> 00:15:02,370
So you might think,
as a first, given

261
00:15:02,370 --> 00:15:04,890
what we did for
getting B on the tape,

262
00:15:04,890 --> 00:15:07,530
that we'll get A on the
tape in the same way,

263
00:15:07,530 --> 00:15:16,570
by putting a copy of A inside
B. So a copy of B is inside A,

264
00:15:16,570 --> 00:15:21,230
and a copy of A is inside B.

265
00:15:21,230 --> 00:15:23,540
And at some
conceptual level, that

266
00:15:23,540 --> 00:15:24,950
seems like that
might do the job.

267
00:15:24,950 --> 00:15:26,090
But it's really not--

268
00:15:26,090 --> 00:15:28,470
that is not a solution.

269
00:15:28,470 --> 00:15:32,880
Because the fact that I
can put B inside A kind of

270
00:15:32,880 --> 00:15:34,478
forbids me from also
putting A inside

271
00:15:34,478 --> 00:15:36,270
P, because that's going
to be the same kind

272
00:15:36,270 --> 00:15:38,580
of circular reasoning
of just putting

273
00:15:38,580 --> 00:15:39,948
a machine inside itself.

274
00:15:39,948 --> 00:15:41,490
You just can't do
that because you're

275
00:15:41,490 --> 00:15:43,110
going to end up with an
infinitely big machine

276
00:15:43,110 --> 00:15:43,610
that way.

277
00:15:43,610 --> 00:15:46,140

278
00:15:46,140 --> 00:15:50,166
In fact, if I'm
putting B inside A--

279
00:15:50,166 --> 00:15:53,702
a copy of B in terms of
its description inside A, A

280
00:15:53,702 --> 00:15:55,410
is really going to be
much bigger than B.

281
00:15:55,410 --> 00:15:59,510
Because it has all of B with
inside it, plus other stuff--

282
00:15:59,510 --> 00:16:03,360
all the states and transitions
for printing that B out.

283
00:16:03,360 --> 00:16:05,730
So I can't have the A
be much bigger than B

284
00:16:05,730 --> 00:16:07,560
and then B also
much bigger than A.

285
00:16:07,560 --> 00:16:11,632
So this is no good.

286
00:16:11,632 --> 00:16:13,340
We're going to have
to do something else.

287
00:16:13,340 --> 00:16:17,030

288
00:16:17,030 --> 00:16:19,810
So how is B now going
to get ahold of A?

289
00:16:19,810 --> 00:16:24,690

290
00:16:24,690 --> 00:16:31,960
And the trick for doing
that, without having

291
00:16:31,960 --> 00:16:35,410
a copy of A inside B--
which doesn't work.

292
00:16:35,410 --> 00:16:37,450
That's not going to
be a good solution.

293
00:16:37,450 --> 00:16:39,670
Instead, the way that
B is going to get A,

294
00:16:39,670 --> 00:16:41,230
it's going to figure
out what A is.

295
00:16:41,230 --> 00:16:44,890
It's going to figure
out what A is.

296
00:16:44,890 --> 00:16:47,470
And how is it going to
figure out what A is?

297
00:16:47,470 --> 00:16:53,900
Because if you remember, B can
now look can look at the tape.

298
00:16:53,900 --> 00:16:55,925
It sees some string
there which happens

299
00:16:55,925 --> 00:16:58,050
to be a description of
itself, but it doesn't care.

300
00:16:58,050 --> 00:17:00,170
It sees some string on the tape.

301
00:17:00,170 --> 00:17:02,840
A is the machine that
prints out that string.

302
00:17:02,840 --> 00:17:07,790

303
00:17:07,790 --> 00:17:10,445
A is q of this string.

304
00:17:10,445 --> 00:17:15,130

305
00:17:15,130 --> 00:17:19,089
So B is simply going to
compute q of whatever it

306
00:17:19,089 --> 00:17:21,089
sees on the tape.

307
00:17:21,089 --> 00:17:28,230
That is A. OK?

308
00:17:28,230 --> 00:17:29,760
So I don't know if you can read.

309
00:17:29,760 --> 00:17:31,320
That's kind of small here.

310
00:17:31,320 --> 00:17:34,920
It's going to compute A
from B sitting on the tape.

311
00:17:34,920 --> 00:17:36,780
So here is the
instructions for B.

312
00:17:36,780 --> 00:17:40,740
It's going to compute q of
the tape contents, which

313
00:17:40,740 --> 00:17:43,050
happens to be the
description of B.

314
00:17:43,050 --> 00:17:45,390
But that's irrelevant
to B. B just sees

315
00:17:45,390 --> 00:17:46,770
some string on the tape.

316
00:17:46,770 --> 00:17:51,300
It computes q of
that, and that is A.

317
00:17:51,300 --> 00:17:55,940
Because A is the machine
which prints out that string.

318
00:17:55,940 --> 00:17:59,750
Then it's going to
combine A with B,

319
00:17:59,750 --> 00:18:02,600
doing whatever
slight interfacing

320
00:18:02,600 --> 00:18:03,830
that needs to happen--

321
00:18:03,830 --> 00:18:06,760
I'm not going to get
into those details--

322
00:18:06,760 --> 00:18:10,700
to convert those two
pieces into one machine,

323
00:18:10,700 --> 00:18:14,200
which is the machine SELF.

324
00:18:14,200 --> 00:18:16,810
And then it's going to print out
with SELF on the tape, as I'm

325
00:18:16,810 --> 00:18:17,977
going to indicate over here.

326
00:18:17,977 --> 00:18:22,080

327
00:18:22,080 --> 00:18:23,040
OK?

328
00:18:23,040 --> 00:18:27,960
So that's how a
Turing machine can

329
00:18:27,960 --> 00:18:30,720
print out a copy of
its own description

330
00:18:30,720 --> 00:18:31,770
and leave it on the tape.

331
00:18:31,770 --> 00:18:34,988

332
00:18:34,988 --> 00:18:36,530
And what's nice
about this is nothing

333
00:18:36,530 --> 00:18:37,950
specific about Turing machines.

334
00:18:37,950 --> 00:18:42,890
This is a general
procedure that allows

335
00:18:42,890 --> 00:18:45,560
any programming
language to print out

336
00:18:45,560 --> 00:18:46,550
a copy of its own code.

337
00:18:46,550 --> 00:18:49,400
You can even carry
this out in English,

338
00:18:49,400 --> 00:18:50,990
as I'm going to do
in the next slide.

339
00:18:50,990 --> 00:18:55,990

340
00:18:55,990 --> 00:18:57,967
OK, so here's a good question.

341
00:18:57,967 --> 00:18:59,800
There are many possible
Turing machines that

342
00:18:59,800 --> 00:19:02,410
can print out B. That's right.

343
00:19:02,410 --> 00:19:04,810
How do I know how to
get the particular one?

344
00:19:04,810 --> 00:19:06,640
What I have in mind,
that's a little bit

345
00:19:06,640 --> 00:19:08,995
of a subtle question,
but it's a good question.

346
00:19:08,995 --> 00:19:12,210

347
00:19:12,210 --> 00:19:15,960
I have in mind the
particular Turing machine

348
00:19:15,960 --> 00:19:19,470
that prints out B, which
is the one that q produces.

349
00:19:19,470 --> 00:19:22,180

350
00:19:22,180 --> 00:19:25,150
Remember, so we have to
refer back to this lemma.

351
00:19:25,150 --> 00:19:27,970
This lemma produces
a particular machine

352
00:19:27,970 --> 00:19:32,350
that prints out B from B.

353
00:19:32,350 --> 00:19:35,193
And that's the one that
I'm going to use for A,

354
00:19:35,193 --> 00:19:36,610
and that's the one
that B is going

355
00:19:36,610 --> 00:19:41,020
to be able to obtain by running
the q algorithm to figure out

356
00:19:41,020 --> 00:19:41,860
what A is.

357
00:19:41,860 --> 00:19:44,183
So you have to make sure
you're being consistent then.

358
00:19:44,183 --> 00:19:46,600
That's a little bit of a detail,
but it's a good question.

359
00:19:46,600 --> 00:19:49,590

360
00:19:49,590 --> 00:19:51,870
And why doesn't this create
a circular argument too?

361
00:19:51,870 --> 00:19:53,820
Well, so that was
another question

362
00:19:53,820 --> 00:19:55,510
I'm seeing here on the tape.

363
00:19:55,510 --> 00:19:57,810
Well, there's no
longer anything-- see,

364
00:19:57,810 --> 00:20:01,500
B does not have to have
A stored within it.

365
00:20:01,500 --> 00:20:03,240
It figures out A.

366
00:20:03,240 --> 00:20:06,975
So in a sense, you're going
to write the code for B first.

367
00:20:06,975 --> 00:20:09,620

368
00:20:09,620 --> 00:20:10,850
B is just a simple program.

369
00:20:10,850 --> 00:20:11,503
Here it is.

370
00:20:11,503 --> 00:20:12,920
There's nothing
circular about it.

371
00:20:12,920 --> 00:20:15,380
It says B is a
simple-- the code for B

372
00:20:15,380 --> 00:20:20,400
is, take a look at the
tape, compute q of that,

373
00:20:20,400 --> 00:20:23,220
combine the result with
whatever was sitting on the tape

374
00:20:23,220 --> 00:20:26,950
from before, and print it out.

375
00:20:26,950 --> 00:20:30,160
I mean, that's a piece of
code which you can just write.

376
00:20:30,160 --> 00:20:32,488
This will become more
clear, hopefully,

377
00:20:32,488 --> 00:20:34,030
in our next slide
where we talk about

378
00:20:34,030 --> 00:20:35,770
the English implementation.

379
00:20:35,770 --> 00:20:39,780
But just, I don't
want to rush to that.

380
00:20:39,780 --> 00:20:43,920
So you could figure out B
without even knowing what A is.

381
00:20:43,920 --> 00:20:45,760
B stands alone.

382
00:20:45,760 --> 00:20:48,720
But then, because B is
just a piece of code

383
00:20:48,720 --> 00:20:52,260
that runs q based on
what it sees on the tape.

384
00:20:52,260 --> 00:20:56,400
A, now you need to
know what B is in order

385
00:20:56,400 --> 00:21:01,940
to obtain A. Because A has
the code for B embedded

386
00:21:01,940 --> 00:21:05,520
within A as a string.

387
00:21:05,520 --> 00:21:08,780
So first you produce B, then
you can figure out-- then

388
00:21:08,780 --> 00:21:10,370
you can obtain A.
There's nothing

389
00:21:10,370 --> 00:21:11,480
circular in this argument.

390
00:21:11,480 --> 00:21:13,805
I don't know if
that's helpful to you,

391
00:21:13,805 --> 00:21:15,180
but you may need
to mull it over.

392
00:21:15,180 --> 00:21:17,340
Or maybe it'll be helpful
from the next slide.

393
00:21:17,340 --> 00:21:19,970
So let's go there now.

394
00:21:19,970 --> 00:21:22,460
So as I'm saying, you can
implement this in any language.

395
00:21:22,460 --> 00:21:25,840
In particular, you can
implement it in English.

396
00:21:25,840 --> 00:21:27,380
So let's just shift gears.

397
00:21:27,380 --> 00:21:31,450
Let's talk about writing
down English instructions.

398
00:21:31,450 --> 00:21:35,980
And then I'll show what
happens if you carry out

399
00:21:35,980 --> 00:21:37,070
those instructions.

400
00:21:37,070 --> 00:21:40,180
So let's start simple.

401
00:21:40,180 --> 00:21:45,860
How about the sentence,
Write "Hello World."

402
00:21:45,860 --> 00:21:50,750
So an obedient person
reading those instructions

403
00:21:50,750 --> 00:21:57,665
would then write "Hello World"
on their paper or wherever.

404
00:21:57,665 --> 00:22:01,120

405
00:22:01,120 --> 00:22:07,040
OK, fine, hopefully
you get the idea.

406
00:22:07,040 --> 00:22:08,560
So now, what I'd like--

407
00:22:08,560 --> 00:22:17,320
here's another sentence,
another instruction.

408
00:22:17,320 --> 00:22:18,175
Write this sentence.

409
00:22:18,175 --> 00:22:20,840

410
00:22:20,840 --> 00:22:30,880
And the obedient reader would
then, OK, Write this sentence.

411
00:22:30,880 --> 00:22:34,010
This is the kind of
thing I'm looking for.

412
00:22:34,010 --> 00:22:38,120
Here is a sentence which
instructs the reader

413
00:22:38,120 --> 00:22:40,660
to make an exact copy.

414
00:22:40,660 --> 00:22:42,660
But I don't like this
one, even though it

415
00:22:42,660 --> 00:22:44,760
does, in a sense,
what I'm looking for.

416
00:22:44,760 --> 00:22:49,350
Because it kind of cheats.

417
00:22:49,350 --> 00:22:55,800
When it has this, this refers
to the entire sentence itself.

418
00:22:55,800 --> 00:23:00,790
It's using kind of
implicitly here a construct

419
00:23:00,790 --> 00:23:03,560
which a Turing
machine does not have.

420
00:23:03,560 --> 00:23:06,620
The Turing machine
does not have a way

421
00:23:06,620 --> 00:23:08,795
of accessing its own code.

422
00:23:08,795 --> 00:23:12,080

423
00:23:12,080 --> 00:23:16,150
And in fact, really what the
point of this whole theorem

424
00:23:16,150 --> 00:23:17,642
that we're going
to present is, is

425
00:23:17,642 --> 00:23:22,590
that you don't need to have this
self-reference as a primitive.

426
00:23:22,590 --> 00:23:28,950
You can get that effectively
using the procedure

427
00:23:28,950 --> 00:23:31,660
that I'm describing, which
will give you the same effect.

428
00:23:31,660 --> 00:23:33,210
So you don't need
it as a primitive.

429
00:23:33,210 --> 00:23:36,690
You can design some
software basically,

430
00:23:36,690 --> 00:23:38,190
which will give you
the same effect.

431
00:23:38,190 --> 00:23:41,280

432
00:23:41,280 --> 00:23:43,220
So let me show you how
to do that in English.

433
00:23:43,220 --> 00:23:47,720
So let's look at
a slightly more--

434
00:23:47,720 --> 00:23:49,880
whoops, cheating,
so Turing machines

435
00:23:49,880 --> 00:23:51,680
don't have this
self-reference primitive.

436
00:23:51,680 --> 00:23:54,190
So let's look at
another sentence here.

437
00:23:54,190 --> 00:23:56,620
Write the following
twice, the second time

438
00:23:56,620 --> 00:24:00,930
in quotes, and
then, "Hello World."

439
00:24:00,930 --> 00:24:06,340
So what do we get if we
follow that instruction?

440
00:24:06,340 --> 00:24:10,030
Well, you get "Hello World"
and then "Hello World"

441
00:24:10,030 --> 00:24:11,260
again, now in quotes.

442
00:24:11,260 --> 00:24:14,040

443
00:24:14,040 --> 00:24:15,600
OK?

444
00:24:15,600 --> 00:24:17,650
Hopefully not too bad.

445
00:24:17,650 --> 00:24:19,860
But now, I'm one
step away for doing

446
00:24:19,860 --> 00:24:24,655
the implementation of the
self-reproducing algorithm

447
00:24:24,655 --> 00:24:25,155
in English.

448
00:24:25,155 --> 00:24:28,050

449
00:24:28,050 --> 00:24:31,920
Write the following twice,
the second time in quotes,

450
00:24:31,920 --> 00:24:33,630
and then in quotes,
the same text.

451
00:24:33,630 --> 00:24:37,440

452
00:24:37,440 --> 00:24:39,210
Now following
those instructions,

453
00:24:39,210 --> 00:24:43,800
you get, well, "Write
the following twice,

454
00:24:43,800 --> 00:24:46,120
the second time in quotes,"
so that comes out here.

455
00:24:46,120 --> 00:24:48,730
And the second time,
you put it in quotes,

456
00:24:48,730 --> 00:24:51,600
just like you did with
the "Hello World."

457
00:24:51,600 --> 00:24:57,570
But that's exactly
here, the output

458
00:24:57,570 --> 00:25:00,650
is exactly what the input was.

459
00:25:00,650 --> 00:25:05,820
And even though there is a
part of the sentence here

460
00:25:05,820 --> 00:25:07,830
which refers to
a different part,

461
00:25:07,830 --> 00:25:11,840
so here the first part is
referring to the second part,

462
00:25:11,840 --> 00:25:14,870
never do I have to have
the sentence referring

463
00:25:14,870 --> 00:25:17,720
to its entirety.

464
00:25:17,720 --> 00:25:19,220
There's no part of
the sentence here

465
00:25:19,220 --> 00:25:22,430
that's pointing at
the entire sentence.

466
00:25:22,430 --> 00:25:26,960
And so, this here
manages to get the effect

467
00:25:26,960 --> 00:25:31,300
that I'm looking for, where the
output is equal to the code,

468
00:25:31,300 --> 00:25:35,840
but avoids having
the self-reference.

469
00:25:35,840 --> 00:25:37,675
One thing is referring
to something else,

470
00:25:37,675 --> 00:25:39,050
but not referring
back to itself.

471
00:25:39,050 --> 00:25:43,530

472
00:25:43,530 --> 00:25:47,160
So let me just see here.

473
00:25:47,160 --> 00:25:53,250
So here, I'm going to have a
check-in on this in a minute.

474
00:25:53,250 --> 00:25:56,300
So I'm going to try to
contrast what's happening here

475
00:25:56,300 --> 00:25:58,580
with what's happening in
that Turing machine SELF

476
00:25:58,580 --> 00:26:01,730
that I had from
the previous slide.

477
00:26:01,730 --> 00:26:04,520
So why don't you mull this
over, and I'm going to give you

478
00:26:04,520 --> 00:26:06,920
a check-in to see--

479
00:26:06,920 --> 00:26:09,680
this is a little bit of
a challenging check-in.

480
00:26:09,680 --> 00:26:13,820
But let's see if you can
figure your way through it.

481
00:26:13,820 --> 00:26:17,220

482
00:26:17,220 --> 00:26:19,642
And basically it says, so
really what we're doing here

483
00:26:19,642 --> 00:26:21,600
is called the recursion
theorem, as you'll see.

484
00:26:21,600 --> 00:26:23,808
We'll actually present the
recursion theorem formally

485
00:26:23,808 --> 00:26:25,410
on the next slide.

486
00:26:25,410 --> 00:26:29,260
But here, in both
of these cases,

487
00:26:29,260 --> 00:26:33,210
we kind of have a template
part and an action part.

488
00:26:33,210 --> 00:26:38,070
In both cases, there are two
parts to the instructions,

489
00:26:38,070 --> 00:26:40,320
the template and the action.

490
00:26:40,320 --> 00:26:40,820
OK?

491
00:26:40,820 --> 00:26:43,130
So I'm going to leave
it to you to try

492
00:26:43,130 --> 00:26:46,310
to imagine which
of those is which,

493
00:26:46,310 --> 00:26:49,460
in each of these two examples.

494
00:26:49,460 --> 00:26:51,305
And then, I'm going
to ask you to pick.

495
00:26:51,305 --> 00:26:53,623

496
00:26:53,623 --> 00:26:55,790
In the Turing machine, which
is the action and which

497
00:26:55,790 --> 00:26:57,833
is the template,
and in the sentence,

498
00:26:57,833 --> 00:26:59,750
which is the action and
which is the template.

499
00:26:59,750 --> 00:27:02,870
The action is the
part where there's

500
00:27:02,870 --> 00:27:08,000
some interesting sort of
instructional stuff happening

501
00:27:08,000 --> 00:27:09,800
that you have to carry out.

502
00:27:09,800 --> 00:27:16,950
The template is really basically
just text or just a string.

503
00:27:16,950 --> 00:27:19,785
So let me pull up that poll.

504
00:27:19,785 --> 00:27:23,748

505
00:27:23,748 --> 00:27:24,540
See what you think.

506
00:27:24,540 --> 00:27:30,920

507
00:27:30,920 --> 00:27:34,220
Because I'm asking you
now to indicate where

508
00:27:34,220 --> 00:27:37,400
is the action part in
both of those cases.

509
00:27:37,400 --> 00:27:44,570

510
00:27:44,570 --> 00:27:46,320
What is the upper
phrase and lower phrase?

511
00:27:46,320 --> 00:27:47,500
I mean, of this sentence here.

512
00:27:47,500 --> 00:27:48,770
So write the following twice.

513
00:27:48,770 --> 00:27:49,920
This is the upper phrase.

514
00:27:49,920 --> 00:27:52,965
And the part in quotations
is the lower phrase-- sorry.

515
00:27:52,965 --> 00:28:00,510

516
00:28:00,510 --> 00:28:01,620
OK, almost done here?

517
00:28:01,620 --> 00:28:07,130

518
00:28:07,130 --> 00:28:12,300
5 seconds-- a few of you
have not answered yet.

519
00:28:12,300 --> 00:28:12,990
Answer it.

520
00:28:12,990 --> 00:28:15,810

521
00:28:15,810 --> 00:28:17,340
One second to go.

522
00:28:17,340 --> 00:28:19,950
OK, here we go, ending polling.

523
00:28:19,950 --> 00:28:22,510

524
00:28:22,510 --> 00:28:24,880
So the majority here is correct.

525
00:28:24,880 --> 00:28:29,510

526
00:28:29,510 --> 00:28:33,500
I would say, in the
English sentence here,

527
00:28:33,500 --> 00:28:36,020
the action part
is the first part.

528
00:28:36,020 --> 00:28:40,460
That's where you actually have
been directed to do something.

529
00:28:40,460 --> 00:28:44,390
The second half of the sentence,
the lower part of the sentence,

530
00:28:44,390 --> 00:28:47,960
is just a template written.

531
00:28:47,960 --> 00:28:49,850
This is just some string here.

532
00:28:49,850 --> 00:28:51,830
There's no action
really being directed.

533
00:28:51,830 --> 00:28:53,470
It happens to be
the same as the top,

534
00:28:53,470 --> 00:28:55,220
but this could have
been just Hello World.

535
00:28:55,220 --> 00:28:57,140
This could have been anything.

536
00:28:57,140 --> 00:28:59,150
And then the upper
part acts on that.

537
00:28:59,150 --> 00:29:01,160
So the upper part
is the action part.

538
00:29:01,160 --> 00:29:04,160
So it's the upper phrase
that's the relevant part.

539
00:29:04,160 --> 00:29:07,760
Now, in the Turing
machine, in a sense,

540
00:29:07,760 --> 00:29:09,740
it's the other way around.

541
00:29:09,740 --> 00:29:12,560
The first part is really
just the template.

542
00:29:12,560 --> 00:29:16,700
The second part, B, is where
you're doing some actual work

543
00:29:16,700 --> 00:29:18,200
on the template.

544
00:29:18,200 --> 00:29:23,250
You're taking that, basically
text, which could be anything.

545
00:29:23,250 --> 00:29:24,320
A could be anything.

546
00:29:24,320 --> 00:29:29,870
And you're looking
at that template

547
00:29:29,870 --> 00:29:34,940
and reconstructing what A
was from that string that

548
00:29:34,940 --> 00:29:35,870
appears on the tape.

549
00:29:35,870 --> 00:29:38,090
So B is actually the one
that's doing the work.

550
00:29:38,090 --> 00:29:41,180
So it's B and the upper
phrase with part c is correct.

551
00:29:41,180 --> 00:29:43,700

552
00:29:43,700 --> 00:29:46,730
So let us continue then.

553
00:29:46,730 --> 00:29:52,280

554
00:29:52,280 --> 00:29:58,100
Oh, I want to mention here
problem 6 on the Pset.

555
00:29:58,100 --> 00:30:02,090
So your job really is
to implement this in--

556
00:30:02,090 --> 00:30:05,720
if you have a programming
language that you like--

557
00:30:05,720 --> 00:30:10,160
it could be Python or whatever
your favorite Java, whatever

558
00:30:10,160 --> 00:30:12,050
you like-- you can
implement this.

559
00:30:12,050 --> 00:30:14,163
If you don't know any
programming languages,

560
00:30:14,163 --> 00:30:16,580
then just make up some sort
of pseudo programming language

561
00:30:16,580 --> 00:30:18,560
and implement it there.

562
00:30:18,560 --> 00:30:27,040
Let me point out that
getting the quoting right

563
00:30:27,040 --> 00:30:31,570
is a bit of a pain because
you have to kind of escape

564
00:30:31,570 --> 00:30:33,650
the quotes and so on.

565
00:30:33,650 --> 00:30:35,380
I'm not going to be
fussy about that.

566
00:30:35,380 --> 00:30:37,780
So you can still get full
credit even if you don't get

567
00:30:37,780 --> 00:30:39,790
the quoting part quite correct.

568
00:30:39,790 --> 00:30:41,950
Do your best.

569
00:30:41,950 --> 00:30:45,850
I think it's an interesting
problem to try to solve.

570
00:30:45,850 --> 00:30:50,710
And if you struggle with it
for a while, it's slippery.

571
00:30:50,710 --> 00:30:54,340
It's the kind of
thing you can easily

572
00:30:54,340 --> 00:30:57,040
spend a couple of
hours on this problem.

573
00:30:57,040 --> 00:31:00,670
Because it's a bit
tricky to manage

574
00:31:00,670 --> 00:31:03,250
to make a program which
prints itself out,

575
00:31:03,250 --> 00:31:06,640
which is what the task of
problem is on the Pset.

576
00:31:06,640 --> 00:31:08,710
But don't fuss about
too much on the quoting

577
00:31:08,710 --> 00:31:10,750
if that's the only thing
that's hanging you up.

578
00:31:10,750 --> 00:31:13,250
Try to get the main structure
of it, which is fairly simple,

579
00:31:13,250 --> 00:31:14,440
actually.

580
00:31:14,440 --> 00:31:17,350
And if you can't get the
quoting part to work,

581
00:31:17,350 --> 00:31:20,980
I'll ask the graders not to
penalize you for that part.

582
00:31:20,980 --> 00:31:26,590

583
00:31:26,590 --> 00:31:31,300
Let's look at the sort of
the more formal version

584
00:31:31,300 --> 00:31:35,050
of what we've just done and
really kind of also taking it

585
00:31:35,050 --> 00:31:36,850
to the next level.

586
00:31:36,850 --> 00:31:40,420
Because being able to print
out a copy of yourself

587
00:31:40,420 --> 00:31:45,500
is kind of a curiosity in a way.

588
00:31:45,500 --> 00:31:48,290
But the recursion theorem
says, not only can you

589
00:31:48,290 --> 00:31:50,720
make a machine which prints
out a copy of itself,

590
00:31:50,720 --> 00:31:52,760
but you can actually
make a machine which

591
00:31:52,760 --> 00:31:57,080
can obtain a copy of itself
and then do some computation

592
00:31:57,080 --> 00:32:01,400
on that copy of itself, on its
own description, which actually

593
00:32:01,400 --> 00:32:03,980
turns out to be a
useful thing to do.

594
00:32:03,980 --> 00:32:06,230
Once you have access to
your own description,

595
00:32:06,230 --> 00:32:07,850
as you'll see from
some examples,

596
00:32:07,850 --> 00:32:12,230
then you can do perhaps some
interesting things with that.

597
00:32:12,230 --> 00:32:14,810
So basically, what the
recursion theorem is,

598
00:32:14,810 --> 00:32:16,190
is a kind of a compiler.

599
00:32:16,190 --> 00:32:19,820
It allows you to have a
new primitive when you're

600
00:32:19,820 --> 00:32:21,920
writing Turing
machines, which is,

601
00:32:21,920 --> 00:32:23,690
compute your own description.

602
00:32:23,690 --> 00:32:27,450
And the recursion theorem
will implement that for you.

603
00:32:27,450 --> 00:32:29,100
OK?

604
00:32:29,100 --> 00:32:33,000
So the technical form
of the recursion theorem

605
00:32:33,000 --> 00:32:38,730
is going to look a little bit
counterintuitive, perhaps.

606
00:32:38,730 --> 00:32:40,470
Let me put it out there.

607
00:32:40,470 --> 00:32:45,030
If you struggle a little bit
with the slide, don't sweat it.

608
00:32:45,030 --> 00:32:48,300
The main thing to remember,
and we'll see from examples,

609
00:32:48,300 --> 00:32:51,140
is that you can compute your
own description in a Turing

610
00:32:51,140 --> 00:32:51,640
machine.

611
00:32:51,640 --> 00:32:55,350
And that's going to
be allowed as code.

612
00:32:55,350 --> 00:32:57,780
So the way we're
going to do this

613
00:32:57,780 --> 00:33:03,030
is, what the
recursion theorem does

614
00:33:03,030 --> 00:33:08,830
for you is, it says you can
write a piece of code here.

615
00:33:08,830 --> 00:33:12,540
Let's call it a piece
of Turing machine code--

616
00:33:12,540 --> 00:33:17,240
algorithmic code--
called T. And T is

617
00:33:17,240 --> 00:33:21,880
going to get transformed
into a new machine, R.

618
00:33:21,880 --> 00:33:27,540
And R is going to get
provided a copy of the program

619
00:33:27,540 --> 00:33:31,260
itself, which is just a
description of R, for free.

620
00:33:31,260 --> 00:33:33,930
But otherwise, it's going
to act exactly like T.

621
00:33:33,930 --> 00:33:36,480
So R is going to
act exactly like T,

622
00:33:36,480 --> 00:33:41,640
except R is going to have
provided a copy of R.

623
00:33:41,640 --> 00:33:45,630
And that's what the theorem
shows you how to implement.

624
00:33:45,630 --> 00:33:46,470
So let me just see.

625
00:33:46,470 --> 00:33:49,500
So for any machine, T,
there is a machine R

626
00:33:49,500 --> 00:33:56,610
which, for any w, which is going
to be the input for R. R, on w,

627
00:33:56,610 --> 00:33:59,910
operates the same as
R on the input with w

628
00:33:59,910 --> 00:34:05,010
where it's given R. So R is
going to be getting access

629
00:34:05,010 --> 00:34:07,050
to R without--

630
00:34:07,050 --> 00:34:12,630
it's going to be obtaining
R by calculating it.

631
00:34:12,630 --> 00:34:15,270
Maybe it'll be clear
from the proof.

632
00:34:15,270 --> 00:34:19,173
I always struggled with how
to explain this clearly.

633
00:34:19,173 --> 00:34:20,590
So now, the proof
of this is going

634
00:34:20,590 --> 00:34:22,570
to be very much like
the proof from two

635
00:34:22,570 --> 00:34:26,139
slides back, except it's
going to be three parts.

636
00:34:26,139 --> 00:34:29,290
This is the part, T, that
you're going to provide.

637
00:34:29,290 --> 00:34:31,659
And the T is going to be
the Turing machine code that

638
00:34:31,659 --> 00:34:35,280
says, get your own description.

639
00:34:35,280 --> 00:34:39,179
And you don't have to worry
about how that happens.

640
00:34:39,179 --> 00:34:42,360
The compiler is going to add
on the A and B parts, which

641
00:34:42,360 --> 00:34:44,860
is going to get the whole
description of the whole thing,

642
00:34:44,860 --> 00:34:51,909
which is R, and feed it into
T as if T had it as an input.

643
00:34:51,909 --> 00:34:55,320
So T is going to be allowed
to get its own description now

644
00:34:55,320 --> 00:35:01,560
and operate on-- now does
its thing on the input w.

645
00:35:01,560 --> 00:35:03,645
So the way it's going
to work, so T is given.

646
00:35:03,645 --> 00:35:06,950

647
00:35:06,950 --> 00:35:12,800
A is going to be, as before,
the description of B now with T.

648
00:35:12,800 --> 00:35:17,450
So when A is done, it's going to
produce BT sitting on the tape

649
00:35:17,450 --> 00:35:20,760
next to the w.

650
00:35:20,760 --> 00:35:25,560
B is going to now figure out
what A was from the BT sitting

651
00:35:25,560 --> 00:35:26,130
on the tape.

652
00:35:26,130 --> 00:35:30,470

653
00:35:30,470 --> 00:35:35,300
And then, it's going to combine
that to get ABT, which is R.

654
00:35:35,300 --> 00:35:41,560
And after that, it passes
control to T with w and now R

655
00:35:41,560 --> 00:35:42,820
sitting on the tape.

656
00:35:42,820 --> 00:35:47,320
And now, T is going to
have its own description.

657
00:35:47,320 --> 00:35:49,810
But don't forget, now T
has been modified to be R.

658
00:35:49,810 --> 00:35:52,720
So it's not that T is
going to get T on the tape.

659
00:35:52,720 --> 00:35:55,060
For this to make
sense, this is going

660
00:35:55,060 --> 00:35:59,470
to be now the new machine R.
And R appears on the tape.

661
00:35:59,470 --> 00:36:01,540
And now, the code
that you provided,

662
00:36:01,540 --> 00:36:06,650
T, is now going to get
to operate on that.

663
00:36:06,650 --> 00:36:07,790
OK?

664
00:36:07,790 --> 00:36:11,990
If you didn't get that,
I'm not so worried.

665
00:36:11,990 --> 00:36:13,700
The main thing is
that you can use

666
00:36:13,700 --> 00:36:15,020
compute your own
description when you're

667
00:36:15,020 --> 00:36:16,145
describing Turing machines.

668
00:36:16,145 --> 00:36:20,560
That's what this
thing is telling you.

669
00:36:20,560 --> 00:36:21,920
I think it'll be--

670
00:36:21,920 --> 00:36:25,470
oh, there's a check-in here.

671
00:36:25,470 --> 00:36:27,180
Yeah, so I don't know.

672
00:36:27,180 --> 00:36:29,640
Let's do this one
kind of quickly here.

673
00:36:29,640 --> 00:36:35,880
Can we use the recursion theorem
to design a machine T which,

674
00:36:35,880 --> 00:36:43,670
instead of producing
its own description,

675
00:36:43,670 --> 00:36:49,010
accepts only its own
description as an input?

676
00:36:49,010 --> 00:36:51,080
So the language
of this machine is

677
00:36:51,080 --> 00:36:57,010
going to be simply the one
string, the description of T.

678
00:36:57,010 --> 00:37:01,090
So can we make a machine,
T, which does this?

679
00:37:01,090 --> 00:37:02,800
Now I'm looking
at this check-in.

680
00:37:02,800 --> 00:37:04,810
This T here is
confusing with that T.

681
00:37:04,810 --> 00:37:07,870
It's not the same T. That's bad.

682
00:37:07,870 --> 00:37:11,590
I should call it M. Design
a machine, M, where L of M

683
00:37:11,590 --> 00:37:15,940
is the description of M.

684
00:37:15,940 --> 00:37:18,670
And can we use the recursion
theorem to do that?

685
00:37:18,670 --> 00:37:23,350
What I would ask you to do is
think about it in this context.

686
00:37:23,350 --> 00:37:26,950
You can use compute
your own description

687
00:37:26,950 --> 00:37:30,130
when you're writing the
code for this machine.

688
00:37:30,130 --> 00:37:32,590
If you could do that,
could you make a machine

689
00:37:32,590 --> 00:37:34,390
which just accepts
strings which happen

690
00:37:34,390 --> 00:37:36,010
to be their own description?

691
00:37:36,010 --> 00:37:37,850
This is supposed to be easy.

692
00:37:37,850 --> 00:37:40,510
But I think it ended up being
a little bit more complicated

693
00:37:40,510 --> 00:37:41,200
than I wanted.

694
00:37:41,200 --> 00:37:45,450

695
00:37:45,450 --> 00:37:49,030
Launch polling, make
your best guess.

696
00:37:49,030 --> 00:37:51,600

697
00:37:51,600 --> 00:37:53,400
I think you all kind of see--

698
00:37:53,400 --> 00:37:57,870
I was kind of leading you,
leading you along the path

699
00:37:57,870 --> 00:37:58,650
here.

700
00:37:58,650 --> 00:38:02,850
Yes so, I think you're pretty
much all are getting it.

701
00:38:02,850 --> 00:38:12,160
Maybe a few of you are unsure.

702
00:38:12,160 --> 00:38:15,672
But anyway, let's just
wrap this one up quickly

703
00:38:15,672 --> 00:38:16,630
so that we can move on.

704
00:38:16,630 --> 00:38:23,340
I think you're pretty much-- so,
5 seconds, I'm going to end it.

705
00:38:23,340 --> 00:38:26,490
So the correct answer is
Yes, as I was hinting at.

706
00:38:26,490 --> 00:38:29,640
So I think maybe this example
would have been better

707
00:38:29,640 --> 00:38:30,900
after the next example.

708
00:38:30,900 --> 00:38:32,442
And then we're going
to have a break.

709
00:38:32,442 --> 00:38:34,720

710
00:38:34,720 --> 00:38:38,910
So here is a new proof
that ATM is undecidable

711
00:38:38,910 --> 00:38:41,100
but now using the
recursion theorem.

712
00:38:41,100 --> 00:38:43,320
And this is going to give
you a nice example of how

713
00:38:43,320 --> 00:38:47,730
we use the recursion
theorem in action.

714
00:38:47,730 --> 00:38:54,060
So remember, we spent half a
lecture or more with a proof

715
00:38:54,060 --> 00:38:55,440
by diagonalization.

716
00:38:55,440 --> 00:38:59,610
As our first example of an
undecidable problem ATM,

717
00:38:59,610 --> 00:39:01,500
we subsequently
showed other things

718
00:39:01,500 --> 00:39:04,380
undecidable by reduction.

719
00:39:04,380 --> 00:39:09,880
But for the very first example,
we used that diagonalization.

720
00:39:09,880 --> 00:39:13,855
Now I'm going to
give you a new proof.

721
00:39:13,855 --> 00:39:15,230
So proof by
contradiction, assume

722
00:39:15,230 --> 00:39:18,230
we have a Turing machine,
H, that decides ATM.

723
00:39:18,230 --> 00:39:21,620
It starts the same way that
the diagonalization proof went.

724
00:39:21,620 --> 00:39:24,440
But now I'm going to
make a new machine called

725
00:39:24,440 --> 00:39:28,070
R. So this is going to be
different from the earlier

726
00:39:28,070 --> 00:39:29,300
proof.

727
00:39:29,300 --> 00:39:33,110
R says, on input w, I
get my own description.

728
00:39:33,110 --> 00:39:34,610
Use the recursion theorem.

729
00:39:34,610 --> 00:39:36,620
That's the way these
things always start.

730
00:39:36,620 --> 00:39:42,820
Now, I'm going to use H. Now
that I know my own description,

731
00:39:42,820 --> 00:39:45,850
I'm going to feed--

732
00:39:45,850 --> 00:39:50,060
I can ask H. I can feed R, w--

733
00:39:50,060 --> 00:39:51,310
w was the input here.

734
00:39:51,310 --> 00:39:56,560
I can feed R, w into H to
determine whether R accepts w.

735
00:39:56,560 --> 00:39:59,110
That's what H does.

736
00:39:59,110 --> 00:40:08,110
Solving ATM, H will tell this
machine whether R accepts w.

737
00:40:08,110 --> 00:40:10,840
R is the machine we're
writing, however.

738
00:40:10,840 --> 00:40:15,920
That is the machine
that's currently running.

739
00:40:15,920 --> 00:40:23,960
So R now uses H, and it knows
what it's supposed to do.

740
00:40:23,960 --> 00:40:26,380
H is going to say, well,
you're going to accept w

741
00:40:26,380 --> 00:40:28,760
or you're not going to accept w.

742
00:40:28,760 --> 00:40:31,520
That's what H is assumed
to be able to do.

743
00:40:31,520 --> 00:40:34,980
But then what is R
going to do after that?

744
00:40:34,980 --> 00:40:39,490
R is going to do the opposite
of what H says it's going to do.

745
00:40:39,490 --> 00:40:46,770
So if H says, R accepts w,
then R is going to reject w.

746
00:40:46,770 --> 00:40:50,610
If H says R doesn't accept w--

747
00:40:50,610 --> 00:40:53,670
it rejects it by looping or
halting, doesn't matter--

748
00:40:53,670 --> 00:41:02,560
H just says it rejects, then
it's just going to accept.

749
00:41:02,560 --> 00:41:06,160
So whatever H says, R is
going to show that H is wrong.

750
00:41:06,160 --> 00:41:08,092
So that's a contradiction.

751
00:41:08,092 --> 00:41:13,620
It says that H cannot
be deciding ATM.

752
00:41:13,620 --> 00:41:17,770
So if you step back and think
about what this is here,

753
00:41:17,770 --> 00:41:20,070
that's that whole
diagonalization proof

754
00:41:20,070 --> 00:41:22,140
in one line.

755
00:41:22,140 --> 00:41:25,428
Basically, we've done that
proof in a different way,

756
00:41:25,428 --> 00:41:26,970
though there is some
similarity here.

757
00:41:26,970 --> 00:41:29,460
I don't want to say that we've
totally reinvented things

758
00:41:29,460 --> 00:41:30,877
and done that
totally differently.

759
00:41:30,877 --> 00:41:32,640
But it's kind of, in
some ways, sort of

760
00:41:32,640 --> 00:41:34,740
gets at the essence
of the diagonalization

761
00:41:34,740 --> 00:41:36,270
in a certain sense.

762
00:41:36,270 --> 00:41:39,030
But anyway, it gives you kind
of a new, very short proof

763
00:41:39,030 --> 00:41:40,650
that ATM is undecidable.

764
00:41:40,650 --> 00:41:42,490
I think that's kind
of a cool thing.

765
00:41:42,490 --> 00:41:48,480
So why don't we take our
little coffee break here,

766
00:41:48,480 --> 00:41:52,500
and you can feel free to ask
questions during the break.

767
00:41:52,500 --> 00:41:56,130
I will start my timer going.

768
00:41:56,130 --> 00:41:59,580
And we'll be back continuing
lecture in five minutes.

769
00:41:59,580 --> 00:42:14,610

770
00:42:14,610 --> 00:42:16,990
OK, so questions-- so we're
getting some questions

771
00:42:16,990 --> 00:42:20,950
on when I said, we don't have
to worry about the quotes

772
00:42:20,950 --> 00:42:27,460
when we're solving
problem 6 on the Pset.

773
00:42:27,460 --> 00:42:33,700
Somebody says, can we just say
print A, B, C, instead of print

774
00:42:33,700 --> 00:42:37,012
quote, "A, B, C," and it will
print A, B, C. Yes, you can--

775
00:42:37,012 --> 00:42:38,220
don't worry about the quotes.

776
00:42:38,220 --> 00:42:41,020

777
00:42:41,020 --> 00:42:42,190
I think it's kind of--

778
00:42:42,190 --> 00:42:44,140
you'll see a challenge
if you want to try

779
00:42:44,140 --> 00:42:45,520
to get the quotes to work.

780
00:42:45,520 --> 00:42:46,970
But it's also kind of a pain.

781
00:42:46,970 --> 00:42:49,750
So yeah, you can just
kind of ignore the quotes,

782
00:42:49,750 --> 00:42:53,810
and I'll ask the graders to
give that full marks there.

783
00:42:53,810 --> 00:42:58,750
So any reasonable
interpretation will--

784
00:42:58,750 --> 00:43:01,150
as long as you get the
rest of the concept right--

785
00:43:01,150 --> 00:43:03,340
will be fine.

786
00:43:03,340 --> 00:43:09,150
Let's see, somebody is asking,
In the recursion theorem,

787
00:43:09,150 --> 00:43:12,480
why doesn't T get
the description of T

788
00:43:12,480 --> 00:43:15,620
instead of the description of R?

789
00:43:15,620 --> 00:43:19,250
Because the machine
that's running

790
00:43:19,250 --> 00:43:26,980
is R, back in the previous
slide, two slides ago.

791
00:43:26,980 --> 00:43:29,452
So if R got T, it would not be
getting its own description.

792
00:43:29,452 --> 00:43:30,910
It would be getting
the description

793
00:43:30,910 --> 00:43:32,000
of some other machine.

794
00:43:32,000 --> 00:43:33,850
So you need to think
about what we actually

795
00:43:33,850 --> 00:43:36,475
need to have happen here in the
proof of the recursion theorem.

796
00:43:36,475 --> 00:43:39,940
But it needs to have R, not T.

797
00:43:39,940 --> 00:43:41,590
Let's just see if I can--

798
00:43:41,590 --> 00:43:43,960
why does R do the
opposite of what H says?

799
00:43:43,960 --> 00:43:56,870

800
00:43:56,870 --> 00:43:59,072
Why does R do the
opposite of what H says?

801
00:43:59,072 --> 00:44:00,530
Well, first of all,
I'm the one who

802
00:44:00,530 --> 00:44:03,710
gets to design R. So
here is the code arc.

803
00:44:03,710 --> 00:44:05,930
We're assuming we
have H. I'm going

804
00:44:05,930 --> 00:44:11,180
to design R to do anything
I want to satisfy the proof.

805
00:44:11,180 --> 00:44:20,140
And R here is designed
to do the opposite of H.

806
00:44:20,140 --> 00:44:21,220
So I'm asking R--

807
00:44:21,220 --> 00:44:24,490
I'm programming R
to find out what

808
00:44:24,490 --> 00:44:29,068
H predicts it will do
and then do the opposite.

809
00:44:29,068 --> 00:44:31,730
Maybe the situation
is sort of like this.

810
00:44:31,730 --> 00:44:38,930
Suppose somebody says, I
have a crystal ball, which

811
00:44:38,930 --> 00:44:41,510
is going to be like the role
of H. And you say, oh, really?

812
00:44:41,510 --> 00:44:43,190
That's kind of cool.

813
00:44:43,190 --> 00:44:46,850
I don't believe you, but it
still sounds interesting.

814
00:44:46,850 --> 00:44:49,085
And the person says, yeah,
I can see the future.

815
00:44:49,085 --> 00:44:52,160

816
00:44:52,160 --> 00:44:57,360
I know what you're going
to do in five minutes.

817
00:44:57,360 --> 00:45:01,280
And in fact, I can see
that in five minutes,

818
00:45:01,280 --> 00:45:05,570
you're going to say, Hello.

819
00:45:05,570 --> 00:45:08,940
And you can say, well,
you can think to yourself,

820
00:45:08,940 --> 00:45:10,340
well, this person is nuts.

821
00:45:10,340 --> 00:45:12,120
I'm not going to do that.

822
00:45:12,120 --> 00:45:13,940
I'm just not going to say Hello.

823
00:45:13,940 --> 00:45:18,448
And then the genie there
with the crystal ball

824
00:45:18,448 --> 00:45:20,240
waits five minutes and
you don't say Hello.

825
00:45:20,240 --> 00:45:23,000
And then you've proven that
the crystal ball doesn't work.

826
00:45:23,000 --> 00:45:23,750
It's very similar.

827
00:45:23,750 --> 00:45:31,210

828
00:45:31,210 --> 00:45:34,240
I'm not going to explain how we
can do the combining in SELF.

829
00:45:34,240 --> 00:45:38,410
I just want to explain
at a high level.

830
00:45:38,410 --> 00:45:40,780
That's just going to be messy.

831
00:45:40,780 --> 00:45:44,520
Because I said, we were somehow
going to combine in SELF.

832
00:45:44,520 --> 00:45:48,570
Let me leave that as
a conceptual level.

833
00:45:48,570 --> 00:45:52,773
OK, how does this idea
work for Turing machines?

834
00:45:52,773 --> 00:45:54,440
I don't really
understand that question.

835
00:45:54,440 --> 00:45:57,290
How does this idea work for
Turing machines are decidable?

836
00:45:57,290 --> 00:45:58,790
You'll have to
resend that because I

837
00:45:58,790 --> 00:46:02,060
don't understand the question.

838
00:46:02,060 --> 00:46:06,290
Can I explain, use
your own description?

839
00:46:06,290 --> 00:46:12,220
So when you write code that
says, get your own description,

840
00:46:12,220 --> 00:46:18,120
after that code executes,
the Turing machine

841
00:46:18,120 --> 00:46:22,960
appears on the tape, like
magic, the description

842
00:46:22,960 --> 00:46:25,870
of its own code.

843
00:46:25,870 --> 00:46:28,570
Say, sitting next to the
input to the machine,

844
00:46:28,570 --> 00:46:31,280
because the machine may have
an separate input from that.

845
00:46:31,280 --> 00:46:34,420
So the machine just
magically gets its own code.

846
00:46:34,420 --> 00:46:38,320
And the proof of the recursion
theorem implements that,

847
00:46:38,320 --> 00:46:39,760
so it's not magic after all.

848
00:46:39,760 --> 00:46:44,790

849
00:46:44,790 --> 00:46:49,970
But I still don't
understand the question.

850
00:46:49,970 --> 00:46:55,440

851
00:46:55,440 --> 00:46:57,470
So for problem 6, is it
enough to attach code?

852
00:46:57,470 --> 00:47:05,510
If you're going to attach
code for problem 6, and that's

853
00:47:05,510 --> 00:47:06,140
good enough.

854
00:47:06,140 --> 00:47:10,130
Or if you can explain,
it's also good, like usual.

855
00:47:10,130 --> 00:47:11,810
Do we worry about
tabs and new lines?

856
00:47:11,810 --> 00:47:12,310
No.

857
00:47:12,310 --> 00:47:17,682

858
00:47:17,682 --> 00:47:20,140
OK, we're going to have to
defer the rest of the questions.

859
00:47:20,140 --> 00:47:22,140
Don't forget we have
a zillion questions

860
00:47:22,140 --> 00:47:23,280
here which I didn't get to.

861
00:47:23,280 --> 00:47:27,140

862
00:47:27,140 --> 00:47:30,620
OK, last one here-- why
does programming R do

863
00:47:30,620 --> 00:47:32,780
the opposite of H?

864
00:47:32,780 --> 00:47:34,620
Is that a contradiction?

865
00:47:34,620 --> 00:47:37,370
Well, H is predicting that R
accepts, but R doesn't accept,

866
00:47:37,370 --> 00:47:39,350
so H is wrong.

867
00:47:39,350 --> 00:47:40,670
We're a little short on time.

868
00:47:40,670 --> 00:47:44,070
Let me skip this one.

869
00:47:44,070 --> 00:47:46,180
You can look at
this on your own.

870
00:47:46,180 --> 00:47:49,290
I mean, this is proving
sort of the cool fact that--

871
00:47:49,290 --> 00:47:51,090
I'll just say it
at a high level.

872
00:47:51,090 --> 00:47:56,050
If you have a program
transformation,

873
00:47:56,050 --> 00:47:58,590
so if I have some
method of transforming

874
00:47:58,590 --> 00:48:01,540
one program to another program,
but it's done by algorithm.

875
00:48:01,540 --> 00:48:03,900
So an algorithmic way
that transforms one

876
00:48:03,900 --> 00:48:05,460
program to another program.

877
00:48:05,460 --> 00:48:09,030
There's always going to be
some program whose behavior is

878
00:48:09,030 --> 00:48:12,060
unchanged by the transformation.

879
00:48:12,060 --> 00:48:15,090
That's called the
fixed point theorem.

880
00:48:15,090 --> 00:48:16,800
So there some program
whose behavior

881
00:48:16,800 --> 00:48:18,600
doesn't change no
matter how you try

882
00:48:18,600 --> 00:48:21,540
two transform programs-- easy
proof using the recursion

883
00:48:21,540 --> 00:48:23,370
theorem.

884
00:48:23,370 --> 00:48:27,480
You can look at
the slide offline

885
00:48:27,480 --> 00:48:30,063
separately if you like
to see how that goes.

886
00:48:30,063 --> 00:48:30,855
It's pretty simple.

887
00:48:30,855 --> 00:48:35,340

888
00:48:35,340 --> 00:48:38,895
Here's another exercise
of the recursion theorem.

889
00:48:38,895 --> 00:48:43,180

890
00:48:43,180 --> 00:48:44,785
So if I have a--

891
00:48:44,785 --> 00:48:51,580

892
00:48:51,580 --> 00:48:58,030
let's say a Turing
machine is minimal

893
00:48:58,030 --> 00:49:03,640
if its description is the
shortest among all Turing

894
00:49:03,640 --> 00:49:06,310
machines which behave
the way it does,

895
00:49:06,310 --> 00:49:07,660
which are equivalent to it.

896
00:49:07,660 --> 00:49:12,570

897
00:49:12,570 --> 00:49:18,000
When I was an undergraduate,
I took a programming class.

898
00:49:18,000 --> 00:49:21,930
And some of us sort of
enjoyed writing short programs

899
00:49:21,930 --> 00:49:27,558
to carry out the exercises.

900
00:49:27,558 --> 00:49:29,100
Probably these days,
that's forbidden

901
00:49:29,100 --> 00:49:31,890
because it just encourages
bad programming style.

902
00:49:31,890 --> 00:49:38,730
But anyway, so you
kind of won if you

903
00:49:38,730 --> 00:49:42,720
found the shortest solution for
a given programming exercise.

904
00:49:42,720 --> 00:49:44,910
It was Heap Sort, I
remember, was one of the ones

905
00:49:44,910 --> 00:49:47,250
that we had to do.

906
00:49:47,250 --> 00:49:53,510
So this is sort of similar.

907
00:49:53,510 --> 00:49:56,750
You might imagine if people try
to find the shortest possible

908
00:49:56,750 --> 00:49:58,650
universal Turing machine.

909
00:49:58,650 --> 00:50:01,700
So short is, in our
sense is, in terms

910
00:50:01,700 --> 00:50:04,610
of whatever encoding
method we have in mind,

911
00:50:04,610 --> 00:50:09,770
a machine is minimal if there
is no shorter program which

912
00:50:09,770 --> 00:50:15,470
is equivalent using our
encoding system, whatever it is.

913
00:50:15,470 --> 00:50:20,600
So M is minimal if anything
that has a shorter description

914
00:50:20,600 --> 00:50:21,785
has a different language.

915
00:50:21,785 --> 00:50:26,390

916
00:50:26,390 --> 00:50:32,590
OK, so let's look at the
collection of all descriptions

917
00:50:32,590 --> 00:50:34,980
of minimal Turing machines.

918
00:50:34,980 --> 00:50:39,562
And I want to prove that that
language is unrecognizable.

919
00:50:39,562 --> 00:50:41,520
I'm going to do it using
the recursion theorem.

920
00:50:41,520 --> 00:50:44,228
And it's kind of
a cool exercise.

921
00:50:44,228 --> 00:50:46,770
And you can actually use it to
prove something more powerful.

922
00:50:46,770 --> 00:50:52,170
But let's focus on
this theorem for now.

923
00:50:52,170 --> 00:50:54,690
So assume we have--

924
00:50:54,690 --> 00:50:58,622
and it's also in the little
nice exercise about enumerators.

925
00:50:58,622 --> 00:51:01,080
I don't know how comfortable
you ever got with enumerators.

926
00:51:01,080 --> 00:51:04,860
But I'm trying to prove
this language here

927
00:51:04,860 --> 00:51:06,120
is not recognizable.

928
00:51:06,120 --> 00:51:08,820
And so remember,
enumerators, you

929
00:51:08,820 --> 00:51:12,090
can enumerate exactly all
the recognizable languages.

930
00:51:12,090 --> 00:51:14,880
So I'm going to assume I have
an enumerator for this language,

931
00:51:14,880 --> 00:51:21,160
which just prints out all of
the minimal Turing machines.

932
00:51:21,160 --> 00:51:22,530
So I have some enumerator.

933
00:51:22,530 --> 00:51:26,550
It's a program that prints
out the descriptions of all

934
00:51:26,550 --> 00:51:27,960
of the minimal--

935
00:51:27,960 --> 00:51:30,300
the shortest possible
Turing machines.

936
00:51:30,300 --> 00:51:32,980
And now I'm going to
get a contradiction.

937
00:51:32,980 --> 00:51:36,960
So we're going to build
this Turing machine, R,

938
00:51:36,960 --> 00:51:39,620
which gets its own description.

939
00:51:39,620 --> 00:51:46,550
And then, it's going to
start the enumerator until--

940
00:51:46,550 --> 00:51:50,360
so looking at the strings
that the enumerator produces.

941
00:51:50,360 --> 00:51:53,000
So this enumerator is producing
these minimal Turing machines,

942
00:51:53,000 --> 00:51:55,700
one after the next-- chunk,
chunk, chunk, chunk, chunk.

943
00:51:55,700 --> 00:51:58,610
All these minimal Turing
machines are coming out.

944
00:51:58,610 --> 00:52:02,060
And you keep looking at those
until you find one of them

945
00:52:02,060 --> 00:52:05,870
which is bigger than yourself.

946
00:52:05,870 --> 00:52:08,090
And how do you know how
big you are yourself?

947
00:52:08,090 --> 00:52:12,430
From the description you're
given by the recursion theorem.

948
00:52:12,430 --> 00:52:15,820
So you keep on printing
out these Turing machines

949
00:52:15,820 --> 00:52:18,590
until you find one that's
bigger than yourself.

950
00:52:18,590 --> 00:52:20,270
And then, what do
you do with that?

951
00:52:20,270 --> 00:52:22,990
You simulate that.

952
00:52:22,990 --> 00:52:27,120
So now, so what?

953
00:52:27,120 --> 00:52:29,190
Well, the point is
that you're going

954
00:52:29,190 --> 00:52:33,630
to be smaller than that
machine that you're simulating.

955
00:52:33,630 --> 00:52:35,400
Because you waited
to find a machine

956
00:52:35,400 --> 00:52:39,040
that the enumerator produced
which is bigger than you.

957
00:52:39,040 --> 00:52:41,440
So you're going to be
simulating that machine that's

958
00:52:41,440 --> 00:52:43,720
bigger than you.

959
00:52:43,720 --> 00:52:46,668
And so, you're going to be doing
exactly what that machine does

960
00:52:46,668 --> 00:52:48,210
on every input,
because you're always

961
00:52:48,210 --> 00:52:51,630
going to be simulating that
same machine on every input.

962
00:52:51,630 --> 00:52:53,910
And so, you're going to be
equivalent to that bigger

963
00:52:53,910 --> 00:52:55,410
machine.

964
00:52:55,410 --> 00:52:58,860
But that bigger machine
is supposed to be minimal

965
00:52:58,860 --> 00:53:01,800
because E is producing it.

966
00:53:01,800 --> 00:53:03,950
But here, you are
exhibiting a machine

967
00:53:03,950 --> 00:53:06,770
that's smaller than that--

968
00:53:06,770 --> 00:53:10,400
that allegedly minimal
machine couldn't be minimal.

969
00:53:10,400 --> 00:53:14,000
That's the contradiction.

970
00:53:14,000 --> 00:53:17,770
So the language of R, this
machine I just produced,

971
00:53:17,770 --> 00:53:23,050
equals the language of B.
Because R ends up simulating B.

972
00:53:23,050 --> 00:53:26,650
But R is smaller
than B because R

973
00:53:26,650 --> 00:53:29,890
waited until it found a bigger
machine that's bigger than it.

974
00:53:29,890 --> 00:53:33,220
So B couldn't be minimal,
but B was one of the machines

975
00:53:33,220 --> 00:53:34,990
that the enumerator produced.

976
00:53:34,990 --> 00:53:38,480
That's a contradiction.

977
00:53:38,480 --> 00:53:40,990
So let me do a check-in on this.

978
00:53:40,990 --> 00:53:43,720
I expect this is going to
cause some of you heartburn,

979
00:53:43,720 --> 00:53:45,700
but let's do the best you can.

980
00:53:45,700 --> 00:53:51,430

981
00:53:51,430 --> 00:53:54,190
Suppose I have this collection
of minimal Turing machines

982
00:53:54,190 --> 00:53:57,450
and I take some
infinite subset of that.

983
00:53:57,450 --> 00:53:59,538
So now I'm not demanding
that I have all

984
00:53:59,538 --> 00:54:00,830
of the minimal Turing machines.

985
00:54:00,830 --> 00:54:04,660
I just have infinitely many
minimal Turing machines.

986
00:54:04,660 --> 00:54:08,880
Is it possible that
subset-- whatever it is--

987
00:54:08,880 --> 00:54:13,380
could be Turing-recognizable?

988
00:54:13,380 --> 00:54:14,910
Now, think about that.

989
00:54:14,910 --> 00:54:18,570
Now, you can have
languages which

990
00:54:18,570 --> 00:54:20,670
are not
Turing-recognizable, that

991
00:54:20,670 --> 00:54:25,810
have infinite
Turing-recognizable subsets.

992
00:54:25,810 --> 00:54:27,610
Could that be for this language?

993
00:54:27,610 --> 00:54:42,330

994
00:54:42,330 --> 00:54:43,740
And maybe I'll give you a--

995
00:54:43,740 --> 00:54:48,420

996
00:54:48,420 --> 00:54:53,400
it will be helpful to you to
understand and perhaps apply

997
00:54:53,400 --> 00:54:57,265
the methodology that I gave
you in this proof here.

998
00:54:57,265 --> 00:54:58,640
And that might be
helpful to you.

999
00:54:58,640 --> 00:55:01,340

1000
00:55:01,340 --> 00:55:05,380
But I can see this is not--

1001
00:55:05,380 --> 00:55:07,870
this one is a bit of a struggle.

1002
00:55:07,870 --> 00:55:11,080

1003
00:55:11,080 --> 00:55:12,280
OK, let's end it.

1004
00:55:12,280 --> 00:55:15,400

1005
00:55:15,400 --> 00:55:19,670
Two seconds, just
pick something.

1006
00:55:19,670 --> 00:55:23,110
So the majority has the
correct answer here.

1007
00:55:23,110 --> 00:55:27,240

1008
00:55:27,240 --> 00:55:33,350
So in fact, this
proof would still

1009
00:55:33,350 --> 00:55:40,500
work if the enumerator was
enumerating an infinite subset

1010
00:55:40,500 --> 00:55:43,070
of minimal Turing machines.

1011
00:55:43,070 --> 00:55:45,290
Because all you need
is to wait until one

1012
00:55:45,290 --> 00:55:47,300
that's bigger than you appears.

1013
00:55:47,300 --> 00:55:50,810
And all that R
needs to do is wait

1014
00:55:50,810 --> 00:55:53,090
until one that's
bigger than R appears,

1015
00:55:53,090 --> 00:55:54,890
which will certainly
happen eventually

1016
00:55:54,890 --> 00:55:56,600
if the subset is infinite.

1017
00:55:56,600 --> 00:56:02,810
And then R simulates that bigger
machine and acts the same way,

1018
00:56:02,810 --> 00:56:04,625
thereby proving it
could not be minimal.

1019
00:56:04,625 --> 00:56:07,330

1020
00:56:07,330 --> 00:56:10,630
So it's exactly the same proof
shows that the answer here

1021
00:56:10,630 --> 00:56:13,170
is No.

1022
00:56:13,170 --> 00:56:14,680
And it's a kind of a curiosity.

1023
00:56:14,680 --> 00:56:17,490
It's not necessarily
that easy to construct

1024
00:56:17,490 --> 00:56:20,910
languages which not only
are they not recognizable,

1025
00:56:20,910 --> 00:56:23,520
but they have no
recognizable subsets--

1026
00:56:23,520 --> 00:56:24,570
infinite subsets.

1027
00:56:24,570 --> 00:56:26,100
Obviously, a finite
subset is going

1028
00:56:26,100 --> 00:56:31,910
to be recognizable because it
would be decidable as well.

1029
00:56:31,910 --> 00:56:33,310
So anyway, let's move on.

1030
00:56:33,310 --> 00:56:37,730

1031
00:56:37,730 --> 00:56:43,712
Some other
applications-- so first,

1032
00:56:43,712 --> 00:56:46,790
a real-world application--

1033
00:56:46,790 --> 00:56:54,790

1034
00:56:54,790 --> 00:56:58,200
somebody is asking
for an example

1035
00:56:58,200 --> 00:57:03,390
of a language of a
recognizable subset

1036
00:57:03,390 --> 00:57:06,750
of a non-recognizable language.

1037
00:57:06,750 --> 00:57:09,540
So starting out with something
which is not recognizable,

1038
00:57:09,540 --> 00:57:18,245
and can we come
up with a quick--

1039
00:57:18,245 --> 00:57:21,180

1040
00:57:21,180 --> 00:57:25,230
So here is, I don't know
if this will help you.

1041
00:57:25,230 --> 00:57:28,190
So the question is,
can I give an example

1042
00:57:28,190 --> 00:57:33,670
of a non-recognizable language
that has a recognizable subset?

1043
00:57:33,670 --> 00:57:40,150
So I didn't prepare this, but
let me see if this helps you.

1044
00:57:40,150 --> 00:57:42,460
So let's take ATM complement.

1045
00:57:42,460 --> 00:57:47,300
We already showed that ATM
complement is not recognizable.

1046
00:57:47,300 --> 00:57:51,890
So these are the sets
of pairs, M and w,

1047
00:57:51,890 --> 00:57:53,510
where M does not accept w.

1048
00:57:53,510 --> 00:58:03,965

1049
00:58:03,965 --> 00:58:11,630
So if I focus only on those
M's, which are finite automata,

1050
00:58:11,630 --> 00:58:15,260
which are a subclass
of Turing machines,

1051
00:58:15,260 --> 00:58:17,930
then I can get the
answer for those M's.

1052
00:58:17,930 --> 00:58:20,450

1053
00:58:20,450 --> 00:58:24,200
So for the infinitely many cases
where the Turing machine never

1054
00:58:24,200 --> 00:58:31,350
writes on its tape, it
even becomes decidable.

1055
00:58:31,350 --> 00:58:33,730
So I don't know
if that's helpful,

1056
00:58:33,730 --> 00:58:37,350
but you can
definitely find cases

1057
00:58:37,350 --> 00:58:39,900
where there are
undecidable languages that

1058
00:58:39,900 --> 00:58:42,780
have decidable subsets,
unrecognizable languages that

1059
00:58:42,780 --> 00:58:45,540
have recognizable
infinite subsets.

1060
00:58:45,540 --> 00:58:47,923
But there's one example
where it's not true,

1061
00:58:47,923 --> 00:58:48,840
in the previous slide.

1062
00:58:48,840 --> 00:58:53,740

1063
00:58:53,740 --> 00:58:55,490
OK, a lot of questions
are coming up here.

1064
00:58:55,490 --> 00:59:00,860

1065
00:59:00,860 --> 00:59:05,540
Yes, I'm seeing some
other proposals here.

1066
00:59:05,540 --> 00:59:09,270
If you take ATM
complement and you union

1067
00:59:09,270 --> 00:59:11,990
with just any old
strings of 1's,

1068
00:59:11,990 --> 00:59:14,762
just one star, assuming
that one star--

1069
00:59:14,762 --> 00:59:16,220
just strings of
1's are never going

1070
00:59:16,220 --> 00:59:18,530
to code for a Turing machine--

1071
00:59:18,530 --> 00:59:20,360
that's still going
to be unrecognizable.

1072
00:59:20,360 --> 00:59:22,400
But then you can
just throw away all

1073
00:59:22,400 --> 00:59:24,890
of those just strings
of 1's, and you're

1074
00:59:24,890 --> 00:59:26,330
going to get an infinite subset.

1075
00:59:26,330 --> 00:59:27,646
Oh, wait a minute.

1076
00:59:27,646 --> 00:59:29,130
It's still unrecognizable.

1077
00:59:29,130 --> 00:59:29,820
That's no good.

1078
00:59:29,820 --> 00:59:32,880

1079
00:59:32,880 --> 00:59:35,430
Oh, no, yeah, I threw
away the wrong stuff.

1080
00:59:35,430 --> 00:59:39,090
You throw away the descriptions
of the Turing machines,

1081
00:59:39,090 --> 00:59:42,090
and you just have the
one-star strings left.

1082
00:59:42,090 --> 00:59:45,130
And so, that becomes
decidable, even regular.

1083
00:59:45,130 --> 00:59:48,620
Anyway, I'm not sure
I'm helping you.

1084
00:59:48,620 --> 00:59:50,270
Let's move on to
other applications.

1085
00:59:50,270 --> 00:59:54,790
So this is kind of a curious
application that actually

1086
00:59:54,790 --> 00:59:57,610
is in the real world,
where a machine might want

1087
00:59:57,610 --> 01:00:00,760
to get a copy of itself and
then do something perhaps

1088
01:00:00,760 --> 01:00:07,367
even nefarious with a
copy of its own code.

1089
01:00:07,367 --> 01:00:08,825
And that would be
a computer virus.

1090
01:00:08,825 --> 01:00:12,010

1091
01:00:12,010 --> 01:00:16,540
Computer viruses make
copies of themselves

1092
01:00:16,540 --> 01:00:20,950
and then propagate them through
the internet, or whatever media

1093
01:00:20,950 --> 01:00:23,440
you have, to infect
other computers.

1094
01:00:23,440 --> 01:00:28,580
And I'm sure we all
know computer viruses.

1095
01:00:28,580 --> 01:00:31,000
Well, they need to get
copies of themselves

1096
01:00:31,000 --> 01:00:35,020
in order to do the infection.

1097
01:00:35,020 --> 01:00:37,420
How do they do that?

1098
01:00:37,420 --> 01:00:42,580
Many of them operate in a way
where in either in a language

1099
01:00:42,580 --> 01:00:46,060
or in a system, where
they can make reference

1100
01:00:46,060 --> 01:00:55,670
to their own code, either by
looking at the machine code,

1101
01:00:55,670 --> 01:00:58,970
or whatever direct
access to their own code.

1102
01:00:58,970 --> 01:01:02,550
There are languages and
systems which allow for that.

1103
01:01:02,550 --> 01:01:05,420
But I'm not an expert
on computer viruses.

1104
01:01:05,420 --> 01:01:09,560
I would be shocked if they're
not some other viruses that

1105
01:01:09,560 --> 01:01:15,620
get access to their own code by
using something in the same--

1106
01:01:15,620 --> 01:01:19,250
using basically the method
of the recursion theorem.

1107
01:01:19,250 --> 01:01:21,170
I haven't done a
systematic study.

1108
01:01:21,170 --> 01:01:23,210
But I'm sure, if
you can't access

1109
01:01:23,210 --> 01:01:26,810
to your own code directly
using some operating system

1110
01:01:26,810 --> 01:01:29,510
mechanism, some primitive,
the only other way

1111
01:01:29,510 --> 01:01:32,497
is basically doing the method
that we just described.

1112
01:01:32,497 --> 01:01:36,480

1113
01:01:36,480 --> 01:01:44,540
OK, so another application
is in a branch of mathematics

1114
01:01:44,540 --> 01:01:47,700
called mathematical logic.

1115
01:01:47,700 --> 01:01:51,570
Where, I imagine that many
of you have heard of the work

1116
01:01:51,570 --> 01:01:54,720
of Godel from the earlier
part of the 20th century,

1117
01:01:54,720 --> 01:01:58,560
where they show that
you can come up--

1118
01:01:58,560 --> 01:02:02,490
it's possible to demonstrate
that there are true

1119
01:02:02,490 --> 01:02:05,200
mathematical statements but
which cannot be proven to be

1120
01:02:05,200 --> 01:02:05,700
true.

1121
01:02:05,700 --> 01:02:08,410

1122
01:02:08,410 --> 01:02:13,050
So proof-- there might be
something like maybe even

1123
01:02:13,050 --> 01:02:16,710
questions of interest to us,
like P versus NP question,

1124
01:02:16,710 --> 01:02:21,660
which we will, at some point,
look at in a few weeks--

1125
01:02:21,660 --> 01:02:25,923
actually, yeah, maybe two
or three weeks from now.

1126
01:02:25,923 --> 01:02:27,840
There are many unsolved
mathematical problems.

1127
01:02:27,840 --> 01:02:31,250
And people wonder,
maybe there's just

1128
01:02:31,250 --> 01:02:33,000
no way to prove them
one way or the other.

1129
01:02:33,000 --> 01:02:35,560

1130
01:02:35,560 --> 01:02:40,350
So in the 1930s, when
Godel did his work,

1131
01:02:40,350 --> 01:02:42,720
he shocked the
mathematical community

1132
01:02:42,720 --> 01:02:48,120
by showing that proof does
not work for everything.

1133
01:02:48,120 --> 01:02:50,910
There may be things that are
true that you cannot prove.

1134
01:02:50,910 --> 01:02:53,740

1135
01:02:53,740 --> 01:02:56,760
In Hilbert, in particular,
from Hilbert's 10th problem,

1136
01:02:56,760 --> 01:03:02,970
he was dismayed by this
result. Because he had earlier

1137
01:03:02,970 --> 01:03:07,350
believed that anything that
was true you could prove.

1138
01:03:07,350 --> 01:03:10,650
So anyway, let's just see how--

1139
01:03:10,650 --> 01:03:14,490
I'm going to sketch how we
actually go about doing that.

1140
01:03:14,490 --> 01:03:16,500
Because we now have a
kind of enough technique

1141
01:03:16,500 --> 01:03:18,510
to at least give you
an idea of how do

1142
01:03:18,510 --> 01:03:21,510
you demonstrate that there are
true but unprovable statements

1143
01:03:21,510 --> 01:03:25,240
and actually even exhibit one.

1144
01:03:25,240 --> 01:03:27,490
OK, mathematical logic
is the mathematical study

1145
01:03:27,490 --> 01:03:28,555
of mathematics itself.

1146
01:03:28,555 --> 01:03:31,610

1147
01:03:31,610 --> 01:03:34,490
Godel's first incompleteness
theorem, as we described,

1148
01:03:34,490 --> 01:03:37,490
is that in any
reasonable formal system

1149
01:03:37,490 --> 01:03:41,570
of mathematical
provability, there

1150
01:03:41,570 --> 01:03:43,310
are going to be some
true statements that

1151
01:03:43,310 --> 01:03:46,150
are not provable.

1152
01:03:46,150 --> 01:03:49,620
And in order to sort of get
the sketch of the proof--

1153
01:03:49,620 --> 01:03:50,910
I shouldn't say proof here.

1154
01:03:50,910 --> 01:03:54,090
We're going to proof sketch.

1155
01:03:54,090 --> 01:03:59,310
We're going to basically use
two properties of formal proof

1156
01:03:59,310 --> 01:04:01,120
systems.

1157
01:04:01,120 --> 01:04:08,050
One is that kind of obvious
property that you would expect

1158
01:04:08,050 --> 01:04:11,320
all probability systems to
have, is that you can only

1159
01:04:11,320 --> 01:04:13,730
prove true things.

1160
01:04:13,730 --> 01:04:16,840
So if something is being
proven, it's going to be true.

1161
01:04:16,840 --> 01:04:20,080
You can't prove anything false.

1162
01:04:20,080 --> 01:04:23,050
If you can prove false things,
your system of provability

1163
01:04:23,050 --> 01:04:23,560
is bad.

1164
01:04:23,560 --> 01:04:26,550

1165
01:04:26,550 --> 01:04:30,930
And the other thing
is that proofs

1166
01:04:30,930 --> 01:04:33,960
are checkable by machine.

1167
01:04:33,960 --> 01:04:37,850
So if you write down-- do
your system in a formal way

1168
01:04:37,850 --> 01:04:39,930
and you have this
formal notion of proofs,

1169
01:04:39,930 --> 01:04:42,410
which underlies all mathematical
reasoning, by the way.

1170
01:04:42,410 --> 01:04:43,820
This is completely
well accepted.

1171
01:04:43,820 --> 01:04:46,640
Both of these properties are
accepted by mathematicians.

1172
01:04:46,640 --> 01:04:50,570
Then in principle, you can
convert any mathematical proof

1173
01:04:50,570 --> 01:04:53,270
into a form that you can
check it by computer.

1174
01:04:53,270 --> 01:04:54,810
It might become much longer.

1175
01:04:54,810 --> 01:04:58,070
But in principle, you can
put the proof into a form

1176
01:04:58,070 --> 01:05:01,070
where a computer
could check the proof.

1177
01:05:01,070 --> 01:05:05,240
And the way we're going
to frame that in the way

1178
01:05:05,240 --> 01:05:07,190
we've been talking
about things is

1179
01:05:07,190 --> 01:05:10,290
that the language of
all pairs of proof,

1180
01:05:10,290 --> 01:05:13,310
comma statement being proved--

1181
01:05:13,310 --> 01:05:17,270
so where pi is a proof
of the statement phi--

1182
01:05:17,270 --> 01:05:18,690
that's a decidable thing.

1183
01:05:18,690 --> 01:05:23,210
So you can check, by
machine, whether pi

1184
01:05:23,210 --> 01:05:25,010
is a valid proof of phi.

1185
01:05:25,010 --> 01:05:28,174

1186
01:05:28,174 --> 01:05:33,790
So your proof checker can say,
Yes, it's valid, No, not valid.

1187
01:05:33,790 --> 01:05:37,588
And that's something
you can do by algorithm.

1188
01:05:37,588 --> 01:05:39,380
So those are the two
assumptions that we're

1189
01:05:39,380 --> 01:05:41,088
going to make about
our system of proofs.

1190
01:05:41,088 --> 01:05:44,010
And that's all
we're going to need.

1191
01:05:44,010 --> 01:05:46,000
Now, the first
conclusion, which is,

1192
01:05:46,000 --> 01:05:48,900
I think, a good sort of
a little bit of exercise

1193
01:05:48,900 --> 01:05:55,060
on the kind of thinking we've
been doing in this course.

1194
01:05:55,060 --> 01:05:58,200
Number 2, checkability
implies that the set

1195
01:05:58,200 --> 01:06:03,900
of provable statements
is recognizable.

1196
01:06:03,900 --> 01:06:05,010
Why?

1197
01:06:05,010 --> 01:06:09,300
Suppose I give you a
statement that has a proof--

1198
01:06:09,300 --> 01:06:11,650
a provable statement.

1199
01:06:11,650 --> 01:06:13,870
I'm not saying it's a true
statement, necessarily.

1200
01:06:13,870 --> 01:06:18,820
That's going to be perhaps a
larger class of statements.

1201
01:06:18,820 --> 01:06:21,880
But the statement
that do have proofs,

1202
01:06:21,880 --> 01:06:23,850
that's a recognizable language.

1203
01:06:23,850 --> 01:06:26,930

1204
01:06:26,930 --> 01:06:30,800
Because, if I give
you a statement,

1205
01:06:30,800 --> 01:06:33,650
your recognizer is going
to take that statement

1206
01:06:33,650 --> 01:06:38,900
and start looking through
all possible proofs.

1207
01:06:38,900 --> 01:06:41,900
It's going to look at string
after string as a candidate

1208
01:06:41,900 --> 01:06:43,340
proof, one after the next.

1209
01:06:43,340 --> 01:06:46,297
Some strings, of course-- most
strings are going to be junk.

1210
01:06:46,297 --> 01:06:48,630
But every once in a while, a
proof is going to come out.

1211
01:06:48,630 --> 01:06:52,112
It's going to be a string which
is a valid proof of something.

1212
01:06:52,112 --> 01:06:53,570
And then you're
going to check, oh,

1213
01:06:53,570 --> 01:06:55,280
let me just see if
that's a valid proof.

1214
01:06:55,280 --> 01:06:58,070
And if it does prove the
statement that I have in mind,

1215
01:06:58,070 --> 01:07:00,920
and if it is, then I
accept that statement.

1216
01:07:00,920 --> 01:07:03,130
And it goes through
statement by--

1217
01:07:03,130 --> 01:07:06,810
the input is a
mathematical statement.

1218
01:07:06,810 --> 01:07:09,830
And that's going to be accepted
if the machine, by looking

1219
01:07:09,830 --> 01:07:11,960
through all possible
proofs, finds one

1220
01:07:11,960 --> 01:07:14,160
and then it accepts
that statement.

1221
01:07:14,160 --> 01:07:16,040
So the collection
of all statements

1222
01:07:16,040 --> 01:07:18,470
that have a proof,
that's recognizable.

1223
01:07:18,470 --> 01:07:21,340

1224
01:07:21,340 --> 01:07:29,770
So similarly, if you take
statements of the form

1225
01:07:29,770 --> 01:07:34,660
M and w is in the
complement of ATM.

1226
01:07:34,660 --> 01:07:36,698
So M doesn't accept w.

1227
01:07:36,698 --> 01:07:40,290

1228
01:07:40,290 --> 01:07:43,230
If you take all statements
of that form where M doesn't

1229
01:07:43,230 --> 01:07:49,530
accept w, or M, w is in
the complement of ATM,

1230
01:07:49,530 --> 01:07:52,950
some of those statements may
have proofs in your system.

1231
01:07:52,950 --> 01:07:55,080
Some of them may
not have proofs.

1232
01:07:55,080 --> 01:07:58,230
If all of them
had proofs, if you

1233
01:07:58,230 --> 01:08:00,270
can prove every
statement of this form

1234
01:08:00,270 --> 01:08:02,260
when it happens to be true--

1235
01:08:02,260 --> 01:08:04,510
obviously, you can't prove
the ones that are not true.

1236
01:08:04,510 --> 01:08:08,370
But if you can prove all the
true statements of this kind,

1237
01:08:08,370 --> 01:08:13,660
then ATM complement would
be Turing-recognizable.

1238
01:08:13,660 --> 01:08:18,609
Because you can go through, just
for the same reason as above.

1239
01:08:18,609 --> 01:08:20,859
But we know that that's false.

1240
01:08:20,859 --> 01:08:25,210
So there must be some
statement of this kind which is

1241
01:08:25,210 --> 01:08:28,060
true but does not have a proof.

1242
01:08:28,060 --> 01:08:29,710
Because otherwise,
the ATM complement

1243
01:08:29,710 --> 01:08:30,790
would be recognizable.

1244
01:08:30,790 --> 01:08:34,660

1245
01:08:34,660 --> 01:08:41,470
So we've actually done the first
half of Godel's incompleteness

1246
01:08:41,470 --> 01:08:42,140
theorem.

1247
01:08:42,140 --> 01:08:45,130
The second half, which
we're going to unfortunately

1248
01:08:45,130 --> 01:08:48,279
not have time to finish, but let
me just give you the outline,

1249
01:08:48,279 --> 01:08:51,520
is that we can use the recursion
theorem to give it specific--

1250
01:08:51,520 --> 01:08:53,859
see, what we showed
here is that there

1251
01:08:53,859 --> 01:08:57,115
is some statement of this form
which is true but unprovable.

1252
01:08:57,115 --> 01:08:59,720
It doesn't exhibit
a particular one.

1253
01:08:59,720 --> 01:09:03,939
Now the recursion theorem allows
you to give a particular one.

1254
01:09:03,939 --> 01:09:07,779
And the one, it
basically implements

1255
01:09:07,779 --> 01:09:10,750
Godel's so-called Godel
statement or Godel

1256
01:09:10,750 --> 01:09:15,340
sense that says, "This
statement is unprovable."

1257
01:09:15,340 --> 01:09:21,950
And you can formalize
that precisely.

1258
01:09:21,950 --> 01:09:26,310
And then that statement
becomes true but unprovable.

1259
01:09:26,310 --> 01:09:28,319
Let's just say why that is.

1260
01:09:28,319 --> 01:09:32,790
Because if the
statement were false,

1261
01:09:32,790 --> 01:09:35,819
suppose the
statement were false,

1262
01:09:35,819 --> 01:09:38,359
then, well, then it
would be provable.

1263
01:09:38,359 --> 01:09:41,990
Because the truth says
it's not provable.

1264
01:09:41,990 --> 01:09:43,729
But if the statement
were provable,

1265
01:09:43,729 --> 01:09:46,240
then it had to be
true, which would

1266
01:09:46,240 --> 01:09:48,040
mean it would be unprovable.

1267
01:09:48,040 --> 01:09:51,430
So the only viable outcome
here is that the statement

1268
01:09:51,430 --> 01:09:53,800
is unprovable.

1269
01:09:53,800 --> 01:09:59,080
And which is, it's
therefore that it's true

1270
01:09:59,080 --> 01:10:00,400
that it's unprovable.

1271
01:10:00,400 --> 01:10:01,990
So that this is
a true statement,

1272
01:10:01,990 --> 01:10:03,610
but then it has no proof.

1273
01:10:03,610 --> 01:10:10,110
And let me not go through
it because again, we're

1274
01:10:10,110 --> 01:10:11,670
unfortunately running
short on time.

1275
01:10:11,670 --> 01:10:18,150
But you can implement this using
the recursion theorem to make

1276
01:10:18,150 --> 01:10:25,370
a particular machine, R, where
you cannot prove that R does

1277
01:10:25,370 --> 01:10:27,740
not accept, say, some string 0.

1278
01:10:27,740 --> 01:10:30,730

1279
01:10:30,730 --> 01:10:33,010
So you can find a particular
R using the recursion

1280
01:10:33,010 --> 01:10:35,770
theorem, where it's
impossible to prove

1281
01:10:35,770 --> 01:10:39,370
that R doesn't accept 0.

1282
01:10:39,370 --> 01:10:43,150
Even though, by construction,
R does not accept 0.

1283
01:10:43,150 --> 01:10:44,710
So it's a little
bit slippery there

1284
01:10:44,710 --> 01:10:46,168
because you have
to understand what

1285
01:10:46,168 --> 01:10:48,130
we mean by proof within
the formal system

1286
01:10:48,130 --> 01:10:50,950
versus our external
form of reasoning,

1287
01:10:50,950 --> 01:10:54,730
but taking us a
little bit far afield.

1288
01:10:54,730 --> 01:10:59,140
So for those of you who care,
I hope this little digression

1289
01:10:59,140 --> 01:11:00,250
was interesting.

1290
01:11:00,250 --> 01:11:02,517
As I mentioned at the
beginning, for those

1291
01:11:02,517 --> 01:11:04,850
of you who don't care, you
don't have to worry about it.

1292
01:11:04,850 --> 01:11:07,225
It's not going to be on the
midterm or on the final exam.

1293
01:11:07,225 --> 01:11:09,632
You're not going to be
responsible for this last five

1294
01:11:09,632 --> 01:11:10,840
minutes or so of the lecture.

1295
01:11:10,840 --> 01:11:13,630
But I thought it's kind of
an interesting application

1296
01:11:13,630 --> 01:11:17,620
of the recursion theorem to
a problem outside of computer

1297
01:11:17,620 --> 01:11:19,090
science in mathematical logic.

1298
01:11:19,090 --> 01:11:22,000

1299
01:11:22,000 --> 01:11:27,440
OK, so here is the entire
reasoning here again.

1300
01:11:27,440 --> 01:11:31,750
I invite you to look
at that on the slide

1301
01:11:31,750 --> 01:11:35,440
that I posted if you're curious.

1302
01:11:35,440 --> 01:11:37,780
So anyway, a quick
review of today

1303
01:11:37,780 --> 01:11:39,490
is, we went through
self-reference

1304
01:11:39,490 --> 01:11:40,690
and the recursion theorem.

1305
01:11:40,690 --> 01:11:42,670
We gave a few applications.

1306
01:11:42,670 --> 01:11:45,580
And we did a sketch of Godel's
first incompleteness theorem

1307
01:11:45,580 --> 01:11:47,457
in mathematical logic.

1308
01:11:47,457 --> 01:11:49,540
OK, so that's all I'm going
to have for you today.

1309
01:11:49,540 --> 01:11:51,370
We're out of time.

1310
01:11:51,370 --> 01:11:56,950
And I will take any questions.

1311
01:11:56,950 --> 01:11:59,930
So getting back to the MIN
Turing machine example,

1312
01:11:59,930 --> 01:12:01,452
somebody is asking,
how do I know

1313
01:12:01,452 --> 01:12:03,910
there's a Turing machine that's
longer than the machine, R,

1314
01:12:03,910 --> 01:12:05,200
that I'm building?

1315
01:12:05,200 --> 01:12:08,290
Well, there are infinitely
many machines in MIN TM

1316
01:12:08,290 --> 01:12:09,952
or in the infinite
subset of MIN TM.

1317
01:12:09,952 --> 01:12:11,410
So eventually, one
of them is going

1318
01:12:11,410 --> 01:12:15,040
to have to be longer than the
machine that I'm constructing.

1319
01:12:15,040 --> 01:12:20,915
Because that's a machine
of some very specific size,

1320
01:12:20,915 --> 01:12:23,540
and so eventually there's going
to have to be one that's bigger

1321
01:12:23,540 --> 01:12:24,350
that shows up.

1322
01:12:24,350 --> 01:12:33,033

1323
01:12:33,033 --> 01:12:34,450
So this may be a
similar question.

1324
01:12:34,450 --> 01:12:38,710

1325
01:12:38,710 --> 01:12:42,340
Now, another similar question
is about, how big is R?

1326
01:12:42,340 --> 01:12:47,348
And does the size of R in
that previous thing here--

1327
01:12:47,348 --> 01:12:49,140
I don't know if we want
to go through this.

1328
01:12:49,140 --> 01:12:52,590
But, OK, let's
quickly look at it.

1329
01:12:52,590 --> 01:12:58,680
This machine, R, has a
fixed, predetermined size.

1330
01:12:58,680 --> 01:13:01,520
Its size does not depend on B.

1331
01:13:01,520 --> 01:13:05,520
It depends on E because it's
going to be simulating E.

1332
01:13:05,520 --> 01:13:08,490
But E might be producing
very, very long strings.

1333
01:13:08,490 --> 01:13:10,020
Eventually, it will.

1334
01:13:10,020 --> 01:13:11,400
So E is fixed.

1335
01:13:11,400 --> 01:13:18,520
And then, R's size is fixed.

1336
01:13:18,520 --> 01:13:20,260
So eventually, R
will find a machine

1337
01:13:20,260 --> 01:13:23,740
that's bigger than it is.

1338
01:13:23,740 --> 01:13:24,920
But let's look at--

1339
01:13:24,920 --> 01:13:29,880

1340
01:13:29,880 --> 01:13:32,460
right, so this is
a good question.

1341
01:13:32,460 --> 01:13:34,710
I was wondering if I would
get questions of this kind.

1342
01:13:34,710 --> 01:13:37,170
This is getting back to
the question in logic

1343
01:13:37,170 --> 01:13:38,460
here at the end.

1344
01:13:38,460 --> 01:13:45,220

1345
01:13:45,220 --> 01:13:49,300
Yes, because I said this
statement here is unprovable.

1346
01:13:49,300 --> 01:13:51,010
But in a sense, I proved it.

1347
01:13:51,010 --> 01:13:54,480
Because how do I know it's true?

1348
01:13:54,480 --> 01:13:57,740
And I gave you an
argument for it.

1349
01:13:57,740 --> 01:14:00,280
And so, you have
to differentiate

1350
01:14:00,280 --> 01:14:03,790
between the reasoning
that we're providing

1351
01:14:03,790 --> 01:14:06,940
and the formal system that
we're reasoning about.

1352
01:14:06,940 --> 01:14:09,880
And the formal system
that we're reasoning about

1353
01:14:09,880 --> 01:14:11,950
is not capable of proving this.

1354
01:14:11,950 --> 01:14:14,020
But we're outside
that formal system

1355
01:14:14,020 --> 01:14:16,150
so that we can reason
about the formal system.

1356
01:14:16,150 --> 01:14:18,610
I know it's a little
bit perverse seeming.

1357
01:14:18,610 --> 01:14:20,860
And mathematical logic
is a little tricky

1358
01:14:20,860 --> 01:14:24,610
because it has to deal
with those kinds of issues.

1359
01:14:24,610 --> 01:14:27,550
But this is arguing within
any particular formal system

1360
01:14:27,550 --> 01:14:33,190
of probability, this
is going to be true.

1361
01:14:33,190 --> 01:14:38,920
But that's kind of
an approximation

1362
01:14:38,920 --> 01:14:41,110
to our own thought process.

1363
01:14:41,110 --> 01:14:44,560
So it's slippery, I agree.

1364
01:14:44,560 --> 01:14:52,440

1365
01:14:52,440 --> 01:14:54,720
So, a good question here,
would Godel's theorem still

1366
01:14:54,720 --> 01:14:58,020
hold informal systems where
we don't require that proofs

1367
01:14:58,020 --> 01:14:59,610
of statements are decidable?

1368
01:14:59,610 --> 01:15:02,190
So I'm not saying that
the proofs are decidable.

1369
01:15:02,190 --> 01:15:04,050
That you can--
proofs are checkable.

1370
01:15:04,050 --> 01:15:07,620
So you can test whether
a proof is a proof.

1371
01:15:07,620 --> 01:15:09,570
If you can't test whether
a proof is a proof,

1372
01:15:09,570 --> 01:15:14,230
I don't know of any people who
have studied that situation.

1373
01:15:14,230 --> 01:15:18,030
So that's a little bit
of a trickier case.

1374
01:15:18,030 --> 01:15:21,850
I'm not sure what
to say about that.

1375
01:15:21,850 --> 01:15:25,120
Can I give an example of two
equivalent Turing machines

1376
01:15:25,120 --> 01:15:27,920
where one has a shorter
description than the other?

1377
01:15:27,920 --> 01:15:32,380
How do we define the
length of the description?

1378
01:15:32,380 --> 01:15:39,940
Well, we never really precisely
defined our encoding system.

1379
01:15:39,940 --> 01:15:43,300
But whatever encoding
system you want to use,

1380
01:15:43,300 --> 01:15:50,330
is going to represent
Turing machines as strings.

1381
01:15:50,330 --> 01:15:52,330
And those strings are
going to have a length.

1382
01:15:52,330 --> 01:15:55,150
And so, it doesn't
really matter which

1383
01:15:55,150 --> 01:15:58,540
encoding system you're going to
use because the statement isn't

1384
01:15:58,540 --> 01:16:00,190
going to be true in any of them.

1385
01:16:00,190 --> 01:16:02,380
We could go through the
exercise of defining

1386
01:16:02,380 --> 01:16:03,970
a particular encoding system.

1387
01:16:03,970 --> 01:16:06,950
It's going to be pretty
tedious to do that.

1388
01:16:06,950 --> 01:16:11,500
But you can just imagine writing
down the states, the transition

1389
01:16:11,500 --> 01:16:17,058
function, et cetera, et cetera,
as this big long string.

1390
01:16:17,058 --> 01:16:18,850
And that's going to be
our encoding system.

1391
01:16:18,850 --> 01:16:20,933
And then there are going
to be some long machines.

1392
01:16:20,933 --> 01:16:23,890
Some machines will have
long representations

1393
01:16:23,890 --> 01:16:26,050
and other machines that
have short representations.

1394
01:16:26,050 --> 01:16:30,010
And there's going to
be some machine where

1395
01:16:30,010 --> 01:16:31,930
you can introduce a
bunch of useless states

1396
01:16:31,930 --> 01:16:33,410
that are never accessed.

1397
01:16:33,410 --> 01:16:36,550
So you can expand--

1398
01:16:36,550 --> 01:16:40,347
you can kind of add
junk to the description

1399
01:16:40,347 --> 01:16:42,430
of the machine, which is
not going to do anything.

1400
01:16:42,430 --> 01:16:45,040
But it's just going to make
the description of the machine

1401
01:16:45,040 --> 01:16:48,190
unnecessarily long
compared to what

1402
01:16:48,190 --> 01:16:50,260
with some other
description, which

1403
01:16:50,260 --> 01:16:54,200
is going to compute the same
thing but will be much shorter.

1404
01:16:54,200 --> 01:16:56,560
So you can certainly
find examples

1405
01:16:56,560 --> 01:17:01,040
of pairs of machines that
do the same thing where one

1406
01:17:01,040 --> 01:17:02,290
is much longer than the other.

1407
01:17:02,290 --> 01:17:05,720

1408
01:17:05,720 --> 01:17:08,230
So I will then close
the session here.

1409
01:17:08,230 --> 01:17:15,370
And I will be very shortly
on the office hours link

1410
01:17:15,370 --> 01:17:18,720
and see some of you there.

1411
01:17:18,720 --> 01:17:32,000

